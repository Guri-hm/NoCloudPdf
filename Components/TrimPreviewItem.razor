@using NoCloudPdf.Models
@using System.Text.Json
@inject IJSRuntime JSRuntime
@inject NoCloudPdf.Services.PdfDataService PdfDataService
@implements IAsyncDisposable

<div id="preview-container-@Index" class="relative mb-4 w-full flex justify-center">
    <div class="absolute top-2 left-1/2 -translate-x-1/2 z-20 px-2 py-1 rounded text-sm" data-no-scale>
        <div class="flex items-center gap-2 text-xs font-semibold px-2 py-0.5 rounded max-w-[80vw]"
             title="@Item?.FullFileName"
             style="background:@(string.IsNullOrWhiteSpace(Item?.ColorHsl) ? "rgba(0,0,0,0.7)" : Item.ColorHsl)">
            <span class="truncate">@Item?.DisplayName</span>
            <span class="flex-shrink-0">@(string.IsNullOrEmpty(Item?.PageInfo) ? "" : Item.PageInfo)</span>
        </div>
    </div>

    <div class="w-full">
        <canvas id="@CanvasId" @ref="canvasRef" class="block mx-auto"></canvas>
    </div>

    <div class="absolute inset-0 flex items-center justify-center bg-white/60 z-30" hidden="@(!isLoading)">
        <svg class="w-12 h-12 text-blue-600 animate-spin" viewBox="0 0 50 50" aria-hidden="true" role="img">
            <circle cx="25" cy="25" r="20" fill="none" stroke="currentColor" stroke-width="4" class="opacity-20"></circle>
            <path d="M45 25a20 20 0 0 1-20 20" fill="none" stroke="currentColor" stroke-width="4" stroke-linecap="round"></path>
        </svg>
    </div>
</div>

@code {
    [Parameter] public DisplayItem Item { get; set; } = default!;
    [Parameter] public int Index { get; set; }
    [Parameter] public bool IsDrawingMode { get; set; } = false;
    [Parameter] public bool AllowMultipleRects { get; set; } = false;

    private ElementReference canvasRef;
    private bool isLoading = true;
    private bool isInitialized = false; // 初回初期化フラグ
    private string CanvasId => $"trim-preview-canvas-{Index}";

    private DotNetObjectReference<TrimPreviewItem>? _dotNetRef;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        Console.WriteLine($"OnAfterRenderAsync called idx={Index}");
        // 初期化済みならスキップ
        if (isInitialized) return;
        
        // 初回または再レンダリング時に描画を試行
        await InitializeCanvasAsync();
    }

    private async Task InitializeCanvasAsync()
    {
        try
        {
            if (Item.RawData is not PageItem page) return;

            // 画像ソース取得
            string? src = null;
            if (!string.IsNullOrEmpty(page.PageData) && !page.HasPageDataError)
            {
                src = await PdfDataService.GetPreviewImageAsync(page.Id);
            }

            if (string.IsNullOrEmpty(src)) return;

            // Canvas に描画
            await JSRuntime.InvokeAsync<bool>("drawImageToCanvasForPreview", CanvasId, src, true);

            // Canvas の準備完了を待つ（単一の待機処理）
            const int CANVAS_READY_TIMEOUT_MS = 500;
            var ready = await JSRuntime.InvokeAsync<bool>("waitForCanvasReady", CanvasId, CANVAS_READY_TIMEOUT_MS);

            // ローディング解除
            if (isLoading)
            {
                isLoading = false;
                StateHasChanged();
            }

            // 初回のみリスナー登録と矩形復元
            if (!isInitialized)
            {
                await InitializeTrimmingAsync();
                isInitialized = true;
            }
        }
        catch (OperationCanceledException)
        {
            // キャンセル時は無視
        }
        catch (Exception ex)
        {
            Console.WriteLine($"TrimPreviewItem.InitializeCanvasAsync error idx={Index}: {ex.Message}");
            if (isLoading)
            {
                isLoading = false;
                StateHasChanged();
            }
        }
    }

    private async Task InitializeTrimmingAsync()
    {
        try
        {
            _dotNetRef ??= DotNetObjectReference.Create(this);

            // リスナー登録
            if (IsDrawingMode)
            {
                await JSRuntime.InvokeAsync<bool>("attachTrimListeners", CanvasId, _dotNetRef, "single", AllowMultipleRects);
            }

            // 保存されている矩形を復元
            if (AllowMultipleRects)
            {
                var rects = PdfDataService.GetTrimRects(Index);
                if (rects != null && rects.Count > 0)
                {
                    var rectsToRender = rects.Select(r => new { X = r.X, Y = r.Y, Width = r.Width, Height = r.Height }).ToArray();
                    await JSRuntime.InvokeVoidAsync("drawTrimOverlayAsSvg", CanvasId, rectsToRender);
                }
                else
                {
                    await JSRuntime.InvokeVoidAsync("drawTrimOverlayAsSvg", CanvasId, Array.Empty<object>());
                }
            }
            else
            {
                var r = PdfDataService.GetTrimRect(Index);
                if (r != null)
                {
                    var rect = new { X = r.X, Y = r.Y, Width = r.Width, Height = r.Height };
                    await JSRuntime.InvokeVoidAsync("drawTrimOverlayAsSvg", CanvasId, new[] { rect });
                }
                else
                {
                    await JSRuntime.InvokeVoidAsync("drawTrimOverlayAsSvg", CanvasId, Array.Empty<object>());
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"TrimPreviewItem.InitializeTrimmingAsync error idx={Index}: {ex.Message}");
        }
    }

    // JS から単一矩形が確定したときに呼ばれる
    [JSInvokable("CommitTrimRectFromJs")]
    public Task CommitTrimRectFromJs(double x, double y, double width, double height)
    {
            return PdfDataService.SetTrimRect(Index, x, y, width, height,notify: false);
    }

    // JS から複数矩形が確定したときに呼ばれる
    [JSInvokable("CommitMultipleRectsFromJs")]
    public async Task CommitMultipleRectsFromJs(JsonElement[] rects)
    {
        try
        {
            if (rects == null || rects.Length == 0)
            {
                PdfDataService.ClearTrimRect(Index);
                return;
            }

            var rectList = new List<TrimRectInfo>();

            foreach (var rect in rects)
            {
                if (rect.TryGetProperty("X", out var xProp) &&
                    rect.TryGetProperty("Y", out var yProp) &&
                    rect.TryGetProperty("Width", out var wProp) &&
                    rect.TryGetProperty("Height", out var hProp))
                {
                    rectList.Add(new TrimRectInfo
                    {
                        X = xProp.GetDouble(),
                        Y = yProp.GetDouble(),
                        Width = wProp.GetDouble(),
                        Height = hProp.GetDouble()
                    });
                }
            }

            if (rectList.Count > 0)
            {
                await PdfDataService.SetTrimRects(Index, rectList);
                Console.WriteLine($"CommitMultipleRectsFromJs: saved {rectList.Count} rects for idx={Index}");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"CommitMultipleRectsFromJs failed idx={Index}: {ex.Message}");
        }
    }

    // JS から削除要求があったときに呼ばれる
    [JSInvokable("ClearTrimRectFromJs")]
    public Task ClearTrimRectFromJs()
    {
        try
        {
            PdfDataService.ClearTrimRect(Index);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"ClearTrimRectFromJs failed idx={Index}: {ex.Message}");
        }
        return Task.CompletedTask;
    }

    public async ValueTask DisposeAsync()
    {
        try { await JSRuntime.InvokeVoidAsync("detachTrimListeners", CanvasId); } catch { }
        try { _dotNetRef?.Dispose(); } catch { }
        _dotNetRef = null;
    }
}