@using NoCloudPdf.Models
@inject IJSRuntime JSRuntime
@inject NoCloudPdf.Services.PdfDataService PdfDataService

<div id="preview-container-@Index" class="relative mb-4 w-full flex justify-center">
    <div class="absolute top-2 left-1/2 -translate-x-1/2 z-20 px-2 py-1 rounded text-sm" data-no-scale>
        <div class="flex items-center gap-2 text-xs font-semibold px-2 py-0.5 rounded max-w-[80vw]"
             title="@Item.FullFileName"
             style="background:@(string.IsNullOrWhiteSpace(Item?.ColorHsl) ? "rgba(0,0,0,0.7)" : Item.ColorHsl)">
            <span class="truncate">@Item.DisplayName</span>
            <span class="flex-shrink-0">@(string.IsNullOrEmpty(Item?.PageInfo) ? "" : Item.PageInfo) @(IsDrawingMode ? "Drawing" : "Not Drawing")</span>
        </div>
    </div>

    <div class="w-full">
        <canvas id="@CanvasId" @ref="canvasRef" class="block mx-auto"></canvas>
    </div>

    <div class="absolute inset-0 flex items-center justify-center bg-white/60 z-30"
         hidden="@(!isLoading)">
        <svg class="w-12 h-12 text-blue-600 animate-spin" viewBox="0 0 50 50" aria-hidden="true" role="img">
            <circle cx="25" cy="25" r="20" fill="none" stroke="currentColor" stroke-width="4" class="opacity-20"></circle>
            <path d="M45 25a20 20 0 0 1-20 20" fill="none" stroke="currentColor" stroke-width="4" stroke-linecap="round"></path>
        </svg>
    </div>
</div>

@code {
    [Parameter] public DisplayItem Item { get; set; } = default!;
    [Parameter] public int Index { get; set; }
    [Parameter] public bool IsDrawingMode { get; set; } = false;

    private ElementReference canvasRef;
    private bool isLoading = true;
    private string CanvasId => $"trim-preview-canvas-{Index}";

    private DotNetObjectReference<TrimPreviewItem>? _dotNetRef;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        // まず描画処理を試行
        await EnsureImageRenderedAsync();

        // 画像がまだロード中ならここで終了
        if (isLoading) return;

        // リスナ登録
        await EnsureListenersAndOverlayAsync();
    }

    // JS から確定矩形が届いたらサービスに保存して UI を更新
    [JSInvokable("CommitTrimRectFromJs")]
    public async Task CommitTrimRectFromJs(double x, double y, double width, double height)
    {
        try
        {
            await PdfDataService.SetTrimRect(Index, x, y, width, height);
            // SetTrimRect は UI通知を行うので StateHasChanged はサービス側で引き起こされます。
        }
        catch (Exception ex)
        {
            Console.WriteLine($"CommitTrimRectFromJs failed idx={Index}: {ex.Message}");
        }
    }
    // JS側から「削除（クリア）」を要求されたときに呼ばれるメソッド
    [JSInvokable("ClearTrimRectFromJs")]
    public Task ClearTrimRectFromJs()
    {
        try
        {
            PdfDataService.ClearTrimRect(Index);
            InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"ClearTrimRectFromJs failed idx={Index}: {ex.Message}");
        }
        return Task.CompletedTask;
    }

    private async Task EnsureImageRenderedAsync()
    {
        // 調整しやすい定数
        const int FAST_WAIT_MS = 100;      // 速戻し判定（ユーザーの待ち時間を短縮）
        const int STABLE_WAIT_MS = 400;    // 長めの安定判定（裏で確実に安定を待つ）
        const int DRAW_TASK_TIMEOUT_MS = 1500; // drawTask の最大待ち時間（バックグラウンド）

        try
        {
            if (Item.RawData is not PageItem page) return;

            string? src = null;
            if (!string.IsNullOrEmpty(page.PageData) && !page.HasPageDataError)
            {
                src = await PdfDataService.GetPreviewImageAsync(page.Id);
            }

            if (string.IsNullOrEmpty(src)) return;

            // start draw task but don't block UI for too long
            var drawTask = JSRuntime.InvokeAsync<bool>("drawImageToCanvasForPreview", CanvasId, src, true).AsTask();

            // fast path: まず短時間待って見た目を早く戻す
            bool ready = false;
            try
            {
                ready = await JSRuntime.InvokeAsync<bool>("waitForCanvasReady", CanvasId, FAST_WAIT_MS);
            }
            catch { ready = false; }

            if (ready && isLoading)
            {
                isLoading = false;
                await InvokeAsync(StateHasChanged);
                // drawTask は裏で完了する
            }
            else
            {
                // hide spinner ASAP so UI is responsive
                if (isLoading)
                {
                    isLoading = false;
                    await InvokeAsync(StateHasChanged);
                }

                // background continuation: wait for drawTask (capped) and a longer stability check,
                // then attach/listen/draw overlay on UI thread.
                _ = Task.Run(async () =>
                {
                    try
                    {
                        var completed = await Task.WhenAny(drawTask, Task.Delay(DRAW_TASK_TIMEOUT_MS));
                        // 長めに安定確認
                        var stable = false;
                        try { stable = await JSRuntime.InvokeAsync<bool>("waitForCanvasReady", CanvasId, STABLE_WAIT_MS); } catch { stable = false; }

                        await InvokeAsync(async () =>
                        {
                            try
                            {
                                await EnsureListenersAndOverlayAsync();
                            }
                            catch { }
                        });
                    }
                    catch (Exception ex) { Console.WriteLine($"Background drawTask continuation failed idx={Index}: {ex.Message}"); }
                });
            }
        }
        catch (OperationCanceledException) { }
        catch (Exception ex)
        {
            Console.WriteLine($"TrimPreviewItem render error idx={Index}: {ex.Message}");
        }
    }

    private async Task EnsureListenersAndOverlayAsync()
    {
        try
        {
            _dotNetRef ??= DotNetObjectReference.Create(this);

            // 先に確実に古いリスナ/overlay を削除してから attach（JS 側でも二重ガードあり）
            try
            {
                await JSRuntime.InvokeAsync<bool>("detachTrimListeners", CanvasId);
            }
            catch { /* ignore if detach not available */ }

            if (IsDrawingMode)
            {
                try
                {
                    var attached = await JSRuntime.InvokeAsync<bool>("attachTrimListeners", CanvasId, _dotNetRef);
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"TrimPreviewItem attach listeners failed idx={Index}: {ex.Message}");
                }
            }
            else
            {
                try
                {
                    await JSRuntime.InvokeAsync<bool>("detachTrimListeners", CanvasId);
                }
                catch { }
            }

            // 保存されている矩形があれば描画、なければ clear を呼ぶ
            try
            {
                var r = PdfDataService.GetTrimRect(Index);
                if (r != null)
                {
                    var rect = new { X = r.X, Y = r.Y, Width = r.Width, Height = r.Height };
                    await JSRuntime.InvokeVoidAsync("drawTrimOverlayAsSvg", CanvasId, new[] { rect });
                }
                else
                {
                    await JSRuntime.InvokeVoidAsync("drawTrimOverlayAsSvg", CanvasId, Array.Empty<object>());
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"TrimPreviewItem draw existing rect failed idx={Index}: {ex.Message}");
            }
        }
        catch { }
    }

    public void Dispose()
    {
        try { _ = JSRuntime.InvokeVoidAsync("detachTrimListeners", CanvasId); } catch { }
        try { _dotNetRef?.Dispose(); } catch { }
    }
}