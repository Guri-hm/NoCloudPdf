@using NoCloudPdf.Models
@using System.Text.Json
@inject IJSRuntime JSRuntime
@inject NoCloudPdf.Services.PdfDataService PdfDataService
@implements IAsyncDisposable

<div id="preview-container-@Index" class="relative w-full h-full flex items-start justify-center">

    <!-- Canvas（中央配置） -->
    <canvas id="@CanvasId" 
            data-item-id="@(Item?.RawData is PageItem page ? page.Id : "")"
            @ref="canvasRef" 
            class="block" style="padding: 20px;"></canvas>

    <!-- ローディング表示 -->
    <div class="absolute inset-0 flex items-center justify-center bg-white/60 z-20" hidden="@(!isLoading)">
        <LoadingSpinnerIcon Class="w-12 h-12" />
    </div>
</div>


@code {
    [Parameter] public DisplayItem Item { get; set; } = default!;
    [Parameter] public int Index { get; set; }
    // 今後の拡張(styleの切り替えなど)のためにパラメータを渡しているが現状利用していない
    [Parameter] public bool IsDrawingMode { get; set; } = false;
    [Parameter] public bool AllowMultipleRects { get; set; } = false;

    private ElementReference canvasRef;
    private bool isLoading = true;
    private bool isCanvasDrawn = false;
    private string CanvasId => $"trim-preview-canvas-{Index}";

    private DotNetObjectReference<TrimPreviewItem>? _dotNetRef;

    protected override void OnInitialized()
    {
        PdfDataService.OnChange += OnServiceChanged;
    }

    private void OnServiceChanged()
    {
        if (!isCanvasDrawn && Item.RawData is PageItem page && 
            !string.IsNullOrEmpty(page.PageData) && !page.HasPageDataError)
        {
            _ = InvokeAsync(async () =>
            {
                try
                {
                    await InitializeCanvasAsync();
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"[OnServiceChanged] InitializeCanvasAsync failed idx={Index}: {ex.Message}");
                }
            });
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            try
            {
                await InitializeCanvasAsync();
            }
            catch (Exception ex)
            {
                Console.WriteLine($"InitializeCanvasAsync error idx={Index}: {ex.Message}");
            }
        }
    }


    private async Task InitializeCanvasAsync()
    {
        try
        {
            if (Item.RawData is not PageItem page) return;

            string? src = null;
            if (!string.IsNullOrEmpty(page.PageData) && !page.HasPageDataError)
            {
                src = await PdfDataService.GetPreviewImageAsync(page.Id, null, "preview");
            }

            if (string.IsNullOrEmpty(src)) return;

            var originalSize = await JSRuntime.InvokeAsync<Dictionary<string, double>>("getPdfPageOriginalSize", page.PageData);

            // Canvas に直接描画
            await JSRuntime.InvokeAsync<bool>("drawImageToCanvasForPreview", CanvasId, src, true);

            // Canvas に元PDFサイズを保存（data属性）
            if (originalSize != null)
            {
                await JSRuntime.InvokeVoidAsync("setCanvasOriginalSize", CanvasId, originalSize["width"], originalSize["height"]);
            }

            // 初期表示時に全体表示を適用（自動フィットモードは有効化しない）
            try
            {
                double initialScale = await JSRuntime.InvokeAsync<double>("fitPreviewToViewport", CanvasId, "fit-both");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Initial fit-both failed idx={Index}: {ex.Message}");
            }

            if (isLoading)
            {
                isLoading = false;
                await InvokeAsync(StateHasChanged);
            }

            isCanvasDrawn = true;

            await InitializeTrimmingAsync();
        }
        catch (OperationCanceledException) { }
        catch (Exception ex)
        {
            Console.WriteLine($"TrimPreviewItem.InitializeCanvasAsync error idx={Index}: {ex.Message}");
            if (isLoading)
            {
                isLoading = false;
                await InvokeAsync(StateHasChanged);
            }
        }
    }


    private async Task InitializeTrimmingAsync()
    {
        try
        {
            _dotNetRef ??= DotNetObjectReference.Create(this);

            await JSRuntime.InvokeAsync<bool>("attachTrimListeners", CanvasId, _dotNetRef, "single", AllowMultipleRects);

            await RedrawTrimOverlayAsync();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"TrimPreviewItem.InitializeTrimmingAsync error idx={Index}: {ex.Message}");
        }
    }

    // キャッシュクリア後の再描画用メソッド（外部から呼び出し可能）
    public async Task RefreshCanvasAsync()
    {
        isCanvasDrawn = false;  // Canvas描画フラグだけリセット（トリミング初期化は維持）
        StateHasChanged();  // OnAfterRenderAsync を再実行
        await Task.CompletedTask;
    }

    // 矩形描画だけを再実行する public メソッド（外部から呼べる）
    public async Task RedrawTrimOverlayAsync()
    {
        try
        {
            if (AllowMultipleRects)
            {
                var rects = PdfDataService.GetTrimRects(Index);
                if (rects != null && rects.Count > 0)
                {
                    var rectsToRender = rects.Select(r => new { X = r.X, Y = r.Y, Width = r.Width, Height = r.Height }).ToArray();
                    await JSRuntime.InvokeVoidAsync("drawTrimOverlayAsSvg", CanvasId, rectsToRender);
                }
                else
                {
                    await JSRuntime.InvokeVoidAsync("drawTrimOverlayAsSvg", CanvasId, Array.Empty<object>());
                }
            }
            else
            {
                var r = PdfDataService.GetTrimRect(Index);
                if (r != null)
                {
                    var rect = new { X = r.X, Y = r.Y, Width = r.Width, Height = r.Height };
                    await JSRuntime.InvokeVoidAsync("drawTrimOverlayAsSvg", CanvasId, new[] { rect });
                }
                else
                {
                    await JSRuntime.InvokeVoidAsync("drawTrimOverlayAsSvg", CanvasId, Array.Empty<object>());
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"RedrawTrimOverlayAsync error idx={Index}: {ex.Message}");
        }
    }

    [JSInvokable("CommitTrimRectFromJs")]
    public Task CommitTrimRectFromJs(double x, double y, double width, double height)
    {
        PdfDataService.SetTrimRect(Index, x, y, width, height, notify: false);
        return Task.CompletedTask;
    }

    [JSInvokable("CommitMultipleRectsFromJs")]
    public void CommitMultipleRectsFromJs(JsonElement[] rects)
    {
        try
        {
            if (rects == null || rects.Length == 0)
            {
                PdfDataService.ClearTrimRect(Index);
                return;
            }

            var rectList = new List<TrimRectInfo>();

            foreach (var rect in rects)
            {
                if (rect.TryGetProperty("X", out var xProp) &&
                    rect.TryGetProperty("Y", out var yProp) &&
                    rect.TryGetProperty("Width", out var wProp) &&
                    rect.TryGetProperty("Height", out var hProp))
                {
                    rectList.Add(new TrimRectInfo
                    {
                        X = xProp.GetDouble(),
                        Y = yProp.GetDouble(),
                        Width = wProp.GetDouble(),
                        Height = hProp.GetDouble()
                    });
                }
            }

            if (rectList.Count > 0)
            {
                PdfDataService.SetTrimRects(Index, rectList, notify: false);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"CommitMultipleRectsFromJs failed idx={Index}: {ex.Message}");
        }
    }

    [JSInvokable("ClearTrimRectFromJs")]
    public Task ClearTrimRectFromJs()
    {
        try
        {
            PdfDataService.ClearTrimRect(Index);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"ClearTrimRectFromJs failed idx={Index}: {ex.Message}");
        }
        return Task.CompletedTask;
    }

    public async ValueTask DisposeAsync()
    {
        try { PdfDataService.OnChange -= OnServiceChanged; } catch { }
        
        try { await JSRuntime.InvokeVoidAsync("detachTrimListeners", CanvasId); } catch { }
        try { _dotNetRef?.Dispose(); } catch { }
        _dotNetRef = null;
    }
}