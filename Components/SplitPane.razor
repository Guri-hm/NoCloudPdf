@using Microsoft.JSInterop
@implements IAsyncDisposable
@inject IJSRuntime JSRuntime

<div id="@ContainerId" class="flex-1 flex overflow-hidden">
    <div id="@LeftId" 
         class="flex-shrink-0 overflow-y-auto @LeftAreaClass"
         style="flex-basis: @(LeftWidth)px; min-width: 150px; max-width: 600px;">
        @Left
    </div>

    <div id="@HandleId" 
         class="w-1 bg-gray-400 cursor-ew-resize hover:bg-blue-500 flex-shrink-0"
         style="touch-action: none;">
    </div>

    <div class="flex-1 overflow-auto min-w-[260px]">
        <div id="@RightContainerId" class="relative h-full @RightAreaClass">
            @Right
        </div>
    </div>
</div>

@code {
    [Parameter] public RenderFragment? Left { get; set; }
    [Parameter] public RenderFragment? Right { get; set; }

    [Parameter] public int LeftWidth { get; set; } = 300;
    [Parameter] public EventCallback<int> LeftWidthChanged { get; set; }

    [Parameter] public string LeftAreaClass { get; set; } = "border-r border-gray-300 p-4";
    [Parameter] public string RightAreaClass { get; set; } = "flex flex-col gap-4";

    [Parameter] public string ContainerId { get; set; } = "split-container";
    [Parameter] public string LeftId { get; set; } = "thumbnail-area";
    [Parameter] public string HandleId { get; set; } = "splitter-handle";
    [Parameter] public string RightContainerId { get; set; } = "trim-preview-container";

    // ウィンドウリサイズ時の自動調整を有効化するか
    [Parameter] public bool EnableAutoResize { get; set; } = true;

    private DotNetObjectReference<SplitPane>? _dotNetRef;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _dotNetRef = DotNetObjectReference.Create(this);
            
            try
            {
                // パネルリサイズハンドラ登録
                await JSRuntime.InvokeVoidAsync("registerPanelResize", _dotNetRef, HandleId);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"registerPanelResize failed: {ex.Message}");
            }

            // ウィンドウリサイズハンドラ登録
            if (EnableAutoResize)
            {
                try
                {
                    await JSRuntime.InvokeVoidAsync("registerWindowResize", _dotNetRef);
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"registerWindowResize failed: {ex.Message}");
                }
            }
        }
    }

    // JS(registerPanelResize) から確定幅を受け取る
    [JSInvokable("CommitPanelWidth")]
    public async Task CommitPanelWidth(int width)
    {
        LeftWidth = Math.Max(150, Math.Min(600, width));
        await LeftWidthChanged.InvokeAsync(LeftWidth);
    }

    // JS(registerWindowResize) から呼ばれる
    [JSInvokable("OnWindowResizedFromJs")]
    public async Task OnWindowResizedFromJs(int availableWidth, int sidebarWidth)
    {
        try
        {
            // 利用可能幅の 25% を基準に、最小/最大範囲内でクランプ
            var computed = (int)Math.Round(availableWidth * 0.25);
            var newWidth = Math.Max(150, Math.Min(600, computed));

            // 幅が変わった場合のみ通知
            if (newWidth != LeftWidth)
            {
                LeftWidth = newWidth;
                await LeftWidthChanged.InvokeAsync(LeftWidth);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"OnWindowResizedFromJs error: {ex.Message}");
        }
    }

    public async ValueTask DisposeAsync()
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("unregisterPanelResize");
        }
        catch { }

        try
        {
            await JSRuntime.InvokeVoidAsync("unregisterWindowResize");
        }
        catch { }

        _dotNetRef?.Dispose();
        _dotNetRef = null;
    }
}