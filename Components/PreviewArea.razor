@* filepath: Components/PreviewArea.razor *@
@using NoCloudPdf.Models
@inject IJSRuntime JSRuntime
@inject NoCloudPdf.Services.PdfDataService PdfDataService
@implements IAsyncDisposable

<div id="preview-zoom-viewport" class="w-full h-full overflow-auto custom-scrollbar">
    @if (CurrentItem != null)
    {
        <TrimPreviewItem @key="@GetItemKey()"
            Item="@CurrentItem"
            Index="@CurrentIndex"
            IsDrawingMode="@IsDrawingMode" 
            AllowMultipleRects="@AllowMultipleRects" />
    }
</div>

<!-- 下部操作バー -->
<div class="absolute bottom-8 left-1/2 -translate-x-1/2 flex bg-black/60 px-0 rounded-lg min-h-12 shadow-lg z-50"
    @onclick:stopPropagation>
    <div class="flex w-full items-stretch divide-x divide-gray-400 rounded-lg">
        <button @onclick="PrevPage" disabled="@(CurrentPageNumber <= 1)"
                class="icon-btn flex-1 flex items-center justify-center py-4 px-4 hover:bg-gray-700 transition rounded-l-lg disabled:opacity-50"
                title="前のページ">
            <i class="text-white fa-solid fa-chevron-left"></i>
        </button>
        
        <div class="flex-1 px-2 flex items-center justify-center text-white font-bold whitespace-nowrap">
            <input type="number" min="1" max="@TotalPages" value="@CurrentPageNumber"
                class="w-12 h-full text-center rounded bg-gray-800 text-white border border-gray-400 mx-1"
                @onchange="OnPageInputChanged" />
            <span>/ @TotalPages</span>
        </div>
        
        <button @onclick="NextPage" disabled="@(CurrentPageNumber >= TotalPages)"
                class="icon-btn flex-1 flex items-center justify-center py-4 px-4 hover:bg-gray-700 transition"
                title="次のページ">
            <i class="text-white fa-solid fa-chevron-right"></i>
        </button>
        
        <button @onclick="ZoomOut" class="icon-btn flex-1 flex items-center justify-center py-4 px-4 hover:bg-gray-700 transition" title="縮小">
            <ZoomOutIcon Class="w-5 h-5 text-white" />
        </button>
        
        <button @onclick="ZoomIn" class="icon-btn flex-1 flex items-center justify-center py-4 px-4 hover:bg-gray-700 transition" title="拡大">
            <ZoomInIcon Class="w-5 h-5 text-white" />
        </button>
        
        <button @onclick="FitWidth" class="icon-btn flex-1 flex items-center justify-center py-4 px-4 hover:bg-gray-700 transition" title="幅に合わせる">
            <FitWidthIcon Class="w-5 h-5 text-white" />
        </button>
        
        <button @onclick="FitHeight" class="icon-btn flex-1 flex items-center justify-center py-4 px-4 hover:bg-gray-700 transition" title="高さに合わせる">
            <FitHeightIcon Class="w-5 h-5 text-white" />
        </button>
        
        <button @onclick="FitBoth" class="icon-btn flex-1 flex items-center justify-center py-4 px-4 hover:bg-gray-700 transition rounded-r-lg" title="全体表示">
            <FitScreenIcon Class="w-5 h-5 text-white" />
        </button>
    </div>
</div>

@code {
    [Parameter] public List<DisplayItem> Items { get; set; } = new();
    [Parameter] public int CurrentPageNumber { get; set; } = 1;
    [Parameter] public EventCallback<int> CurrentPageNumberChanged { get; set; }
    [Parameter] public bool IsDrawingMode { get; set; } = true;
    [Parameter] public int RotationCounter { get; set; } = 0;
    [Parameter] public bool AllowMultipleRects { get; set; } = false;

    private DisplayItem? CurrentItem => (CurrentIndex >= 0 && CurrentIndex < Items.Count) ? Items[CurrentIndex] : null;
    private int CurrentIndex => CurrentPageNumber - 1;
    private int TotalPages => Items.Count;

    private string GetItemKey() => CurrentItem != null ? $"{CurrentItem.Id}-{RotationCounter}" : "empty";

    private async Task PrevPage()
    {
        if (CurrentPageNumber > 1)
        {
            CurrentPageNumber--;
            await CurrentPageNumberChanged.InvokeAsync(CurrentPageNumber);
        }
    }

    private async Task NextPage()
    {
        if (CurrentPageNumber < TotalPages)
        {
            CurrentPageNumber++;
            await CurrentPageNumberChanged.InvokeAsync(CurrentPageNumber);
        }
    }

    private async Task OnPageInputChanged(ChangeEventArgs e)
    {
        if (int.TryParse(e?.Value?.ToString(), out var page))
        {
            CurrentPageNumber = Math.Max(1, Math.Min(TotalPages, page));
            await CurrentPageNumberChanged.InvokeAsync(CurrentPageNumber);
        }
    }

    private async Task ZoomIn()
    {
        try { await JSRuntime.InvokeVoidAsync("clearAutoFitMode"); } catch { }
        var canvasId = $"trim-preview-canvas-{CurrentIndex}";
        var currentScale = await JSRuntime.InvokeAsync<double>("getCurrentPreviewZoom", canvasId);
        var newZoom = Math.Min(3.0, (currentScale > 0 ? currentScale : 1.0) + 0.25);
        await JSRuntime.InvokeVoidAsync("setPreviewZoom", newZoom);
    }

    private async Task ZoomOut()
    {
        try { await JSRuntime.InvokeVoidAsync("clearAutoFitMode"); } catch { }
        var canvasId = $"trim-preview-canvas-{CurrentIndex}";
        var currentScale = await JSRuntime.InvokeAsync<double>("getCurrentPreviewZoom", canvasId);
        var newZoom = Math.Max(0.25, (currentScale > 0 ? currentScale : 1.0) - 0.25);
        await JSRuntime.InvokeVoidAsync("setPreviewZoom", newZoom);
    }

    private async Task FitWidth()
    {
        var canvasId = $"trim-preview-canvas-{CurrentIndex}";
        await JSRuntime.InvokeVoidAsync("setAutoFitMode", "width");
        await JSRuntime.InvokeAsync<double>("fitPreviewToViewport", canvasId, "fit-width");
    }

    private async Task FitHeight()
    {
        var canvasId = $"trim-preview-canvas-{CurrentIndex}";
        await JSRuntime.InvokeVoidAsync("setAutoFitMode", "height");
        await JSRuntime.InvokeAsync<double>("fitPreviewToViewport", canvasId, "fit-height");
    }

    private async Task FitBoth()
    {
        var canvasId = $"trim-preview-canvas-{CurrentIndex}";
        await JSRuntime.InvokeVoidAsync("setAutoFitMode", "both");
        await JSRuntime.InvokeAsync<double>("fitPreviewToViewport", canvasId, "fit-both");
    }

    public async ValueTask DisposeAsync()
    {
        // 必要に応じてクリーンアップ
        await Task.CompletedTask;
    }
}