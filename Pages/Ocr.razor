@page "/ocr"
@implements IAsyncDisposable
@inject IJSRuntime JSRuntime
@inject PdfDataService PdfDataService
@inject MessageService MessageService
@inject CompletionStateService CompletionState
@using Microsoft.AspNetCore.Components.Web
@using Microsoft.JSInterop
@using System.IO
@using NoCloudPdf.Models
@using NoCloudPdf.Services
@using NoCloudPdf.Components

<PageTitle>NoCloudPDF-OCR</PageTitle>

@if (IsFilesLoaded && !CompletionState.ShowResult && currentState == OcrWorkflowState.Editing)
{
    <div id="drop-area" class="relative h-screen flex flex-col">
        <DropCover Message="ここにファイルをドロップ" />
        
        <!-- 上部固定バー -->
        <div class="sticky top-0 left-0 w-full max-w-full bg-gray-800 text-white shadow z-50">
            <div class="flex items-start justify-between px-4 py-2 scrollbar-thin scrollbar-thumb-gray-400 scrollbar-track-gray-200">
                <div class="flex flex-wrap gap-2 items-center">
                    <ActionButtonGroup T="string" Actions="resetActions" />
                    <div class="hidden md:block h-6 w-px bg-gray-300 mx-2" aria-hidden="true"></div>
                    <h1 class="hidden md:inline text-lg font-bold">文字認識
                        <Tooltip Text="範囲選択した部分の文字認識をおこないます。">
                            <InfoIcon Class="w-5 h-5 inline-block ml-1 text-blue-400 cursor-pointer" />
                        </Tooltip>
                    </h1>
                    <div class="ml-4 flex items-center gap-2">
                        <input type="number"
                            id="topbar-page-input"
                            min="1"
                            max="@Math.Max(1, DisplayItems.Count)"
                            value="@displayedPageNumber"
                            @onchange="OnTopBarPageInputChanged"
                            class="w-10 px-2 py-1 rounded border border-gray-300 text-sm"
                            title="ページ番号を入力して移動" />
                        <span class="text-sm">/ @DisplayItems.Count</span>
                    </div>
                    <ToggleButtonGroup T="bool" Items="toggleItems" ActiveValue="isDrawingMode"
                        OnClick="OnToggleDrawingMode" />
                    <ActionButtonGroup T="string" Actions="rotateActions" />
                    <ActionButtonGroup T="string" Actions="zoomActions" />

                    <DropdownButton T="string" MenuId="trimMenu" MenuItems="applyTrimItems">
                        <Trigger>
                            <DropdownTriggerButton>
                                <ActivityZoneIcon/>
                                <span class="hidden xl:inline">範囲設定</span>
                            </DropdownTriggerButton>
                        </Trigger>
                    </DropdownButton>
                    <label class="flex items-center gap-2 bg-white text-gray-800 px-2 py-1 rounded cursor-pointer select-none">
                        <input type="checkbox" @bind="useSnapToGrid" @bind:after="OnSnapToGridChanged" class="form-checkbox h-5 w-5 accent-blue-500" />
                        スナップ
                        <Tooltip Text="既存の矩形の位置に合わせて、新しい矩形を自動的にスナップ（吸着）させます。">
                            <InfoIcon Class="w-5 h-5 inline-block ml-1 text-blue-400 cursor-pointer" />
                        </Tooltip>
                    </label>
                    <div class="flex items-center gap-2 bg-white text-gray-800 px-2 py-1 rounded">
                        <label class="text-sm font-medium">画質 (DPI):</label>
                        <select @bind="exportDpi" class="px-2 py-1 rounded border border-gray-300 text-sm">
                            <option value="150">150 (低画質・高速)</option>
                            <option value="200">200 (推奨)</option>
                            <option value="300">300 (高画質)</option>
                            <option value="400">400 (最高画質・低速)</option>
                        </select>
                        <Tooltip Text="高すぎる設定はノイズ増加で精度が低下する可能性があります。">
                            <InfoIcon Class="w-5 h-5 text-blue-400 cursor-pointer ml-1" />
                        </Tooltip>
                    </div>
                </div>
                <ActionButtonGroup T="string" Actions="primaryActions" />
            </div>
        </div>
        <SplitPane LeftWidth="@thumbnailAreaWidth" LeftWidthChanged="@(async w => { thumbnailAreaWidth = w; })">
            <Left>
                <div id="thumbnail-container" class="grid gap-4 p-4" style="grid-template-columns: repeat(auto-fit, minmax(112px, 1fr));">
                    @for (int i = 0; i < DisplayItems.Count; i++)
                    {
                        var index = i;
                        var item = DisplayItems[i];
                        <TrimThumbnailCard Item="@item"
                                        Index="@index"
                                        IsSelected="@(displayedPageNumber -1 == index)"
                                        HasTrimRect="@(PdfDataService.GetTrimRects(index)?.Any() ?? false)"
                                        OnClick="@(() => SelectPage(index))"
                                        OnReloadPageItem="ReloadPageItem" 
                                        />
                    }
                    <FileAddArea
                        Position="@DisplayItems.Count"
                        OnInsertBlankPage="InsertBlankPage"
                        OnInsertPdfAtPosition="InsertPdfAtPosition"
                        OnAddFileClick="OpenFileDialog" ShowInsertButton="@(false)" />
                </div>
            </Left>
            <Right>
                <div id="loading-indicator" class="absolute inset-0 z-[210] flex items-center justify-center bg-white pointer-events-none" style="display:none;">
                    <svg class="w-12 h-12 text-blue-600 animate-spin" viewBox="0 0 50 50" aria-hidden="true" role="img">
                        <circle cx="25" cy="25" r="20" fill="none" stroke="currentColor" stroke-width="4" class="opacity-20"></circle>
                        <path d="M45 25a20 20 0 0 1-20 20" fill="none" stroke="currentColor" stroke-width="4" stroke-linecap="round"></path>
                    </svg>
                </div>

                <div class="preview-zoom-viewport w-full h-full">
                    <div id="preview-zoom-inner" class="preview-zoom-inner" style="--preview-zoom: 1; transform: scale(var(--preview-zoom)); transform-origin: top center;">
                        @if (DisplayItems.Any(item => item.RawData is PageItem pageItem && pageItem.IsLoading))
                        {
                            <div class="w-full flex justify-center my-2">
                                <div class="bg-yellow-100 border-l-4 border-yellow-500 text-yellow-800 p-3 rounded font-bold text-sm flex items-center gap-2">
                                    <i class="fa-solid fa-triangle-exclamation"></i>
                                    ファイルの読み込み中です。すべてのページの読み込みが完了するまで、タブの切り替えや画面遷移を行わないでください。
                                </div>
                            </div>
                        }
                        @foreach (var (item, index) in DisplayItems.Select((x, i) => (x, i)))
                        {
                            string? keyName = $"{item.Id}-{_rotationCounter}";
                            <TrimPreviewItem @key="keyName"
                                            Item="@item"
                                            Index="@index"
                                            IsDrawingMode="@isDrawingMode" AllowMultipleRects="@(true)"/>
                        }
                    </div>
                </div>
            </Right>
        </SplitPane>
        <div class="fixed bottom-0 left-0 w-full z-50 md:hidden bg-white border-t border-gray-300 p-4">
            <button class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 rounded-lg text-lg"
                @onclick="ShowOcrPreview">
                完了
            </button>
        </div>    
    </div>
}
@if (currentState == OcrWorkflowState.Previewing)
{
    <div class="fixed inset-0 bg-white z-50 flex flex-col">
        <!-- ヘッダー（完了画面と同じデザイン） -->
        <div class="sticky top-0 left-0 w-full bg-gray-800 text-white shadow z-50 h-16">
            <div class="flex items-center justify-between px-4 py-2 h-16">
                <!-- 左側：戻るボタン -->
                <div class="flex items-center gap-2">
                    <ActionButtonGroup T="string" Actions="backToEditActions" />
                </div>
                
                <!-- 中央：タイトル -->
                <div class="flex-1 text-center">
                    <h2 class="text-lg md:text-xl font-bold">OCR プレビュー (@ocrPreviewItems.Count 件)</h2>
                </div>
                
                <!-- 右側：OCR実行ボタン -->
                <div class="flex items-center gap-2">
                    <button class="flex items-center gap-2 bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 md:px-6 rounded transition"
                            @onclick="ExecuteOcrFromPreview">
                        <i class="fa-solid fa-play"></i>
                        <span class="hidden md:inline">OCR実行 (@ocrPreviewItems.Count(p => p.IsSelected) 件)</span>
                        <span class="md:hidden">実行 (@ocrPreviewItems.Count(p => p.IsSelected))</span>
                    </button>
                </div>
            </div>
        </div>
        <!-- プレビュー画面のヘッダー下部に設定パネル -->
        <div class="bg-gray-100 border-b border-gray-300 p-3 flex justify-center items-center gap-4">
            <div class="flex items-center gap-2">
                <label class="text-sm font-medium">認識言語:</label>
                <select @bind="ocrLanguage" class="px-2 py-1 rounded border border-gray-300 text-sm">
                    <option value="jpn">日本語のみ</option>
                    <option value="eng+jpn">日本語 + 英数字（推奨）</option>
                    <option value="eng">英語のみ</option>
                </select>
            </div>
            <div class="flex items-center gap-2">
                <label class="text-sm font-medium">文字方向:</label>
                <select @bind="ocrTextDirection" class="px-2 py-1 rounded border border-gray-300 text-sm">
                    <option value="auto">自動検出</option>
                    <option value="horizontal">横書き</option>
                    <option value="vertical">縦書き</option>
                </select>
            </div>
            <div class="flex items-center gap-2">
                <label class="text-sm font-medium">読み取り順:</label>
                <select @bind="ocrReadingOrder" class="px-2 py-1 rounded border border-gray-300 text-sm">
                    <option value="auto">自動</option>
                    <option value="ltr">左→右</option>
                    <option value="rtl">右→左</option>
                </select>
            </div>
            <!-- DPI表示（変更不可） -->
            <div class="flex items-center gap-2 bg-blue-50 px-3 py-1 rounded border border-blue-200">
                <i class="fa-solid fa-image text-blue-600"></i>
                <span class="text-sm font-medium text-blue-800">画質: @exportDpi DPI</span>
                <Tooltip Text="DPIは編集画面で設定できます。変更するには編集画面に戻ってください。">
                    <InfoIcon Class="w-4 h-4 text-blue-600 cursor-pointer" />
                </Tooltip>
            </div>
        </div>
        <!-- メインコンテンツ -->
        <div class="flex-1 overflow-auto bg-gray-50">
            <div class="p-6 grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 2xl:grid-cols-5 gap-6">
                @foreach (var item in ocrPreviewItems)
                {
                    <div class="border-2 rounded-lg overflow-hidden @(item.IsSelected ? "border-blue-500 shadow-lg" : "border-gray-300") bg-white">
                        <!-- 画像プレビューエリア（固定高さ） -->
                        <ImageViewer ImageSrc="@item.ImageDataUrl"
                            AltText="@item.FileName"
                            Height="300px"
                            ShowControls="true"
                            ShowCheckbox="true"
                            IsSelected="@item.IsSelected"
                            IsSelectedChanged="@(async (bool val) => { item.IsSelected = val; await Task.CompletedTask; })"
                            RotationAngle="@item.RotationAngle" />
                        
                        
                        <!-- コントロールエリア -->
                        <div class="p-4 bg-white border-t border-gray-200">
                            <div class="text-sm font-semibold mb-3 text-gray-800 truncate" title="@item.FileName">
                                @item.FileName
                            </div>
                            
                            <!-- 傾き調整（360度対応） -->
                            <div class="space-y-3">
                                <!-- 数値入力 -->
                                <div class="flex items-center gap-2">
                                    <label class="text-xs text-gray-600 w-12 flex-shrink-0">傾き:</label>
                                    <input type="number" 
                                           min="-180" max="180" step="0.5"
                                           @bind="item.RotationAngle"
                                           @bind:after="StateHasChanged"
                                           class="flex-1 px-2 py-1 border border-gray-300 rounded text-sm text-center font-mono" />
                                    <span class="text-xs text-gray-600 w-8">度</span>
                                </div>
                                
                                <!-- スライダー（-180°～180°） -->
                                <div class="flex items-center gap-2">
                                    <input type="range" 
                                           min="-180" max="180" step="1"
                                           @bind="item.RotationAngle"
                                           @bind:after="StateHasChanged"
                                           class="flex-1" />
                                </div>
                                
                                <!-- クイック回転ボタン -->
                                <div class="flex gap-1 justify-center">
                                    <button class="px-2 py-1 bg-gray-200 hover:bg-gray-300 rounded text-xs transition"
                                            @onclick="() => { item.RotationAngle = (item.RotationAngle + 90) % 360 - 180; StateHasChanged(); }"
                                            title="左90度回転">
                                        <i class="fa-solid fa-rotate-left"></i>
                                    </button>
                                    <button class="px-2 py-1 bg-gray-200 hover:bg-gray-300 rounded text-xs transition"
                                            @onclick="() => { item.RotationAngle = (item.RotationAngle - 90 + 360) % 360 - 180; StateHasChanged(); }"
                                            title="右90度回転">
                                        <i class="fa-solid fa-rotate-right"></i>
                                    </button>
                                    <button class="px-2 py-1 bg-blue-100 hover:bg-blue-200 text-blue-700 rounded text-xs transition"
                                            @onclick="() => { item.RotationAngle = 0; StateHasChanged(); }"
                                            title="リセット">
                                        <i class="fa-solid fa-undo mr-1"></i>0°
                                    </button>
                                    <button class="px-2 py-1 bg-gray-200 hover:bg-gray-300 rounded text-xs transition"
                                            @onclick="() => { item.RotationAngle = 180; StateHasChanged(); }"
                                            title="180度回転">
                                        180°
                                    </button>
                                </div>
                                
                                <!-- 微調整ボタン -->
                                <div class="flex gap-1 justify-center items-center">
                                    <span class="text-xs text-gray-500">微調整:</span>
                                    <button class="px-2 py-1 bg-gray-100 hover:bg-gray-200 rounded text-xs transition"
                                            @onclick="() => { item.RotationAngle += 1; StateHasChanged(); }">
                                        -1°
                                    </button>
                                    <button class="px-2 py-1 bg-gray-100 hover:bg-gray-200 rounded text-xs transition"
                                            @onclick="() => { item.RotationAngle += 0.5; StateHasChanged(); }">
                                        -0.5°
                                    </button>
                                    <button class="px-2 py-1 bg-gray-100 hover:bg-gray-200 rounded text-xs transition"
                                            @onclick="() => { item.RotationAngle -= 0.5; StateHasChanged(); }">
                                        +0.5°
                                    </button>
                                    <button class="px-2 py-1 bg-gray-100 hover:bg-gray-200 rounded text-xs transition"
                                            @onclick="() => { item.RotationAngle -= 1; StateHasChanged(); }">
                                        +1°
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                }
            </div>
        </div>
        
        <!-- フッター（選択状況表示） -->
        <div class="bg-gray-100 border-t border-gray-300 p-3 flex justify-between items-center">
            <div class="text-sm text-gray-600">
                選択中: <span class="font-bold text-blue-600">@ocrPreviewItems.Count(p => p.IsSelected)</span> / @ocrPreviewItems.Count 件
            </div>
            <div class="flex gap-2">
                <button class="text-sm text-blue-600 hover:text-blue-800 transition"
                        @onclick="SelectAllPreviewItems">
                    すべて選択
                </button>
                <span class="text-gray-400">|</span>
                <button class="text-sm text-blue-600 hover:text-blue-800 transition"
                        @onclick="DeselectAllPreviewItems">
                    すべて解除
                </button>
            </div>
        </div>
    </div>
}

@if (!IsFilesLoaded && !CompletionState.ShowResult)
{
    <!-- 初期画面：ファイル選択 -->
    <SelectFilePanel OnOpenFileDialog="OpenFileDialog"/>
}
@if (CompletionState.ShowResult && ocrResults.Any())
{
    <!-- PC: 横並び, タブレット以下: 縦並び -->
    <div class="sticky top-0 left-0 w-full bg-gray-800 text-white shadow z-50 h-16">
        <div class="flex items-center px-4 py-2 h-16">
            <ActionButtonGroup T="string" Actions="backToPreviewActions" />
        </div>
    </div>

    <!-- メインエリア -->
    <div class="overflow-hidden h-[calc(100vh-4rem)]">
        <div class="flex flex-col md:flex-row h-full">
            <!-- OCR結果表示エリア（スクロール可能） -->
            <div class="flex-1 overflow-auto bg-gray-50">
                <!-- コピーオプション設定パネル（スクロールエリア内の上部に固定） -->
                <div class="sticky top-0 z-10 bg-gray-100 border-b border-gray-300 p-3 flex justify-center items-center gap-4 flex-wrap shadow-sm">
                    <span class="text-sm font-medium text-gray-700">コピー時の処理:</span>
                    <label class="flex items-center gap-2 cursor-pointer">
                        <input type="checkbox" @bind="copyRemoveSpaces" class="form-checkbox h-4 w-4 accent-blue-600" />
                        <span class="text-sm">半角スペースを除去</span>
                    </label>
                    <label class="flex items-center gap-2 cursor-pointer">
                        <input type="checkbox" @bind="copyRemoveNewlines" class="form-checkbox h-4 w-4 accent-blue-600" />
                        <span class="text-sm">改行を除去</span>
                    </label>
                    <label class="flex items-center gap-2 cursor-pointer">
                        <input type="checkbox" @bind="copyTrimWhitespace" class="form-checkbox h-4 w-4 accent-blue-600" />
                        <span class="text-sm">前後の空白を除去</span>
                    </label>
                </div>

                <!-- OCR結果カード群 -->
                <div class="p-6 grid grid-cols-1 lg:grid-cols-2 xl:grid-cols-3 gap-6">
                    @foreach (var result in ocrResults)
                    {
                        <div class="bg-white rounded-lg shadow-lg overflow-hidden flex flex-col">
                            <!-- 画像ビューアー（ズーム・パン対応） -->
                            <ImageViewer ImageSrc="@result.ImageDataUrl"
                                AltText="@result.FileName"
                                Height="300px"
                                ShowControls="true"
                                ShowCheckbox="false"
                                RotationAngle="0" />
                            
                            <!-- OCR結果 -->
                            <div class="p-4 flex-1 flex flex-col">
                                <div class="flex items-center justify-between mb-2">
                                    <span class="text-sm font-semibold text-gray-700 truncate flex-1" title="@result.FileName">@result.FileName</span>
                                    <span class="text-xs text-gray-500 ml-2 flex-shrink-0">信頼度: @result.Confidence.ToString("F1")%</span>
                                </div>
                                
                                <!-- 認識テキスト -->
                                <div class="flex-1 min-h-0 flex flex-col gap-2">
                                    <!-- コピーボタンを外に配置 -->
                                    <div class="flex justify-end">
                                        <button
                                            class="bg-blue-600 hover:bg-blue-700 text-white px-3 py-1 rounded text-xs flex items-center gap-1 shadow-md transition"
                                            @onclick="() => CopyToClipboard(result.Text)">
                                            <i class="fa-solid fa-copy"></i>
                                            コピー
                                        </button>
                                    </div>
                                    
                                    <!-- テキストエリア -->
                                    <textarea 
                                        class="w-full flex-1 p-3 border border-gray-300 rounded resize-none font-mono text-sm"
                                        readonly>@GetDisplayText(result.Text)</textarea>
                                </div>

                                <!-- 行ごとの結果（詳細） -->
                                @if (result.Lines != null && result.Lines.Any())
                                {
                                    <details class="mt-3">
                                        <summary class="cursor-pointer text-sm text-blue-600 hover:text-blue-800 select-none">
                                            <i class="fa-solid fa-chevron-down mr-1"></i>
                                            行ごとの詳細を表示 (@result.Lines.Count 行)
                                        </summary>
                                        <div class="mt-2 space-y-2 max-h-48 overflow-auto border border-gray-200 rounded p-2 bg-gray-50">
                                            @foreach (var (line, index) in result.Lines.Select((l, i) => (l, i)))
                                            {
                                                <div class="flex items-start gap-2 p-2 bg-white rounded text-xs shadow-sm">
                                                    <span class="font-mono text-gray-500 flex-shrink-0 w-8 text-right">@(index + 1)</span>
                                                    <span class="flex-1 break-all text-gray-800">@GetDisplayText(line.Text)</span>
                                                    <button
                                                        class="flex-shrink-0 text-blue-600 hover:text-blue-800 transition"
                                                        @onclick="() => CopyToClipboard(line.Text)"
                                                        title="コピー">
                                                        <i class="fa-solid fa-copy"></i>
                                                    </button>
                                                </div>
                                            }
                                        </div>
                                    </details>
                                }
                            </div>
                        </div>
                    }
                </div>
            </div>
            
            <!-- 情報パネル（PCのみ表示） -->
            <div class="hidden md:flex flex-col w-full max-w-xs bg-white border-l border-gray-200 shadow-lg h-full p-6 justify-center items-center">
                <InfoPanel Title="完了" FileName="@mergedFileName" FileSize="@mergedFileSize" PageCount="@mergedPageCount">
                    <button
                        class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-6 rounded-lg w-full flex items-center justify-center transition"
                        @onclick="DownloadAllOcrResultsAsText">
                        <i class="fa-solid fa-download mr-2"></i>
                        すべてテキストでダウンロード
                    </button>
                    <button
                        class="bg-white hover:bg-gray-100 border-1 border-solid border-gray-300 font-bold py-2 px-6 rounded-lg w-full flex items-center justify-center mt-4 transition"
                        @onclick="StartNew">
                        <ResetIcon class="inline-block align-middle w-[1em] h-[1em]" />
                        新規作成
                    </button>
                </InfoPanel>
            </div>
        </div>
        
        <!-- 以下省略 -->
    </div>
}
<!-- ローディング中 -->
<LoadingOverlay />

<!-- メッセージ表示エリア -->
<MessageBar />

<PasswordInputDialog IsOpen="@isPasswordDialogOpen" FileName="@passwordDialogFileName" OnClose="OnPasswordDialogClose" />

<!-- ファイル選択用の隠しinput -->
<InputFile OnChange="HandleFileSelectionAsync" multiple class="hidden" id="fileInput" />

@if(isTrimRangeDialogOpen){
    <TrimRangeDialog 
        OnClose="CloseTrimRangeDialog"
        OnApply="ApplyTrimRangeSettings"
        PreviewImageSrc="@currentPreviewImage"
        CurrentPageNumber="@displayedPageNumber"
        TotalPages="@DisplayItems.Count"
        InitialTrimRectNormalized="@InitialTrimRectNormalized"
        OnError="OnDialogError" />
}

@code {
    // ========================================
    // 状態管理
    // ========================================
    
    private enum OcrWorkflowState
    {
        Editing,      // 範囲選択中
        Previewing,   // 切り取り画像プレビュー（傾き調整可能）
        Completed     // OCR完了
    }

    private OcrWorkflowState currentState = OcrWorkflowState.Editing;
    
    // ========================================
    // 初期化・ライフサイクル
    // ========================================
    
    protected override void OnInitialized()
    {
        PdfDataService.OnChange += OnServiceChanged;
        PdfDataService.PasswordInputDialogFunc = ShowPasswordInputDialogAsync;
        PdfDataService.SwitchDisplayMode(DisplayMode.Page);
        CompletionState.Reset();
    }

    private void OnServiceChanged()
    {
        InvokeAsync(StateHasChanged);
    }

    public async ValueTask DisposeAsync()
    {
        // 1) サービスのイベント購読解除
        try { PdfDataService.OnChange -= OnServiceChanged; } catch { }
        try { CompletionState.Reset(); } catch { }

        // 2) JS 側の登録解除を確実に await（逆順推奨）

        // 2-1) trim-preview.js の一括解除
        try { await JSRuntime.InvokeVoidAsync("unregisterAllTrimPreview"); } catch { }

        // 2-2) 個別の unregister（念のため重複呼び出し）
        try { await JSRuntime.InvokeVoidAsync("unregisterPreviewCacheCleanup", "trim-preview-container"); } catch { }
        _previewCacheCleanupRegistered = false;

        try { await JSRuntime.InvokeVoidAsync("unregisterVisiblePageObserver", "trim-preview-container"); } catch { }
        _visibleObserverLastCount = -1;

        try { await JSRuntime.InvokeVoidAsync("unobserveTrimPreviewVisibility", "trim-preview-container"); } catch { }

        try
        {
            if (_dropAreaRegistered)
            {
                await JSRuntime.InvokeVoidAsync("unregisterDropArea", "drop-area");
            }
        }
        catch { }
        _dropAreaRegistered = false;

        try { await JSRuntime.InvokeVoidAsync("unregisterSelectDropArea"); } catch { }

        try { await JSRuntime.InvokeVoidAsync("trimPreviewArea.unregister"); } catch { }

        try
        {
            if (_windowResizeRegistered)
            {
                await JSRuntime.InvokeVoidAsync("unregisterWindowResize");
            }
        }
        catch { }
        _windowResizeRegistered = false;

        // 2-3) OCR エンジンのクリーンアップ
        try { await JSRuntime.InvokeVoidAsync("ocrHelper.terminate"); } catch (Exception ex) { Console.WriteLine($"OCR cleanup error: {ex.Message}"); }

        // 3) 非同期タスクのキャンセル
        try { passwordTcs?.TrySetCanceled(); } catch { }
        passwordTcs = null;

        // 4) JS が参照をクリアする時間を少し与える（オプション：安全策）
        try { await Task.Delay(30); } catch { }

        // 5) 最後に DotNetObjectReference を破棄
        try { _dotNetRef?.Dispose(); } catch { }
        _dotNetRef = null;
    }

    // ========================================
    // プロパティ・フィールド
    // ========================================
    
    private DisplayMode CurrentDisplayMode => PdfDataService.GetModel().CurrentMode;
    private List<DisplayItem> DisplayItems => PdfDataService.GetDisplayItems();
    private bool IsFilesLoaded => DisplayItems.Any();

    private DotNetObjectReference<Ocr>? _dotNetRef;
    private string mergedFileName = "";
    private string mergedFileSize = "";
    private int mergedPageCount = 0;
    private bool isDrawingMode = true;
    private int thumbnailAreaWidth = 300;
    private bool isResizingPanel = false;
    private double resizeStartX = 0;
    private int resizeStartWidth = 0;
    private int _rotationCounter = 0;
    private int insertPosition = -1;
    private bool isPasswordDialogOpen = false;
    private string passwordDialogFileName = "";
    private TaskCompletionSource<string?>? passwordTcs;
    private bool _dropAreaRegistered = false;
    private bool previewZoomInitialized = false;
    private int displayedPageNumber = 1;
    private int _visibleObserverLastCount = -1;
    private bool _windowResizeRegistered = false;
    private double previewZoom = 1.0;
    private const double ZoomStep = 0.25;
    private const double MinZoom = 0.25;
    private const double MaxZoom = 3.0;
    private bool isTrimRangeDialogOpen = false;
    private string currentPreviewImage = "";
    private TrimRectInfo? InitialTrimRectNormalized;
    private bool useSnapToGrid = false;
    private bool _previewCacheCleanupRegistered = false;

    // ========================================
    // OCR関連
    // ========================================
    private string ocrLanguage = "eng+jpn"; // jpn, eng+jpn, eng
    private string ocrTextDirection = "auto"; // auto, horizontal, vertical
    private string ocrReadingOrder = "auto";// auto, ltr, rtl
    private int exportDpi = 200;
    // コピーオプション
    private bool copyRemoveSpaces = false;
    private bool copyRemoveNewlines = false;
    private bool copyTrimWhitespace = false;
    public class OcrOptions
    {
        public int PsmMode { get; set; }
        public bool AutoRotate { get; set; }
        public string ReadingOrder { get; set; } = "auto";
    }

    private class OcrPreviewItem
    {
        public string Id { get; set; } = "";
        public string ImageDataUrl { get; set; } = "";
        public string FileName { get; set; } = "";
        public int PageIndex { get; set; }
        public int RectIndex { get; set; }
        public double RotationAngle { get; set; } = 0;
        public bool IsSelected { get; set; } = true;
    }

    private class OcrResult
    {
        public string Id { get; set; } = "";
        public string ImageDataUrl { get; set; } = "";
        public string FileName { get; set; } = "";
        public string Text { get; set; } = "";
        public double Confidence { get; set; }
        public List<OcrLine> Lines { get; set; } = new();
        public int OriginalPageIndex { get; set; }
        public int RectIndex { get; set; }
    }

    private class OcrLine
    {
        public string Text { get; set; } = "";
        public double Confidence { get; set; }
    }

    private class OcrResultJson
    {
        public string text { get; set; } = "";
        public double confidence { get; set; }
        public List<OcrLineJson>? lines { get; set; }
    }

    private class OcrLineJson
    {
        public string text { get; set; } = "";
        public double confidence { get; set; }
    }

    private List<OcrPreviewItem> ocrPreviewItems = new();
    private List<OcrResult> ocrResults = new();

    // 「完了」ボタン → プレビュー画面へ
    private async Task ShowOcrPreview()
    {
        try
        {
            await MessageService.ShowLoadingAsync("画像を準備中...");
            await Task.Yield();
            
            ocrPreviewItems.Clear();
            int imageCounter = 1;
            
            for (int pageIndex = 0; pageIndex < DisplayItems.Count; pageIndex++)
            {
                var item = DisplayItems[pageIndex];
                if (item.RawData is not PageItem page) continue;
                
                var rects = PdfDataService.GetTrimRects(pageIndex);
                if (rects == null || rects.Count == 0) continue;
                
                for (int rectIndex = 0; rectIndex < rects.Count; rectIndex++)
                {
                    var rect = rects[rectIndex];
                    var rotate = normalizeRotationAngle(page.RotateAngle);
                    
                    var imageDataUrl = await JSRuntime.InvokeAsync<string>(
                        "cropPdfPageToImage",
                        page.PageData,
                        rect.X, rect.Y, rect.Width, rect.Height,
                        rotate,
                        exportDpi
                    );
                    
                    if (!string.IsNullOrEmpty(imageDataUrl))
                    {
                        ocrPreviewItems.Add(new OcrPreviewItem
                        {
                            Id = $"preview-{pageIndex}-{rectIndex}",
                            ImageDataUrl = imageDataUrl,
                            FileName = $"ocr_{imageCounter:D3}.txt",
                            PageIndex = pageIndex,
                            RectIndex = rectIndex,
                            RotationAngle = 0,
                            IsSelected = true
                        });
                        imageCounter++;
                    }
                }
            }
            
            if (ocrPreviewItems.Count == 0)
            {
                _ = MessageService.ShowAsync("文字認識させる範囲が設定されていません", MessageType.Warn);
                return;
            }
            
            currentState = OcrWorkflowState.Previewing;
        }
        catch (Exception ex)
        {
            _ = MessageService.ShowAsync($"プレビュー作成に失敗しました: {ex.Message}", MessageType.Error);
        }
        finally
        {
            await MessageService.HideLoadingAsync();
            StateHasChanged();
        }
    }

    // プレビュー画面から「OCR実行」
    private async Task ExecuteOcrFromPreview()
    {
        try
        {
            var selectedItems = ocrPreviewItems.Where(p => p.IsSelected).ToList();
            
            // 選択数チェック
            if (selectedItems.Count == 0)
            {
                _ = MessageService.ShowAsync("OCRを実行する画像を選択してください", MessageType.Warn);
                return;
            }
            
            // 選択された言語でOCRエンジンを初期化
            var initialized = await JSRuntime.InvokeAsync<bool>("ocrHelper.initialize", ocrLanguage);
            if (!initialized)
            {
                _ = MessageService.ShowAsync("OCR エンジンの初期化に失敗しました", MessageType.Error);
                return;
            }
            
            ocrResults.Clear();
            int processedCount = 0;
            
            foreach (var preview in selectedItems)
            {
                processedCount++;
                await MessageService.ShowLoadingAsync($"OCR処理中... ({processedCount}/{selectedItems.Count})");
                await Task.Yield();
                
                try
                {
                    string processedImage = preview.ImageDataUrl;
                    if (Math.Abs(preview.RotationAngle) > 0.1)
                    {
                        processedImage = await JSRuntime.InvokeAsync<string>(
                            "ocrHelper.rotateImage",
                            preview.ImageDataUrl,
                            preview.RotationAngle
                        );
                    }
                    
                    // PSMモードの決定（文字方向）
                    int psmMode = ocrTextDirection switch
                    {
                        "horizontal" => 6,  // 単一の均一なテキストブロック（横書き）
                        "vertical" => 5,    // 単一の垂直な均一なテキストブロック（縦書き）
                        _ => 3              // 自動ページセグメンテーション
                    };

                    // OCRオプションを作成
                    var ocrOptions = new OcrOptions
                    {
                        PsmMode = psmMode,
                        AutoRotate = false,
                        ReadingOrder = ocrReadingOrder
                    };
                    
                    var ocrData = await JSRuntime.InvokeAsync<OcrResultJson>(
                        "ocrHelper.recognize",
                        processedImage,
                        ocrOptions
                    );
                    
                    if (ocrData != null)
                    {
                        ocrResults.Add(new OcrResult
                        {
                            Id = preview.Id,
                            ImageDataUrl = processedImage,
                            FileName = preview.FileName,
                            Text = ocrData.text ?? "",
                            Confidence = ocrData.confidence,
                            Lines = ocrData.lines?.Select(l => new OcrLine
                            {
                                Text = l.text ?? "",
                                Confidence = l.confidence
                            }).ToList() ?? new(),
                            OriginalPageIndex = preview.PageIndex,
                            RectIndex = preview.RectIndex
                        });
                    }
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"OCR error for {preview.FileName}: {ex.Message}");
                    // 個別のエラーはログのみ、処理は継続
                }
            }
            
            if (ocrResults.Count == 0)
            {
                _ = MessageService.ShowAsync("OCR処理に失敗しました。すべての画像で認識エラーが発生しました", MessageType.Error);
                return;
            }
            
            mergedFileName = $"ocr_results_{DateTime.Now:yyyyMMddHHmm}.txt";
            mergedFileSize = FormatFileSize(ocrResults.Sum(r => System.Text.Encoding.UTF8.GetByteCount(r.Text)));
            mergedPageCount = ocrResults.Count;
            
            currentState = OcrWorkflowState.Completed;
            CompletionState.SetShowResult(true);
            
            // 一部失敗した場合の通知
            if (ocrResults.Count < selectedItems.Count)
            {
                _ = MessageService.ShowAsync(
                    $"{ocrResults.Count}/{selectedItems.Count} 件の文字認識が完了しました（一部失敗）", 
                    MessageType.Warn
                );
            }
            else
            {
                _ = MessageService.ShowAsync($"{ocrResults.Count} 件の文字認識が完了しました", MessageType.Success);
            }
        }
        catch (Exception ex)
        {
            _ = MessageService.ShowAsync($"OCR処理中にエラーが発生しました: {ex.Message}", MessageType.Error);
        }
        finally
        {
            await MessageService.HideLoadingAsync();
            StateHasChanged();
        }
    }

    private async Task ReloadPageItem(DisplayItem item)
    {
        // ページ単位の場合のみ対応
        if (item.RawData is PageItem pageItem)
        {
            pageItem.IsLoading = true;
            
            var errorMsg = await PdfDataService.ReloadPageAsync(pageItem.FileId, pageItem.OriginalPageIndex);

            if (!string.IsNullOrEmpty(errorMsg))
            {
                _ = MessageService.ShowAsync(errorMsg, MessageType.Error);
            }
        }
    }

    /// <summary>
    /// 表示用のテキストを取得（コピーオプションに応じて処理）
    /// </summary>
    private string GetDisplayText(string text)
    {
        if (string.IsNullOrEmpty(text))
            return text;

        // いずれかのオプションが有効な場合のみ処理
        if (!copyRemoveSpaces && !copyRemoveNewlines && !copyTrimWhitespace)
            return text;

        return ProcessTextForCopy(text);
    }

    private async Task CopyToClipboard(string text)
    {
        try
        {
            string processedText = ProcessTextForCopy(text);
            
            var success = await JSRuntime.InvokeAsync<bool>("copyToClipboard", processedText);
            if (success)
            {
                _ = MessageService.ShowAsync("クリップボードにコピーしました", MessageType.Success);
            }
            else
            {
                _ = MessageService.ShowAsync("コピーに失敗しました", MessageType.Error);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Clipboard copy error: {ex.Message}");
            _ = MessageService.ShowAsync("コピーに失敗しました", MessageType.Error);
        }
    }

    private string ProcessTextForCopy(string text)
    {
        if (string.IsNullOrEmpty(text))
            return text;

        string result = text;

        // 半角スペースを除去
        if (copyRemoveSpaces)
        {
            result = result.Replace(" ", "");
        }

        // 改行を除去
        if (copyRemoveNewlines)
        {
            result = result.Replace("\r\n", "").Replace("\n", "").Replace("\r", "");
        }

        // 前後の空白を除去
        if (copyTrimWhitespace)
        {
            result = result.Trim();
        }

        return result;
    }

    private async Task DownloadAllOcrResultsAsText()
    {
        try
        {
            // ダウンロード時も処理後のテキストを使用
            var allText = string.Join("\n\n" + new string('=', 50) + "\n\n",
                ocrResults.Select(r => 
                {
                    string displayText = GetDisplayText(r.Text);
                    return $"[{r.FileName}]\n信頼度: {r.Confidence:F1}%\n\n{displayText}";
                }));

            var bytes = System.Text.Encoding.UTF8.GetBytes(allText);
            var base64 = Convert.ToBase64String(bytes);
            var dataUrl = $"data:text/plain;charset=utf-8;base64,{base64}";

            await JSRuntime.InvokeVoidAsync("downloadFileFromUrl", dataUrl, mergedFileName, "text/plain");

            _ = MessageService.ShowAsync("テキストファイルをダウンロードしました", MessageType.Success);
        }
        catch (Exception ex)
        {
            _ = MessageService.ShowAsync($"ダウンロードに失敗しました: {ex.Message}", MessageType.Error);
        }
    }

    private int normalizeRotationAngle(int angle)
    {
        var normalized = ((angle % 360) + 360) % 360;
        return (int)Math.Round(normalized / 90.0) * 90 % 360;
    }

    private string FormatFileSize(long bytes)
    {
        string[] sizes = { "B", "KB", "MB", "GB" };
        double len = bytes;
        int order = 0;
        while (len >= 1024 && order < sizes.Length - 1)
        {
            order++;
            len /= 1024;
        }
        return $"{len:0.##} {sizes[order]}";
    }

    // ========================================
    // UI アクション
    // ========================================

    private List<ActionButtonItem> primaryActions => new()
    {
        new ActionButtonItem
        {
            Label = "完了",
            IconHtml = "<i class='fa-solid fa-arrow-right text-xl'></i>",
            Title = "完了",
            OnClick = EventCallback.Factory.Create(this, ShowOcrPreview),
            ButtonClass = "bg-blue-600 hover:bg-blue-700 px-8 transition hidden md:flex h-10",
            IconPosition = "right",
            TextColor = "text-white"
        }
    };

    private List<ActionButtonItem> resetActions => new()
    {
        new ActionButtonItem
        {
            Icon = builder =>
            {
                builder.OpenComponent(0, typeof(ResetIcon));
                builder.AddAttribute(1, "Class", "w-5 h-5");
                builder.CloseComponent();
            },
            Title = "最初からやり直す",
            OnClick = EventCallback.Factory.Create(this, StartNew),
            ButtonClass = "bg-amber-200 hover:bg-amber-300 border border-amber-400 font-bold py-2 px-3 rounded",
            TextColor = "text-black"
        }
    };

    private List<ActionButtonItem> backToEditActions => new()
    {
        new ActionButtonItem
        {
            Label = "編集に戻る",
            IconHtml = "<i class='fa-solid fa-arrow-left'></i>",
            Title = "編集に戻る",
            OnClick = EventCallback.Factory.Create(this, BackToEdit),
        }
    };

    // 完了画面の「戻る」ボタン（プレビューに戻る）
    private List<ActionButtonItem> backToPreviewActions => new()
    {
        new ActionButtonItem
        {
            Label = "プレビューに戻る",
            IconHtml = "<i class='fa-solid fa-arrow-left'></i>",
            Title = "プレビューに戻る",
            OnClick = EventCallback.Factory.Create(this, BackToPreview),
        }
    };

    private List<ActionButtonItem> rotateActions => new()
    {
        new ActionButtonItem
        {
            Label = "左",
            Icon = builder =>
            {
                builder.OpenComponent(0, typeof(RotateLeftIcon));
                builder.AddAttribute(1, "Class", "w-6 h-6"); 
                builder.CloseComponent();
            },
            Title = "左回転",
            OnClick = EventCallback.Factory.Create(this, RotateAllLeft),
            IconPosition = "left"
        },
        new ActionButtonItem
        {
            Label = "右",
            Icon = builder =>
            {
                builder.OpenComponent(0, typeof(RotateRightIcon));
                builder.AddAttribute(1, "Class", "w-6 h-6"); 
                builder.CloseComponent();
            },
            Title = "右回転",
            OnClick = EventCallback.Factory.Create(this, RotateAllRight),
            IconPosition = "left"
        }
    };

    private List<ActionButtonItem> zoomActions => new()
    {
        new ActionButtonItem
        {
            Label = "幅に合わせる",
            Icon = builder =>
            {
                builder.OpenComponent(0, typeof(FitWidthIcon));
                builder.AddAttribute(1, "Class", "w-6 h-6"); 
                builder.CloseComponent();
            },
            Title = "幅に合わせる",
            OnClick = EventCallback.Factory.Create(this, FitPreviewWidth),
        },
        new ActionButtonItem
        {
            Label = "実際のサイズ",
            Icon = builder =>
            {
                builder.OpenComponent(0, typeof(ViewRealSizeIcon));
                builder.AddAttribute(1, "Class", "w-6 h-6"); 
                builder.CloseComponent();
            },
            Title = "実際のサイズ",
            OnClick = EventCallback.Factory.Create(this, SetPreviewToActualSize),
        },
        new ActionButtonItem
        {
            Icon = builder =>
            {
                builder.OpenComponent(0, typeof(ZoomOutIcon));
                builder.AddAttribute(1, "Class", "w-6 h-6"); 
                builder.CloseComponent();
            },
            Title = "縮小",
            OnClick = EventCallback.Factory.Create(this, ZoomOut),
            IconPosition = "left"
        },
        new ActionButtonItem
        {
            Icon = builder =>
            {
                builder.OpenComponent(0, typeof(ZoomInIcon));
                builder.AddAttribute(1, "Class", "w-6 h-6"); 
                builder.CloseComponent();
            },
            Title = "拡大",
            OnClick = EventCallback.Factory.Create(this, ZoomIn),
            IconPosition = "left"
        }
    };

    private List<DropdownMenuItem> applyTrimItems => new()
    {
        new DropdownMenuItem
        {
            Label = "現在ページの範囲を全ページに適用",
            OnClick = EventCallback.Factory.Create(this,ApplyCurrentTrimToAll)
        },
        new DropdownMenuItem
        {
            Label = "すべての範囲をクリア",
            OnClick = EventCallback.Factory.Create(this, ClearAllTrims)
        }
    };

    private List<ToggleButtonItem<bool>> toggleItems = new()
    {
        new ToggleButtonItem<bool>
        {
            Value = true,
            Label = "範囲選択",
            IconFragment = builder =>
            {
                builder.OpenComponent(0, typeof(CropFreeIcon));
                builder.AddAttribute(1, "Class", "w-5 h-5");
                builder.CloseComponent();
            }
        },
        new ToggleButtonItem<bool>
        {
            Value = false,
            Label = "パン",
            IconFragment = builder =>
            {
                builder.OpenComponent(0, typeof(PanIcon));
                builder.AddAttribute(1, "Class", "w-5 h-5");
                builder.CloseComponent();
            }
        }
    };

    // ========================================
    // その他のメソッド
    // ========================================

    private async Task OnDialogError(string message)
    {
        Console.WriteLine($"OnDialogError called: {message}");
        isTrimRangeDialogOpen = false;
        _ = MessageService.ShowAsync(message, MessageType.Error);
        StateHasChanged();
        await Task.CompletedTask;
    }

    [JSInvokable("SetVisiblePageFromJs")]
    public Task SetVisiblePageFromJs(int pageIndex)
    {
        try
        {
            if (pageIndex < 0) pageIndex = 0;
            if (pageIndex >= DisplayItems.Count) pageIndex = Math.Max(0, DisplayItems.Count - 1);
            displayedPageNumber = pageIndex + 1;
        }
        catch { }
        return Task.CompletedTask;
    }

    private async Task OnTopBarPageInputChanged(ChangeEventArgs e)
    {
        if (int.TryParse(e?.Value?.ToString(), out var v))
        {
            var target = Math.Max(1, Math.Min(Math.Max(1, DisplayItems.Count), v));
            displayedPageNumber = target;
            var targetIndex = target - 1;
            try
            {
                await JSRuntime.InvokeVoidAsync("trimPreviewArea.scrollToPage", targetIndex);
            }
            catch { }
        }
    }

    private async Task OnToggleDrawingMode(bool drawingMode)
    {
        isDrawingMode = drawingMode;
        try
        {
            await JSRuntime.InvokeVoidAsync("setPreviewPanEnabled", !drawingMode);
        }
        catch { }
    }

    private async Task OpenFileDialog()
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("openFileDialog", "fileInput");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error opening file dialog: {ex.Message}");
            _ = MessageService.ShowAsync($"ファイル選択ダイアログの表示に失敗しました: {ex.Message}", MessageType.Error);
        }
    }

    private void BackToPreview()
    {
        CompletionState.Reset();
        currentState = OcrWorkflowState.Previewing;
        StateHasChanged();
    }
    // BackToEdit は編集画面に戻る用に残す
    private void BackToEdit()
    {
        currentState = OcrWorkflowState.Editing;
        StateHasChanged();
    }
    private void StartNew()
    {
        CompletionState.Reset();
        PdfDataService.Clear();
        ocrResults.Clear();
        ocrPreviewItems.Clear();
        mergedFileName = "";
        mergedFileSize = "";
        mergedPageCount = 0;
        currentState = OcrWorkflowState.Editing;
        StateHasChanged();
    }

    private async Task RotateAllLeft() => await RotateAll(-90);
    private async Task RotateAllRight() => await RotateAll(90);

    private async Task RotateAll(int angle)
    {
        try{
            await MessageService.ShowLoadingAsync("回転中...");
            await Task.Yield();

            PdfDataService.RotateAll(CurrentDisplayMode, DisplayItems, angle);
            _rotationCounter++;
            _ = MessageService.ShowAsync($"回転が完了しました", MessageType.Success);
        }catch(Exception ex){
            _ = MessageService.ShowAsync($"回転中にエラーが発生しました: {ex.Message}", MessageType.Error);
        }finally{
            await MessageService.HideLoadingAsync();
        }
    }

    public async Task InsertBlankPage(int position)
    {
        await PdfDataService.InsertBlankPageWithDisplayModeAsync(
            CurrentDisplayMode, DisplayItems, position);
    }

    public async Task InsertPdfAtPosition(int position)
    {
        await PdfDataService.OpenInsertPdfDialogAsync(
            CurrentDisplayMode,
            DisplayItems,
            position,
            pos => insertPosition = pos
        );
    }

    private async Task HandleFileSelectionAsync(InputFileChangeEventArgs e)
    {
        try
        {
            await MessageService.ShowLoadingAsync("ファイル読み込み中...");
            await PdfDataService.HandleFileInputAsync(
                e,
                insertPosition >= 0 ? insertPosition : null
            );
            insertPosition = -1;

        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error handling file selection: {ex.Message}");
            _ = MessageService.ShowAsync($"ファイルの読み込みに失敗しました: {ex.Message}", MessageType.Error);
        }finally
        {
            await MessageService.HideLoadingAsync();
        }
    }

    private Task SelectPage(int index)
    {
        _ = JSRuntime.InvokeVoidAsync("trimPreviewArea.scrollToPage", index);
        displayedPageNumber = index + 1;
        StateHasChanged();
        return Task.CompletedTask;
    }

    [JSInvokable]
    public void OnPanelMouseMove(double clientX)
    {
        if (isResizingPanel)
        {
            var delta = clientX - resizeStartX;
            thumbnailAreaWidth = Math.Max(200, Math.Min(600, resizeStartWidth + (int)delta));
            StateHasChanged();
        }
    }

    [JSInvokable]
    public void OnPanelMouseUp()
    {
        isResizingPanel = false;
    }

    private int BrowserViewportWidth()
    {
        return 1200;
    }

    private async Task ApplyPreviewZoomAsync()
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("setPreviewZoom", previewZoom);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"setPreviewZoom failed: {ex.Message}");
        }
    }

    private Task ZoomIn()
    {
        previewZoom = Math.Min(MaxZoom, previewZoom + ZoomStep);
        _ = ApplyPreviewZoomAsync();
        return Task.CompletedTask;
    }

    private Task ZoomOut()
    {
        previewZoom = Math.Max(MinZoom, previewZoom - ZoomStep);
        _ = ApplyPreviewZoomAsync();
        return Task.CompletedTask;
    }

    private Task FitPreviewWidth()
    {
        try
        {
            _ = JSRuntime.InvokeVoidAsync("computeAndApplyFitZoom");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"FitPreviewWidth failed: {ex.Message}");
            previewZoom = 1.0;
            _ = ApplyPreviewZoomAsync();
        }
        return Task.CompletedTask;
    }

    private Task SetPreviewToActualSize()
    {
        previewZoom = 1.0;
        _ = ApplyPreviewZoomAsync();
        return Task.CompletedTask;
    }

    private Task ApplyCurrentTrimToAll()
    {
        if (DisplayItems == null || DisplayItems.Count == 0)
        {
            _ = MessageService.ShowAsync("適用対象がありません。", MessageType.Warn);
            return Task.CompletedTask;
        }

        var idx = Math.Max(0, Math.Min(DisplayItems.Count - 1, displayedPageNumber - 1));
        var trimRects = PdfDataService.GetTrimRects(idx);
        if (trimRects == null || trimRects.Count == 0)
        {
            _ = MessageService.ShowAsync("現在ページに範囲が設定されていません。", MessageType.Warn);
            return Task.CompletedTask;
        }

        try
        {
            for (int i = 0; i < DisplayItems.Count; i++)
            {
                PdfDataService.SetTrimRects(i, new List<TrimRectInfo>(trimRects), notify: false);
            }
            _ = PdfDataService.RedrawAllTrimOverlaysAsync();
            _ = MessageService.ShowAsync("すべてのページに適用しました", MessageType.Success);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"ApplyCurrentTrimToAll error: {ex.Message}");
            _ = MessageService.ShowAsync("すべてのページへの適用に失敗しました", MessageType.Error);
        }
        return Task.CompletedTask;
    }

    private Task ClearAllTrims()
    {
        try
        {
            var count = DisplayItems?.Count ?? 0;
            for (int i = 0; i < count; i++)
            {
                try { PdfDataService.ClearTrimRect(i); } catch { }
            }

            for (int i = 0; i < count; i++)
            {
                try
                {
                    _ = JSRuntime.InvokeVoidAsync("drawTrimOverlayAsSvg", $"trim-preview-canvas-{i}", Array.Empty<object>());
                }
                catch { }
            }

            _ = MessageService.ShowAsync("範囲をクリアしました", MessageType.Success);
        }
        catch
        {
            _ = MessageService.ShowAsync("範囲のクリアに失敗しました", MessageType.Error);
        }
        return Task.CompletedTask;
    }

    [JSInvokable]
    public async Task OnJsFileDropped(string fileName, string contentType, string base64Data)
    {
        try
        {
            await MessageService.ShowLoadingAsync("ファイル読み込み中...");
            await Task.Yield();

            await PdfDataService.HandleDroppedFileAsync(
                fileName,
                base64Data,
                async (name, data) => await PdfDataService.AddOrInsertPdfFileAsync(name, data, null),
                async (name, data) => await PdfDataService.AddOrInsertImageFileAsync(name, data, null)
            );
        }
        finally
        {
            await MessageService.HideLoadingAsync();
        }
    }

    public Task<string?> ShowPasswordInputDialogAsync(string fileName)
    {
        isPasswordDialogOpen = true;
        passwordDialogFileName = fileName;
        passwordTcs = new TaskCompletionSource<string?>();
        StateHasChanged();
        return passwordTcs.Task;
    }

    private void OnPasswordDialogClose(string? password)
    {
        isPasswordDialogOpen = false;
        passwordTcs?.SetResult(password);
        passwordTcs = null;
        StateHasChanged();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _dotNetRef = DotNetObjectReference.Create(this);
            try
            {
                await JSRuntime.InvokeVoidAsync("registerWindowResize", _dotNetRef);
                _windowResizeRegistered = true;
            }
            catch (Exception ex)
            {
                Console.WriteLine($"registerWindowResize failed: {ex.Message}");
            }
        }

        if (IsFilesLoaded && DisplayItems.Any())
        {
            // プレビューキャッシュの自動クリーンアップを登録（初回のみ）
            if (!_previewCacheCleanupRegistered)
            {
                try
                {
                    await JSRuntime.InvokeVoidAsync("registerPreviewCacheCleanup", "trim-preview-container", _dotNetRef);
                    _previewCacheCleanupRegistered = true;
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"[Trim] registerPreviewCacheCleanup failed: {ex.Message}");
                }
            }

            if (!previewZoomInitialized)
            {
                await ApplyPreviewZoomAsync();
                previewZoomInitialized = true;
            }
            if (DisplayItems.Count != _visibleObserverLastCount)
            {
                try
                {   
                    await JSRuntime.InvokeVoidAsync("registerVisiblePageObserver", _dotNetRef, "trim-preview-container");
                    _visibleObserverLastCount = DisplayItems.Count;
                }
                catch { _visibleObserverLastCount = -1; }
            }
            // サムネイル描画
            await JSRuntime.InvokeVoidAsync("drawVisibleCanvases", "thumbnail-container");

        }
        else
        {
            if (_visibleObserverLastCount != -1)
            {
                try { await JSRuntime.InvokeVoidAsync("unregisterVisiblePageObserver", "trim-preview-container"); } catch { }
                _visibleObserverLastCount = -1;
            }
        }

        if (!IsFilesLoaded && !CompletionState.ShowResult)
        {
            await JSRuntime.InvokeVoidAsync("registerSelectDropArea", _dotNetRef);
        }

        if (!_dropAreaRegistered && IsFilesLoaded && DisplayItems.Any())
        {
            await JSRuntime.InvokeVoidAsync("registerDropArea", "drop-area", _dotNetRef);
            _dropAreaRegistered = true;
        }
        else if (_dropAreaRegistered && (!IsFilesLoaded || !DisplayItems.Any()))
        {
            _dropAreaRegistered = false;
        }
    }

    [JSInvokable("OnWindowResizedFromJs")]
    public Task OnWindowResizedFromJs(int availableWidth, int sidebarWidth)
    {
        try
        {
            if (isResizingPanel) return Task.CompletedTask;

            var computed = (int)Math.Round(availableWidth * 0.25);
            var clamped = Math.Max(200, Math.Min( Math.Min(600, computed), (int)(BrowserViewportWidth() - 260) ));

            thumbnailAreaWidth = clamped;
            StateHasChanged();

            _ = JSRuntime.InvokeVoidAsync("applyThumbnailWidth", clamped);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"OnWindowResizedFromJs error: {ex.Message}");
        }
        return Task.CompletedTask;
    }

    private async Task OpenTrimRangeDialog()
    {
        try
        {
            if (DisplayItems == null || DisplayItems.Count == 0)
            {
                _ = MessageService.ShowAsync("対象のページがありません。", MessageType.Warn);
                return;
            }
            var idx = Math.Max(0, Math.Min(DisplayItems.Count - 1, displayedPageNumber - 1));
            if (DisplayItems[idx].RawData is PageItem page)
            {
                currentPreviewImage = await PdfDataService.GetPreviewImageAsync(page.Id) ?? "";
            }

            InitialTrimRectNormalized = PdfDataService.GetTrimRect(idx);
            isTrimRangeDialogOpen = true;
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"OpenTrimRangeDialog error: {ex.Message}");
        }
    }

    private Task CloseTrimRangeDialog()
    {
        isTrimRangeDialogOpen = false;
        StateHasChanged();
        return Task.CompletedTask;
    }

    private async Task ApplyTrimRangeSettings(TrimRangeDialog.TrimRangeSettings settings)
    {
        try
        {
            await MessageService.ShowLoadingAsync("適用中...");
            await Task.Yield();

            int w = settings.ImageNaturalWidth;
            int h = settings.ImageNaturalHeight;

            if (w <= 0 || h <= 0)
            {
                try
                {
                    var curIndex = Math.Max(0, displayedPageNumber - 1);
                    var canvasId = $"trim-preview-canvas-{curIndex}";
                    var canvasSize = await JSRuntime.InvokeAsync<int[]>("getCanvasNaturalSize", canvasId);
                    if (canvasSize != null && canvasSize.Length >= 2)
                    {
                        w = canvasSize[0];
                        h = canvasSize[1];
                    }
                }
                catch { }
            }

            if (w <= 0 || h <= 0)
            {
                _ = MessageService.ShowAsync("プレビュー画像のサイズを取得できませんでした", MessageType.Error);
                return;
            }

            double nx = (double)settings.LeftMargin / w;
            double ny = (double)settings.TopMargin / h;
            double nw = Math.Max(0, 1.0 - (double)(settings.LeftMargin + settings.RightMargin) / w);
            double nh = Math.Max(0, 1.0 - (double)(settings.TopMargin + settings.BottomMargin) / h);

            List<int> targetPages = new();
            if (settings.ApplyRange == "current")
            {
                targetPages.Add(displayedPageNumber - 1);
            }
            else if (settings.ApplyRange == "all")
            {
                targetPages.AddRange(Enumerable.Range(0, DisplayItems.Count));
            }
            else if (settings.ApplyRange == "range")
            {
                int start = Math.Max(0, settings.RangeStart - 1);
                int end = Math.Min(DisplayItems.Count - 1, settings.RangeEnd - 1);
                targetPages.AddRange(Enumerable.Range(start, end - start + 1));
            }

            foreach (var idx in targetPages)
            {
                PdfDataService.SetTrimRect(idx, nx, ny, nw, nh);
            }

            _ = MessageService.ShowAsync("トリミング範囲を適用しました", MessageType.Success);
            isTrimRangeDialogOpen = false;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"ApplyTrimRangeSettings error: {ex.Message}");
            _ = MessageService.ShowAsync("トリミング範囲の適用に失敗しました", MessageType.Error);
        }
        finally
        {
            await MessageService.HideLoadingAsync();
            StateHasChanged();
        }
    }

    private async Task OnSnapToGridChanged()
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("setTrimSnapEnabled", useSnapToGrid);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"OnSnapToGridChanged error: {ex.Message}");
        }
    }

    // すべて選択
    private void SelectAllPreviewItems()
    {
        foreach (var item in ocrPreviewItems)
        {
            item.IsSelected = true;
        }
        StateHasChanged();
    }

    // すべて解除
    private void DeselectAllPreviewItems()
    {
        foreach (var item in ocrPreviewItems)
        {
            item.IsSelected = false;
        }
        StateHasChanged();
    }
        [JSInvokable("OnPreviewOutOfView")]
    public Task OnPreviewOutOfView(string pageId)
    {
        PdfDataService.ClearPreviewCache(pageId);
        return Task.CompletedTask;
    }
}