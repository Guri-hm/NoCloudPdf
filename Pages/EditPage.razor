@page "/edit/page/{FileId}/{PageIndex:int}"
@using NoCloudPdf.Models
@using Microsoft.AspNetCore.Components.Web
@using Microsoft.AspNetCore.Components
@using NoCloudPdf.Services
@using System.Text.Json
@using NoCloudPdf.Components
@inject IJSRuntime JSRuntime
@inject NavigationManager Navigation
@inject PdfDataService PdfDataService
@inject MessageService MessageService

<HeadContent>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+JP:wght@400;700&display=swap" rel="stylesheet">

</HeadContent>
<div class="edit-page-layout">
    <!-- ヘッダー -->
    <div class="sticky top-0 left-0 w-full bg-gray-800 text-white shadow z-50 flex-shrink-0">
        <div class="flex items-center justify-between px-4 py-2 scrollbar-thin scrollbar-thumb-gray-400 scrollbar-track-gray-200">
            <div class="flex flex-wrap gap-2 items-center">
                <ActionButtonGroup T="string" Actions="backToActions" />

                <div class="hidden md:block h-6 w-px bg-gray-300 mx-2" aria-hidden="true"></div>

                <h1 class="hidden md:inline text-lg font-bold">ページ編集</h1>
                @if (!string.IsNullOrEmpty(fileName))
                {
                    <span class="text-sm">@fileName - ページ @(PageIndex + 1)</span>
                }

                <ToggleButtonGroup T="EditTool" 
                    Items="toolToggleItems" 
                    ActiveValue="currentTool"
                    OnClick="OnToolChanged" />
                <ActionButtonGroup T="string" Actions="zoomActions" />
                <div class="flex items-center gap-2 flex-shrink-0">

                    @if (currentTool == EditTool.Text)
                    {
                        <div class="h-6 w-px bg-gray-300"></div>
                        <div class="flex items-center gap-2 flex-shrink-0">
                            <div class="flex flex-wrap items-center gap-2">
                                <select class="text-sm border rounded px-2 py-1 w-20 focus:ring-2 focus:ring-blue-200 focus:border-blue-400"
                                    value="@(editElements.FirstOrDefault(el => el.IsEditing)?.FontSize ?? fontSize)"
                                    @onchange="OnFontSizeChanged" 
                                    @onclick:stopPropagation
                                    @onmousedown:stopPropagation>
                                    <option value="10">10px</option>
                                    <option value="11">11px</option>
                                    <option value="12">12px</option>
                                    <option value="13">13px</option>
                                    <option value="14">14px</option>
                                    <option value="15">15px</option>
                                    <option value="16">16px</option>
                                    <option value="18">18px</option>
                                    <option value="20">20px</option>
                                    <option value="22">22px</option>
                                    <option value="24">24px</option>
                                    <option value="28">28px</option>
                                    <option value="32">32px</option>
                                    <option value="36">36px</option>
                                    <option value="40">40px</option>
                                    <option value="48">48px</option>
                                    <option value="56">56px</option>
                                    <option value="64">64px</option>
                                </select>
                                <input type="number" min="6" max="128" step="1"
                                    class="text-sm border rounded px-2 py-1 w-12 focus:ring-2 focus:ring-blue-200 focus:border-blue-400"
                                    value="@(editElements.FirstOrDefault(el => el.IsEditing)?.FontSize ?? fontSize)"
                                    @onchange="OnFontSizeChanged" @onclick:stopPropagation
    @onmousedown:stopPropagation placeholder="手入力" />
                                <span class="text-xs text-gray-500">px</span>

                                <input type="number" min="0" max="300" step="1"
                                class="text-sm border rounded px-2 py-1 w-12 focus:ring-2 focus:ring-blue-200 focus:border-blue-400"
                                value="@(editElements.FirstOrDefault(el => el.IsEditing)?.LineHeight ?? 0)"
                                @onchange="OnLineHeightChanged" @onclick:stopPropagation
    @onmousedown:stopPropagation />
                                <span class="text-xs text-gray-500">行間 (px, 0=自動)</span>

                                <select id="font-family-select"
                                    class="text-sm border rounded px-2 py-1 w-30 focus:ring-2 focus:ring-blue-200 focus:border-blue-400"
                                    value="@fontFamily"
                                    @onchange="OnFontFamilyChanged" @onmousedown="() => ignoreTextBlur = true">
                                    @* 編集中の要素 or 選択中の要素を取得 *@
                                    @{
                                        var editingElement = editElements.FirstOrDefault(el => el.IsEditing);
                                        var selectedElement = editElements.FirstOrDefault(el => selectedElementIds.Contains(el.Id));
                                        var targetElement = editingElement ?? selectedElement;
                                    }
                                    @if (targetElement != null && ContainsJapanese(targetElement.Text))
                                    {
                                        <option value="@FontFamilyNotoSans" title="Noto Sans JP — ゴシック系（日本語対応）">Noto Sans（ゴシック） — 日本語対応</option>
                                        <option value="@FontFamilyNotoSerif" title="Noto Serif JP — 明朝系（日本語対応）">Noto Serif（明朝） — 日本語対応</option>
                                    }
                                    else
                                    {
                                        <option value="@FontFamilyNotoSans" title="Noto Sans JP — ゴシック系（日本語対応）">Noto Sans（ゴシック） — 日本語対応</option>
                                        <option value="@FontFamilyNotoSerif" title="Noto Serif JP — 明朝系（日本語対応）">Noto Serif（明朝） — 日本語対応</option>
                                        <option value="sans-serif" title="ブラウザ既定のゴシック系（主に英数字）">システム ゴシック（英数字向け）</option>
                                        <option value="serif" title="ブラウザ既定の明朝系（主に英数字）">システム 明朝（英数字向け）</option>
                                        <option value="monospace" title="等幅フォント（コードや表記揃えに）">等幅（Monospace）</option>
                                        <option value="Arial, Helvetica, sans-serif" title="英字メインの欧文フォント">Arial（英字向け）</option>
                                        <option value="Times New Roman, serif" title="欧文の明朝系フォント">Times New Roman（英字向け）</option>
                                        <option value="Meiryo, sans-serif" title="メイリオ（Windows 日本語ゴシック）">Meiryo（Windows）</option>
                                        <option value="Yu Gothic, sans-serif" title="游ゴシック（Windows 日本語ゴシック）">游ゴシック（Windows）</option>
                                    }
                                </select>
                                <Tooltip Text="日本語テキストを含む場合は自動的にNotoSansフォントで表示・保存されます">
                                        <InfoIcon Class="w-5 h-5 inline-block ml-1 text-blue-400 cursor-pointer" />
                                </Tooltip>
                                <button
                                    @onclick="ToggleBold" 
                                    @onclick:stopPropagation
                                    title="太字"
                                    aria-pressed="@IsBoldActive"
                                    class="@(IsBoldActive ? "h-8 flex items-center justify-center px-2 rounded border border-blue-600 bg-blue-600 text-white transition-colors" : "h-8 flex items-center justify-center px-2 rounded border border-gray-300 bg-white hover:bg-gray-200")">
                                    <BoldIcon/>
                                </button>
                                <input type="color"
                                    class="w-8 h-8 border rounded focus:ring-2 focus:ring-blue-200 focus:border-blue-400"
                                    value="@CurrentTextColor"
                                    @oninput="OnTextColorInput"
                                    @onfocus="() => ignoreNextPageClick = true"
                                    @onblur="OnColorPickerBlur"
                                    @onclick:stopPropagation
                                    @onmousedown:stopPropagation/>
                            </div>
                        </div>
                    }
                    @if (currentTool == EditTool.Image)
                    {
                        <label class="flex items-center gap-1 text-sm flex-shrink-0">
                            <input type="checkbox" @bind="keepAspectRatio" />
                            アスペクト比固定
                        </label>
                        <label class="cursor-pointer px-3 py-1 bg-gray-200 text-gray-800 rounded hover:bg-gray-300">
                            画像を追加
                            <InputFile OnChange="OnImageSelected" multiple class="hidden" />
                        </label>
                    }
                </div>
            </div>
            <ActionButtonGroup T="string" Actions="primaryActions" />
        </div>
    </div>
        
    <!-- メインエディタエリア -->
    <div id="edit-canvas-container" class="flex-1 w-full overflow-auto flex justify-center items-start custom-scrollbar
    @(currentTool == EditTool.Text ? " cursor-text" : "")"
    @onmousedown="OnCanvasMouseDown" @onmouseup="OnElementMouseUp">
                <!-- PDF ページ -->
                <div class="pdf-page bg-white shadow-lg relative"
                    style="width:@(pageWidth * zoomLevel)px; height:@(pageHeight * zoomLevel)px; margin: 20px; transform: scale(1); transform-origin: center center;"
                    @onclick="OnPageClick">
                    <canvas id="pdf-canvas-@canvasUniqueId"
                            width="@(pageWidth)"
                            height="@(pageHeight)"
                            style="width:@(pageWidth * zoomLevel)px; height:@(pageHeight * zoomLevel)px;"
                            class="absolute inset-0"></canvas>

                    <!-- 編集要素 -->
                    @foreach (var element in editElements)
                    {
                        @if (element.Type == ElementType.Text)
                        {
                            <div class="edit-element text-element absolute cursor-move select-none
                                @(element.IsEditing
                                    ? "border-3 border-blue-600 bg-blue-50"
                                    : (selectedElementIds.Contains(element.Id)
                                        ? "border-2 border-blue-600"
                                        : "border-2 border-transparent"))"
                                style="
                                    left: @(element.X * zoomLevel)px;
                                    top: @(element.Y * zoomLevel)px;
                                    width: @(element.Width * zoomLevel)px;
                                    height: @(element.Height * zoomLevel)px;
                                    font-size: @(element.FontSize * zoomLevel)px;
                                    color: @element.Color;
                                    font-family: @(element.FontFamily);"
                                @onmousedown="(e) => OnElementMouseDown(e, element)"
                                @onmouseup="OnElementMouseUp"
                                >
                                @if (element.IsEditing)
                                {
                                    <textarea
                                        id="text-area-@element.Id"
                                        name="text-area-@element.Id"
                                        @bind="element.Text"
                                        @oninput="(e) => OnTextAreaInput(e, element)"
                                        @onblur="() => FinishTextEdit(element)"
                                        class="border-none outline-none bg-transparent resize-none overflow-hidden"
                                        style="width: 100%; height: auto; min-height: @((element.LineHeight > 0 ? element.LineHeight : element.FontSize) * zoomLevel)px; font-size: @(element.FontSize * zoomLevel)px; line-height: @((element.LineHeight > 0 ? element.LineHeight : element.FontSize) * zoomLevel)px; padding: 0; margin: 0; box-sizing: border-box; display: block; color: @element.Color; font-weight: @(element.IsBold ? "bold" : "normal"); @(element.FitTextToArea ? "white-space: nowrap; overflow: hidden;" : "white-space: pre-wrap; overflow-wrap: anywhere; word-break: break-word; overflow: hidden;")"
                                        wrap="@(element.FitTextToArea ? "off" : "soft")"
                                        @ref="textInputRef"
                                        @onclick:stopPropagation
                                        @onmousedown:stopPropagation
                                    />
                                }
                                else
                                {
                                    <span
                                        @onclick="() => { if (!element.IsEditing) SelectElement(element.Id); }"
                                        @ondblclick="() => StartTextEdit(element)"
                                        @onclick:stopPropagation
                                        @ondblclick:stopPropagation
                                        style="
                                            width: 100%;
                                            height: 100%;
                                            font-size: @(element.FontSize * zoomLevel)px;
                                            line-height: @((element.LineHeight > 0 ? element.LineHeight : element.FontSize) * zoomLevel)px;
                                            padding: 0;
                                            margin: 0;
                                            border: none;
                                            box-sizing: border-box;
                                            display: block;
                                            vertical-align: middle;
                                            color: @element.Color;
                                            font-weight: @(element.IsBold ? "bold" : "normal");
                                            @(element.FitTextToArea ? "white-space: nowrap; overflow: hidden;" : "white-space: normal; overflow-wrap: anywhere; word-break: break-word;")"
                                    >
                                        @((MarkupString)element.Text.Replace("\n", "<br />"))
                                    </span>
                                }
                                @if (selectedElementIds.Contains(element.Id) && !element.IsEditing)
                                {
                                    <div class="element-handles absolute inset-[-4px] pointer-events-none">
                                        @foreach (var handle in new[] { "nw", "n", "ne", "e", "se", "s", "sw", "w" })
                                        {
                                            <div class="handle handle-@handle absolute border border-white pointer-events-auto z-[10]"
                                                style="@GetHandleStyle(handle, element)"
                                                @onmousedown="@(e => OnTextResizeMouseDown(e, element, handle))"
                                                @onmousedown:stopPropagation>
                                            </div>
                                        }

                                        <div class="absolute top-0 left-[calc(100%+4px)] flex flex-col gap-1 rounded-md p-1 pointer-events-auto z-20" style="background-color:rgba(0, 0, 0, 0.6);">
                                            @if (currentTool == EditTool.Text)
                                            {
                                                <button class="w-6 h-6 bg-transparent text-white border-none rounded cursor-pointer flex items-center justify-center hover:bg-gray-600 transition-colors"
                                                    @onclick="() => StartTextEdit(element)" 
                                                    @onclick:stopPropagation 
                                                    title="テキスト編集">
                                                    <PenIcon Class="w-4 h-4"/>
                                                </button>
                                            }
                                            <button class="w-6 h-6 bg-transparent text-white border-none rounded cursor-pointer flex items-center justify-center hover:bg-red-600 transition-colors"
                                                @onclick="() => DeleteElement(element.Id)" 
                                                @onclick:stopPropagation 
                                                title="削除">
                                                <DeleteIcon Class="w-4 h-4"/>
                                            </button>
                                        </div>

                                    </div>
                                }
                            </div>
                        }
                        else if (element.Type == ElementType.Image)
                        {
                            <div class="edit-element image-element absolute select-none cursor-move
                                @(selectedElementIds.Contains(element.Id) ? "border-2 border-blue-600" : "border-2 border-transparent")"
                                style="
                                    left: @(element.X * zoomLevel)px;
                                    top: @(element.Y * zoomLevel)px;
                                    width: @(element.Width * zoomLevel)px;
                                    height: @(element.Height * zoomLevel)px;"
                                @onmousedown="(e) => OnImageMouseDown(e, element)"
                                @onmouseup="OnImageMouseUp"
                                @onclick="() => { if (currentTool == EditTool.Image || currentTool == EditTool.Select) SelectElement(element.Id); }"
                                @onclick:stopPropagation
                            >
                                <img src="@element.ImageUrl" class="w-full h-full object-contain pointer-events-none" style="object-fit:@(keepAspectRatio ? "contain" : "fill");" />
                                @if (selectedElementIds.Contains(element.Id) && currentTool == EditTool.Image || currentTool == EditTool.Select)
                                {
                                    <div class="element-handles absolute inset-0 pointer-events-none">
                                        @foreach (var handle in new[] { "nw", "n", "ne", "e", "se", "s", "sw", "w" })
                                        {
                                            <div class="handle handle-@handle absolute bg-blue-600 border border-white w-2 h-2 pointer-events-auto"
                                                style="@GetHandleStyle(handle, element)"
                                                @onmousedown="(e) => OnImageResizeMouseDown(e, element, handle)"
                                                @onmousedown:stopPropagation />
                                        }
                                    </div>
                                }
                                @if (selectedElementIds.Contains(element.Id))
                                {
                                    <button class="delete-btn absolute top-[-20px] right-[-20px] w-5 h-5 bg-red-500 text-white border-none rounded-full cursor-pointer pointer-events-auto flex items-center justify-center text-xs hover:bg-red-600"
                                            @onclick="() => DeleteElement(element.Id)" @onclick:stopPropagation title="削除">
                                            <CloseIcon/>
                                    </button>
                                }
                            </div>
                        }
                    }
                </div>
        
    </div>


</div>
<!-- ローディング中 -->
<LoadingOverlay />

<!-- メッセージ表示エリア -->
<MessageBar />

@code {
    // ページ表示時の元PDFデータを保持
    private string? originalPageData;
    private bool hasSaved = false;

    private DotNetObjectReference<EditPage>? _dotNetRef;
    private PageSourceInfo? cachedPageSource;

    [Parameter] public string FileId { get; set; } = "";
    [Parameter] public int PageIndex { get; set; }
    // 例: FileIdをピリオドなしに変換(cssセレクタでピリオドがクラス名として解釈されるため)
    private string GetSafeId(string fileId) =>
    fileId.Replace(".", "_").Replace("/", "_").Replace("\\", "_");

    private string safeFileId = "";
    protected override void OnParametersSet()
    {
        safeFileId = GetSafeId(FileId);
    }
    private string fileName = "";
    private int pageWidth = 595;
    private int pageHeight = 842;
    private double zoomLevel = 1.0;
    private double offsetX = 0;
    private double offsetY = 0;

    private string? draggingElementId = null;
    private double dragStartMouseX = 0;
    private double dragStartMouseY = 0;
    private double dragStartElementX = 0;
    private double dragStartElementY = 0;

    private string? draggingImageId = null;
    private string? resizingImageId = null;
    private string? resizingHandle = null;
    private double dragStartImageX, dragStartImageY;
    private double dragStartImageWidth, dragStartImageHeight;

    private EditTool currentTool = EditTool.Select;
    private double lastMouseX = 0;
    private double lastMouseY = 0;

    private bool ignoreNextPageClick = false;
    private bool ignoreTextBlur = false;

    // コンテナサイズのキャッシュ（ウィンドウリサイズ時に更新）
    private double containerWidth = 0;
    private double containerHeight = 0;
    
    // PDFページの余白（左右・上下）
    private const double PAGE_MARGIN_X = 20;
    private const double PAGE_MARGIN_Y = 20;

    // 選択された要素のIDリスト
    private List<string> selectedElementIds = new();

    private List<ToggleButtonItem<EditTool>> toolToggleItems = new()
    {
        new ToggleButtonItem<EditTool>
        {
            Value = EditTool.Select,
            Label = "選択",
            IconFragment = builder =>
            {
                builder.OpenComponent(0, typeof(ArrowPointerIcon));
                builder.AddAttribute(1, "Class", "w-6 h-6");
                builder.CloseComponent();
            }
        },
        new ToggleButtonItem<EditTool>
        {
            Value = EditTool.Text,
            Label = "テキスト",
            IconFragment = builder =>
            {
                builder.OpenComponent(0, typeof(FontIcon));
                builder.AddAttribute(1, "Class", "w-6 h-6");
                builder.CloseComponent();
            }
        },
        new ToggleButtonItem<EditTool>
        {
            Value = EditTool.Image,
            Label = "画像",
            IconFragment = builder =>
            {
                builder.OpenComponent(0, typeof(ImageIcon));
                builder.AddAttribute(1, "Class", "w-6 h-6");
                builder.CloseComponent();
            }
        }
    };

    private Task OnToolChanged(EditTool tool)
    {
        SetTool(tool);
        return Task.CompletedTask;
    }

    private List<ActionButtonItem> backToActions => new()
    {
        new ActionButtonItem
        {
            Label = "戻る",
            IconFragment = builder =>
            {
                builder.OpenComponent(0, typeof(ArrowLeftIcon));
                builder.CloseComponent();
            },
            Title = "戻る",
            OnClick = EventCallback.Factory.Create(this, NavigateBack),
        }
    };

    private List<ActionButtonItem> primaryActions => new()
    {
        new ActionButtonItem
        {
            Label = "保存",
            Title = "保存",
            OnClick = EventCallback.Factory.Create(this, SaveChanges),
            ButtonClass = "bg-blue-600 hover:bg-blue-700 px-8 transition hidden md:flex",
            IconPosition = "right",
            TextColor = "text-white"
        }
    };
    
    private List<ActionButtonItem> zoomActions => new()
    {
        new ActionButtonItem
        {
            Label = "幅に合わせる",
            IconFragment = builder =>
            {
                builder.OpenComponent(0, typeof(FitWidthIcon));
                builder.AddAttribute(1, "Class", "w-6 h-6"); 
                builder.CloseComponent();
            },
            Title = "幅に合わせる",
            OnClick = EventCallback.Factory.Create(this, FitToWidth),
        },
        new ActionButtonItem
        {
            Label = "高さに合わせる",
            IconFragment = builder =>
            {
                builder.OpenComponent(0, typeof(FitHeightIcon));
                builder.AddAttribute(1, "Class", "w-6 h-6"); 
                builder.CloseComponent();
            },
            Title = "高さに合わせる",
            OnClick = EventCallback.Factory.Create(this, FitToHeight),
        },
        new ActionButtonItem
        {
            Label = "実際のサイズ",
            IconFragment = builder =>
            {
                builder.OpenComponent(0, typeof(ViewRealSizeIcon));
                builder.AddAttribute(1, "Class", "w-6 h-6"); 
                builder.CloseComponent();
            },
            Title = "実際のサイズ",
            OnClick = EventCallback.Factory.Create(this, SetToActualSize),
        },
        new ActionButtonItem
        {
            IconFragment = builder =>
            {
                builder.OpenComponent(0, typeof(ZoomOutIcon));
                builder.AddAttribute(1, "Class", "w-6 h-6"); 
                builder.CloseComponent();
            },
            Title = "縮小",
            OnClick = EventCallback.Factory.Create(this, ZoomOut),
            IconPosition = "left"
        },
        new ActionButtonItem
        {
            Title = "倍率",
            Label = $"{(int)(zoomLevel * 100)}%"
        },
        new ActionButtonItem
        {
            IconFragment = builder =>
            {
                builder.OpenComponent(0, typeof(ZoomInIcon));
                builder.AddAttribute(1, "Class", "w-6 h-6"); 
                builder.CloseComponent();
            },
            Title = "拡大",
            OnClick = EventCallback.Factory.Create(this, ZoomIn),
            IconPosition = "left"
        }
    };

    private string fontFamily = "NotoSansJP, sans-serif";

    private string? canvasUniqueId;
    private bool _uiFitTextToArea = false;
    private bool uiFitTextToArea
    {
        get => _uiFitTextToArea;
        set
        {
            if (_uiFitTextToArea == value) return;
            _uiFitTextToArea = value;
            // 編集中の要素があればその要素に反映、なければ選択中の要素すべてに反映
            var editingElement = editElements.FirstOrDefault(el => el.IsEditing);
            if (editingElement != null)
            {
                editingElement.FitTextToArea = value;
            }
            else if (selectedElementIds.Count > 0)
            {
                foreach (var el in editElements.Where(el => selectedElementIds.Contains(el.Id)))
                    el.FitTextToArea = value;
            }
            StateHasChanged();
        }
    }
    private bool IsBoldActive
    {
        get
        {
            var editing = editElements.FirstOrDefault(el => el.IsEditing && el.Type == ElementType.Text);
            if (editing != null) return editing.IsBold;
            var selectedTextElems = editElements.Where(el => selectedElementIds.Contains(el.Id) && el.Type == ElementType.Text).ToList();
            if (!selectedTextElems.Any()) return false;
            return selectedTextElems.All(e => e.IsBold);
        }
    }
    
    private bool IsFitActive
    {
        get
        {
            var editing = editElements.FirstOrDefault(el => el.IsEditing && el.Type == ElementType.Text);
            if (editing != null) return editing.FitTextToArea;
            var selectedTextElems = editElements.Where(el => selectedElementIds.Contains(el.Id) && el.Type == ElementType.Text).ToList();
            if (!selectedTextElems.Any()) return uiFitTextToArea;
            return selectedTextElems.All(e => e.FitTextToArea);
        }
    }

    protected override void OnInitialized()
    {
        canvasUniqueId = Guid.NewGuid().ToString();
    }

    private bool IsNotoFamily(string? ff)
    {
        if (string.IsNullOrWhiteSpace(ff)) return false;
        var s = ff.Replace(" ", "").ToLowerInvariant();
        return s.Contains("noto");
    }
    // 日本語を含む場合は、ユーザーが選んだフォントが Noto 系ならそれを使い、
    // そうでなければ Noto Sans を強制する（非日本語なら選択をそのまま返す）
    private string ResolveFontForText(string text, string? preferred)
    {
        if (!ContainsJapanese(text)) return preferred ?? DefaultFontFamily;
        return IsNotoFamily(preferred) ? preferred! : FontFamilyNotoSans;
    }
    private async Task OnTextAreaInput(ChangeEventArgs e, EditElement element)
    {
        element.Text = e.Value?.ToString() ?? "";

        // 日本語が含まれていたらNotoSansJPに強制
        if (ContainsJapanese(element.Text))
        {
            var resolved = ResolveFontForText(element.Text, element.FontFamily ?? fontFamily);
            element.FontFamily = resolved;
            fontFamily = resolved;
        }

        if (element.FitTextToArea)
        {
            // 最大行幅を取得
            var maxLineWidth = await JSRuntime.InvokeAsync<double>(
                "measureMaxLineWidth",
                element.Text,
                element.FontSize * zoomLevel,
                element.FontFamily
            );
            element.Width = (maxLineWidth / zoomLevel) + (element.FontSize * 0.5); // 余白分はfontSizeに比例
        }
        else{

        }
        await Task.Yield();

        var scrollH = await JSRuntime.InvokeAsync<double>("autoResizeTextarea", textInputRef);
        if (scrollH > 0)
        {
            element.Height = Math.Max(6, scrollH / zoomLevel);
        }
        StateHasChanged(); 
    }
    private bool ContainsJapanese(string text)
    {
        // ひらがな・カタカナ・漢字のUnicode範囲で判定
        return System.Text.RegularExpressions.Regex.IsMatch(
            text,
            @"[\u3040-\u30FF\u3400-\u4DBF\u4E00-\u9FFF]"
        );
    }
    private void OnFontFamilyChanged(ChangeEventArgs e)
    {
        var value = e.Value?.ToString() ?? "sans-serif";
        var editingElement = editElements.FirstOrDefault(el => el.IsEditing);
        if (editingElement != null)
        {
            editingElement.FontFamily = value;
            fontFamily = value;
        }
        else if (selectedElementIds.Count > 0)
        {
            foreach (var el in editElements.Where(el => selectedElementIds.Contains(el.Id)))
            {
                el.FontFamily = value;
            }
            fontFamily = value;
        }
        else
        {
            fontFamily = value;
        }
        StateHasChanged();
    }

    private void OnLineHeightChanged(ChangeEventArgs e)
    {
        int val = 0;
        if (!int.TryParse(e.Value?.ToString(), out val)) val = 0;
        var editingElement = editElements.FirstOrDefault(el => el.IsEditing);
        if (editingElement != null)
        {
            editingElement.LineHeight = val;
        }
        else if (selectedElementIds.Count > 0)
        {
            foreach (var el in editElements.Where(el => selectedElementIds.Contains(el.Id)))
                el.LineHeight = val;
        }
        StateHasChanged();
    }

    private List<EditElement> editElements = new();

    private ElementReference textInputRef;

    private enum EditTool { Select, Text, Image }
    private enum ElementType { Text, Image }

    private class EditElement
    {
        public string Id { get; set; } = Guid.NewGuid().ToString();
        public ElementType Type { get; set; }
        public double X { get; set; }
        public double Y { get; set; }
        public double Width { get; set; } = 100;
        public double Height { get; set; } = 20;
        public string Text { get; set; } = "";
        public int FontSize { get; set; } = DefaultFontSize;
        // 0 = 自動（FontSize を使う）、>0 で px 単位の行高（ページ座標）
        public int LineHeight { get; set; } = 0;
        public string Color { get; set; } = "#000000";
        public string ImageUrl { get; set; } = "";
        public bool IsEditing { get; set; } = false;
        public string FontFamily { get; set; } = DefaultFontFamily;
        public double ImageOriginalWidth { get; set; }
        public double ImageOriginalHeight { get; set; }
        public bool IsBold { get; set; } = false;
        public int Rotation { get; set; } = 0;
        public bool FitTextToArea { get; set; } = false;
    }

    private string _textColor = "#000000";
    private string textColor
    {
        get => _textColor;
        set
        {
            _textColor = value;

            // 編集中の要素があればそれだけ
            var editingElement = editElements.FirstOrDefault(el => el.IsEditing);
            if (editingElement != null)
            {
                editingElement.Color = value;
            }
            // 選択中なら全て
            else if (selectedElementIds.Count > 0)
            {
                foreach (var el in editElements.Where(el => selectedElementIds.Contains(el.Id)))
                    el.Color = value;
            }
            StateHasChanged();
        }
    }

    private void ToggleBold()
    {
        ignoreTextBlur = true;
        var editingElement = editElements.FirstOrDefault(el => el.IsEditing);
        if (editingElement != null)
        {
            editingElement.IsBold = !editingElement.IsBold;
            StateHasChanged();
        }
        else if (selectedElementIds.Count > 0)
        {
            foreach (var el in editElements.Where(el => selectedElementIds.Contains(el.Id)))
                el.IsBold = !el.IsBold;
            StateHasChanged();
        }
    }
    private void OnColorPickerBlur(FocusEventArgs e)
    {
        ignoreNextPageClick = true;
    }

    private void OnTextColorInput(ChangeEventArgs e)
    {
        var value = e.Value?.ToString() ?? "#000000";
        textColor = value; // setterで編集中・選択中要素にも反映される
    }

    private string CurrentTextColor
    {
        get
        {
            var editingElement = editElements.FirstOrDefault(el => el.IsEditing);
            if (editingElement != null)
                return editingElement.Color;
            else if (selectedElementIds.Count > 0)
            {
                var selected = editElements.FirstOrDefault(el => selectedElementIds.Contains(el.Id));
                if (selected != null)
                    return selected.Color;
            }
            return textColor;
        }
        set
        {
            textColor = value;
        }
    }

    private const int DefaultFontSize = 16;
    private const string DefaultFontFamily = "NotoSansJP, sans-serif";
    private const string FontFamilyNotoSans = "NotoSansJP, sans-serif";
    private const string FontFamilyNotoSerif = "NotoSerifJP, serif";
    private int _fontSize = DefaultFontSize;
    private void ResetFontToDefault()
    {
        _fontSize = DefaultFontSize;
        fontFamily = DefaultFontFamily;
        StateHasChanged();
    }
    private int fontSize
    {
        get => _fontSize;
        set
        {
            _fontSize = value;
            var editingElement = editElements.FirstOrDefault(el => el.IsEditing);
            if (editingElement != null)
            {
                editingElement.FontSize = value;
            }
        }
    }

    // テキストリサイズ用フィールド/定数 ---
    private string? resizingTextId = null;
    private string? resizingTextHandle = null;
    private double dragStartTextMouseX = 0;
    private double dragStartTextMouseY = 0;
    private double dragStartTextMouseCanvasX = 0;
    private double dragStartTextMouseCanvasY = 0;
    private double dragStartTextElementX = 0;
    private double dragStartTextElementY = 0;
    private double dragStartTextElementWidth = 0;
    private double dragStartTextElementHeight = 0;
    private int dragStartTextFontSize = DefaultFontSize;
    private double anchorX, anchorY; // ページ座標で保持
    private double anchorFontSize;


    // ピクセル移動何pxでフォントサイズを1pt変えるか（調整可）
    private const double TextFontResizePixelsPerPoint = 4.0;

    private DateTime lastMouseMoveTime = DateTime.MinValue;
    private const int MouseMoveThrottleMs = 16; // 約60FPS（16ms間隔）

    private RectDto? cachedCanvasRect = null;
    private DateTime canvasRectCacheTime = DateTime.MinValue;
    private const int CanvasRectCacheMs = 100; // 100ms間キャッシュ

    private async Task<RectDto> GetCanvasRect()
    {
        var now = DateTime.UtcNow;
        if (cachedCanvasRect != null && (now - canvasRectCacheTime).TotalMilliseconds < CanvasRectCacheMs)
        {
            return cachedCanvasRect; // キャッシュを使用
        }

        // 新しく取得
        cachedCanvasRect = await JSRuntime.InvokeAsync<RectDto>("getElementRect", $"#pdf-canvas-{canvasUniqueId}");
        canvasRectCacheTime = now;
        return cachedCanvasRect;
    }
    
    private void OnElementMouseMove(MouseEventArgs e)
    {
        // 何もしていない場合は即座にリターン（StateHasChangedを呼ばない）
        if (resizingTextId == null && draggingElementId == null && draggingImageId == null && resizingImageId == null)
        {
            return; // 同期メソッドなので自動レンダリングされない
        }

        // フレームレート制限（60FPS以下にする）
        DateTime now = DateTime.UtcNow;
        if ((now - lastMouseMoveTime).TotalMilliseconds < MouseMoveThrottleMs)
        {
            return;
        }
        lastMouseMoveTime = now;

        // 実際の処理は非同期で実行（await不要）
        _ = OnElementMouseMoveAsync(e);

    }

    // 実際の処理を行う非同期メソッド
    private async Task OnElementMouseMoveAsync(MouseEventArgs e)
    {

        bool changed = false;

        // テキストリサイズ中のみ処理（ドラッグ中でなければ何もしない）
        if (resizingTextId == null && draggingElementId == null && draggingImageId == null && resizingImageId == null)
        {
            return; 
        }

        // テキストリサイズ中
        if (resizingTextId != null && resizingTextHandle != null)
        {
            var element = editElements.FirstOrDefault(el => el.Id == resizingTextId);
            if (element != null)
            {
                // キャッシュされたCanvasRectを使用
                var canvasRect = await GetCanvasRect();
                var mouseCanvasX = (e.ClientX - canvasRect.left) / zoomLevel;
                var mouseCanvasY = (e.ClientY - canvasRect.top) / zoomLevel;

                // マウスの差分（ページ座標単位）
                var dx = mouseCanvasX - dragStartTextMouseCanvasX;
                var dy = mouseCanvasY - dragStartTextMouseCanvasY;

                double newX = dragStartTextElementX;
                double newY = dragStartTextElementY;
                double newWidth = dragStartTextElementWidth;
                double newHeight = dragStartTextElementHeight;
                int newFontSize = dragStartTextFontSize;

                switch (resizingTextHandle)
                {
                    case "nw":
                        // 右下固定
                        newWidth = Math.Max(dragStartTextElementWidth - dx, 6);
                        newHeight = Math.Max(dragStartTextElementHeight - dy, 6);
                        newX = dragStartTextElementX + (dragStartTextElementWidth - newWidth);
                        newY = dragStartTextElementY + (dragStartTextElementHeight - newHeight);
                        if (element.FitTextToArea)
                        {
                            newFontSize = Math.Max(6, (int)Math.Round(newHeight));
                            var maxLineWidthNW = await JSRuntime.InvokeAsync<double>(
                                "measureMaxLineWidth",
                                element.Text,
                                newFontSize * zoomLevel,
                                element.FontFamily
                            );
                            newWidth = (maxLineWidthNW / zoomLevel) + (newFontSize * 0.5);
                            newX = dragStartTextElementX + (dragStartTextElementWidth - newWidth);
                        }
                        break;

                    case "ne":
                        // 左下固定
                        newWidth = Math.Max(dragStartTextElementWidth + dx, 6);
                        newHeight = Math.Max(dragStartTextElementHeight - dy, 6);
                        newX = dragStartTextElementX;
                        newY = dragStartTextElementY + (dragStartTextElementHeight - newHeight);
                        if (element.FitTextToArea)
                        {
                            newFontSize = Math.Max(6, (int)Math.Round(newHeight));
                            var maxLineWidthNE = await JSRuntime.InvokeAsync<double>(
                                "measureMaxLineWidth",
                                element.Text,
                                newFontSize * zoomLevel,
                                element.FontFamily
                            );
                            newWidth = (maxLineWidthNE / zoomLevel) + (newFontSize * 0.5);
                        }
                        break;

                    case "sw":
                        // 右上固定
                        newWidth = Math.Max(dragStartTextElementWidth - dx, 6);
                        newHeight = Math.Max(dragStartTextElementHeight + dy, 6);
                        newX = dragStartTextElementX + (dragStartTextElementWidth - newWidth);
                        newY = dragStartTextElementY;
                        if (element.FitTextToArea)
                        {
                            newFontSize = Math.Max(6, (int)Math.Round(newHeight));
                            var maxLineWidthSW = await JSRuntime.InvokeAsync<double>(
                                "measureMaxLineWidth",
                                element.Text,
                                newFontSize * zoomLevel,
                                element.FontFamily
                            );
                            newWidth = (maxLineWidthSW / zoomLevel) + (newFontSize * 0.5);
                            newX = dragStartTextElementX + (dragStartTextElementWidth - newWidth);
                        }
                        break;

                    case "se":
                        // 左上固定
                        newWidth = Math.Max(dragStartTextElementWidth + dx, 6);
                        newHeight = Math.Max(dragStartTextElementHeight + dy, 6);
                        newX = dragStartTextElementX;
                        newY = dragStartTextElementY;
                        if (element.FitTextToArea)
                        {
                            newFontSize = Math.Max(6, (int)Math.Round(newHeight));
                            var maxLineWidthSE = await JSRuntime.InvokeAsync<double>(
                                "measureMaxLineWidth",
                                element.Text,
                                newFontSize * zoomLevel,
                                element.FontFamily
                            );
                            newWidth = (maxLineWidthSE / zoomLevel) + (newFontSize * 0.5);
                        }
                        break;

                    case "n":
                        // 下辺（中心）固定 — 高さを変える (上にドラッグで縮小)
                        newHeight = Math.Max(dragStartTextElementHeight - dy, 6);
                        newY = dragStartTextElementY + (dragStartTextElementHeight - newHeight);
                        if (element.FitTextToArea)
                        {
                            newFontSize = Math.Max(6, (int)Math.Round(newHeight));
                            var maxLineWidthN = await JSRuntime.InvokeAsync<double>(
                                "measureMaxLineWidth",
                                element.Text,
                                newFontSize * zoomLevel,
                                element.FontFamily
                            );
                            newWidth = (maxLineWidthN / zoomLevel) + (newFontSize * 0.5);
                            newX = dragStartTextElementX + (dragStartTextElementWidth - newWidth) / 2.0;
                        }
                        else
                        {
                            newWidth = dragStartTextElementWidth;
                            newX = dragStartTextElementX;
                        }
                        break;

                    case "s":
                        // 上辺（中心）固定 — 高さを変える
                        newHeight = Math.Max(dragStartTextElementHeight + dy, 6);
                        newY = dragStartTextElementY;
                        if (element.FitTextToArea)
                        {
                            newFontSize = Math.Max(6, (int)Math.Round(newHeight));
                            var maxLineWidthS = await JSRuntime.InvokeAsync<double>(
                                "measureMaxLineWidth",
                                element.Text,
                                newFontSize * zoomLevel,
                                element.FontFamily
                            );
                            newWidth = (maxLineWidthS / zoomLevel) + (newFontSize * 0.5);
                            newX = dragStartTextElementX + (dragStartTextElementWidth - newWidth) / 2.0;
                        }
                        else
                        {
                            newWidth = dragStartTextElementWidth;
                            newX = dragStartTextElementX;
                        }
                        break;

                    case "w":
                        // 右辺（中心）固定 — 幅を変える (左にドラッグで縮小)
                        newWidth = Math.Max(dragStartTextElementWidth - dx, 6);
                        newX = dragStartTextElementX + (dragStartTextElementWidth - newWidth);
                        newY = dragStartTextElementY;
                        if (element.FitTextToArea)
                        {
                            // 高さは固定 -> フォントサイズは変えない
                            newFontSize = element.FontSize;
                        }
                        break;

                    case "e":
                        // 左辺（中心）固定 — 幅を変える
                        newWidth = Math.Max(dragStartTextElementWidth + dx, 6);
                        newX = dragStartTextElementX;
                        newY = dragStartTextElementY;
                        if (element.FitTextToArea)
                        {
                            newFontSize = element.FontSize;
                        }
                        break;
                }

                // 最低値確保
                newWidth = Math.Max(newWidth, 6);
                newHeight = Math.Max(newHeight, 6);

                // 反映
                element.X = Math.Round(newX, 3);
                element.Y = Math.Round(newY, 3);
                element.Width = Math.Round(newWidth, 3);
                element.Height = Math.Round(newHeight, 3);
                if (element.FitTextToArea)
                {
                    element.FontSize = newFontSize;
                    fontSize = newFontSize;
                }
                changed = true;
            }
        }

        if (changed) StateHasChanged();
    }

    private async void OnTextResizeMouseDown(MouseEventArgs e, EditElement element, string handle)
    {
        resizingTextId = element.Id;
        resizingTextHandle = handle;
        dragStartTextMouseX = e.ClientX;
        dragStartTextMouseY = e.ClientY;
        dragStartTextFontSize = element.FontSize;

        // キャッシュされたCanvasRectを使ってマウスのスタート座標をページ座標に変換して保持
        var canvasRect = await GetCanvasRect();
        dragStartTextMouseCanvasX = (e.ClientX - canvasRect.left) / zoomLevel;
        dragStartTextMouseCanvasY = (e.ClientY - canvasRect.top) / zoomLevel;

        // 要素の開始状態を保持
        dragStartTextElementX = element.X;
        dragStartTextElementY = element.Y;
        dragStartTextElementWidth = element.Width;
        dragStartTextElementHeight = element.Height;

        // 基点も保持（従来のロジックも残すが、移動量ベースで計算するようにした）
        switch (handle)
        {
            case "nw": // 右下が基点
                anchorX = element.X + element.Width;
                anchorY = element.Y + element.Height;
                break;
            case "ne": // 左下が基点
                anchorX = element.X;
                anchorY = element.Y + element.Height;
                break;
            case "sw": // 右上が基点
                anchorX = element.X + element.Width;
                anchorY = element.Y;
                break;
            case "se": // 左上が基点
                anchorX = element.X;
                anchorY = element.Y;
                break;
            case "n": // 下辺中心が基点
                anchorX = element.X + element.Width / 2.0;
                anchorY = element.Y + element.Height;
                break;
            case "s": // 上辺中心が基点
                anchorX = element.X + element.Width / 2.0;
                anchorY = element.Y;
                break;
            case "w": // 右辺中心が基点
                anchorX = element.X + element.Width;
                anchorY = element.Y + element.Height / 2.0;
                break;
            case "e": // 左辺中心が基点
                anchorX = element.X;
                anchorY = element.Y + element.Height / 2.0;
                break;
        }
        anchorFontSize = element.FontSize;
        draggingElementId = null;
        await JSRuntime.InvokeVoidAsync("setEditPageMouseActive", true);
    }

    // マウスアップ時にリサイズを終了
    private void OnElementMouseUp(MouseEventArgs e)
    {
        draggingElementId = null;
        // テキストリサイズ終了
        resizingTextId = null;
        resizingTextHandle = null;

        // 既存: 画像イベントも解除
        draggingImageId = null;
        resizingImageId = null;
        resizingHandle = null;
        StateHasChanged();
    }

    private string GetHandleStyle(string handle, EditElement element)
    {
        var w = element.Width * zoomLevel;
        var h = element.Height * zoomLevel;
        var positions = new Dictionary<string, string>
        {
            ["nw"] = "top:-4px;left:-4px;cursor:nw-resize;",
            ["n"]  = $"top:-4px;left:{w/2-4}px;cursor:n-resize;",
            ["ne"] = $"top:-4px;right:-4px;cursor:ne-resize;",
            ["e"]  = $"top:{h/2-4}px;right:-4px;cursor:e-resize;",
            ["se"] = $"bottom:-4px;right:-4px;cursor:se-resize;",
            ["s"]  = $"bottom:-4px;left:{w/2-4}px;cursor:s-resize;",
            ["sw"] = $"bottom:-4px;left:-4px;cursor:sw-resize;",
            ["w"]  = $"top:{h/2-4}px;left:-4px;cursor:w-resize;"
        };
        return positions[handle];
    }

    private async void OnElementMouseDown(MouseEventArgs e, EditElement element)
    {
        if (element.Type != ElementType.Text || !selectedElementIds.Contains(element.Id)) return;
        draggingElementId = element.Id;
        dragStartMouseX = e.ClientX;
        dragStartMouseY = e.ClientY;
        dragStartElementX = element.X;
        dragStartElementY = element.Y;
        await JSRuntime.InvokeVoidAsync("setEditPageMouseActive", true);
    }

    private async void OnFontSizeChanged(ChangeEventArgs e)
    {
        int value;
        if (!int.TryParse(e.Value?.ToString(), out value))
        {
            value = DefaultFontSize;
        }
        var editingElement = editElements.FirstOrDefault(el => el.IsEditing);
        if (editingElement != null)
        {
            editingElement.FontSize = value;
            if (editingElement.FitTextToArea)
            {
                var maxLineWidth = await JSRuntime.InvokeAsync<double>(
                    "measureMaxLineWidth",
                    editingElement.Text,
                    editingElement.FontSize * zoomLevel,
                    editingElement.FontFamily
                );
                editingElement.Width = (maxLineWidth / zoomLevel) + (editingElement.FontSize * 0.5);
            }
        }
        else if (selectedElementIds.Count > 0)
        {
            foreach (var el in editElements.Where(el => selectedElementIds.Contains(el.Id)))
            {
                el.FontSize = value;
                if (el.FitTextToArea)
                {
                    var maxLineWidth = await JSRuntime.InvokeAsync<double>(
                        "measureMaxLineWidth",
                        el.Text,
                        el.FontSize * zoomLevel,
                        el.FontFamily
                    );
                    el.Width = (maxLineWidth / zoomLevel) + (el.FontSize * 0.5);
                }
            }
        }
        else
        {
            fontSize = value;
        }
        StateHasChanged();
    }

    private async void StartTextEdit(EditElement element)
    {
        foreach (var el in editElements)
            el.IsEditing = false;

        element.IsEditing = true;
        selectedElementIds.Clear();
        selectedElementIds.Add(element.Id);

        fontFamily = element.FontFamily;
        _fontSize = element.FontSize;

        uiFitTextToArea = element.FitTextToArea;

        StateHasChanged();
        await Task.Yield(); // レンダリング待ち

        try
        {
            await textInputRef.FocusAsync();
            var totalParentPx = await JSRuntime.InvokeAsync<double>("autoResizeTextarea", textInputRef);
            if (totalParentPx > 0) element.Height = Math.Max(6, totalParentPx / zoomLevel);
        }
        catch
        {
            // フォーカス失敗は無視
        }
    }

    private bool keepAspectRatio = true;

    private async void OnImageMouseDown(MouseEventArgs e, EditElement element)
    {
        if ((currentTool != EditTool.Image && currentTool != EditTool.Select) || !selectedElementIds.Contains(element.Id)) return;
        draggingImageId = element.Id;
        dragStartMouseX = e.ClientX;
        dragStartMouseY = e.ClientY;
        dragStartImageX = element.X;
        dragStartImageY = element.Y;
        await JSRuntime.InvokeVoidAsync("setEditPageMouseActive", true);
    }

    private void OnImageMouseMove(MouseEventArgs e)
    {
        bool changed = false;
        if (draggingImageId != null)
        {
            var element = editElements.FirstOrDefault(el => el.Id == draggingImageId);
            if (element == null) return;
            var dx = (e.ClientX - dragStartMouseX) / zoomLevel;
            var dy = (e.ClientY - dragStartMouseY) / zoomLevel;
            element.X = dragStartImageX + dx;
            element.Y = dragStartImageY + dy;
            changed = true;
        }
        else if (resizingImageId != null && resizingHandle != null)
        {
            var element = editElements.FirstOrDefault(el => el.Id == resizingImageId);
            if (element == null) return;
            var dx = (e.ClientX - dragStartMouseX) / zoomLevel;
            var dy = (e.ClientY - dragStartMouseY) / zoomLevel;
            ResizeImageElement(element, resizingHandle, dx, dy);
            changed = true;
        }
        if (changed) StateHasChanged();
    }

    private void OnImageMouseUp(MouseEventArgs e)
    {
        draggingImageId = null;
        resizingImageId = null;
        resizingHandle = null;
    }

    private void OnImageResizeMouseDown(MouseEventArgs e, EditElement element, string handle)
    {
        resizingImageId = element.Id;
        resizingHandle = handle;
        dragStartMouseX = e.ClientX;
        dragStartMouseY = e.ClientY;
        dragStartImageX = element.X;
        dragStartImageY = element.Y;
        dragStartImageWidth = element.Width;
        dragStartImageHeight = element.Height;
    }

    private void ResizeImageElement(EditElement element, string handle, double dx, double dy)
    {
        double minSize = 20;
        double aspect = element.ImageOriginalWidth > 0 && element.ImageOriginalHeight > 0
            ? element.ImageOriginalWidth / element.ImageOriginalHeight
            : 1.0;

        double newX = dragStartImageX;
        double newY = dragStartImageY;
        double newWidth = dragStartImageWidth;
        double newHeight = dragStartImageHeight;

        if (keepAspectRatio)
        {
            switch (handle)
            {
                case "n":
                    {
                        double rawHeight = dragStartImageHeight - dy;
                        newHeight = Math.Max(rawHeight, minSize);
                        double actualDy = dragStartImageHeight - newHeight;
                        newWidth = Math.Max(newHeight * aspect, minSize);
                        newY = dragStartImageY + actualDy;
                    }
                    break;
                case "s":
                    {
                        double rawHeight = dragStartImageHeight + dy;
                        newHeight = Math.Max(rawHeight, minSize);
                        newWidth = Math.Max(newHeight * aspect, minSize);
                    }
                    break;
                case "e":
                    {
                        double rawWidth = dragStartImageWidth + dx;
                        newWidth = Math.Max(rawWidth, minSize);
                        newHeight = Math.Max(newWidth / aspect, minSize);
                    }
                    break;
                case "w":
                    {
                        double rawWidth = dragStartImageWidth - dx;
                        newWidth = Math.Max(rawWidth, minSize);
                        double actualDx = dragStartImageWidth - newWidth;
                        newHeight = Math.Max(newWidth / aspect, minSize);
                        newX = dragStartImageX + actualDx;
                    }
                    break;
                case "nw":
                    {
                        // dx,dyのうち絶対値が大きい方を優先
                        double delta = Math.Abs(dx) > Math.Abs(dy) ? dx : dy;
                        double rawWidth = dragStartImageWidth - delta;
                        newWidth = Math.Max(rawWidth, minSize);
                        newHeight = Math.Max(newWidth / aspect, minSize);
                        double actualDelta = dragStartImageWidth - newWidth;
                        newX = dragStartImageX + actualDelta;
                        newY = dragStartImageY + (dragStartImageHeight - newHeight);
                    }
                    break;
                case "ne":
                    {
                        double delta = Math.Abs(dx) > Math.Abs(dy) ? -dx : dy;
                        double rawWidth = dragStartImageWidth + dx;
                        newWidth = Math.Max(rawWidth, minSize);
                        newHeight = Math.Max(newWidth / aspect, minSize);
                        newY = dragStartImageY + (dragStartImageHeight - newHeight);
                    }
                    break;
                case "se":
                    {
                        double delta = Math.Abs(dx) > Math.Abs(dy) ? dx : dy;
                        double rawWidth = dragStartImageWidth + delta;
                        newWidth = Math.Max(rawWidth, minSize);
                        newHeight = Math.Max(newWidth / aspect, minSize);
                    }
                    break;
                case "sw":
                    {
                        double delta = Math.Abs(dx) > Math.Abs(dy) ? dx : -dy;
                        double rawWidth = dragStartImageWidth - dx;
                        newWidth = Math.Max(rawWidth, minSize);
                        newHeight = Math.Max(newWidth / aspect, minSize);
                        double actualDx = dragStartImageWidth - newWidth;
                        newX = dragStartImageX + actualDx;
                    }
                    break;
            }
        }
        else
        {
            // アスペクト比無視（今のままでOK）
            switch (handle)
            {
                case "nw":
                    newX = dragStartImageX + dx;
                    newY = dragStartImageY + dy;
                    newWidth = Math.Max(dragStartImageWidth - dx, minSize);
                    newHeight = Math.Max(dragStartImageHeight - dy, minSize);
                    break;
                case "n":
                    newY = dragStartImageY + dy;
                    newHeight = Math.Max(dragStartImageHeight - dy, minSize);
                    break;
                case "ne":
                    newY = dragStartImageY + dy;
                    newWidth = Math.Max(dragStartImageWidth + dx, minSize);
                    newHeight = Math.Max(dragStartImageHeight - dy, minSize);
                    break;
                case "e":
                    newWidth = Math.Max(dragStartImageWidth + dx, minSize);
                    break;
                case "se":
                    newWidth = Math.Max(dragStartImageWidth + dx, minSize);
                    newHeight = Math.Max(dragStartImageHeight + dy, minSize);
                    break;
                case "s":
                    newHeight = Math.Max(dragStartImageHeight + dy, minSize);
                    break;
                case "sw":
                    newX = dragStartImageX + dx;
                    newWidth = Math.Max(dragStartImageWidth - dx, minSize);
                    newHeight = Math.Max(dragStartImageHeight + dy, minSize);
                    break;
                case "w":
                    newX = dragStartImageX + dx;
                    newWidth = Math.Max(dragStartImageWidth - dx, minSize);
                    break;
            }
        }

        element.X = newX;
        element.Y = newY;
        element.Width = newWidth;
        element.Height = newHeight;
    }

    [JSInvokable]
    public void OnGlobalMouseUp()
    {
        draggingElementId = null;
        draggingImageId = null;
        resizingImageId = null;
        resizingHandle = null;
        resizingTextId = null;
        resizingTextHandle = null;
        StateHasChanged();
    }

    public class MouseMoveArgs
    {
        public double ClientX { get; set; }
        public double ClientY { get; set; }
    }

    public class SizeDto
    {
        public double width { get; set; }
        public double height { get; set; }
    }

    public class ImageConvertResult
    {
        public string pngBase64 { get; set; } = "";
        public double width { get; set; }
        public double height { get; set; }
    }

    [JSInvokable]
public async Task OnGlobalMouseMove(MouseMoveArgs e)
{
    bool changed = false;

    // --- テキストリサイズをグローバルで処理（OnElementMouseMove と同等） ---
    if (resizingTextId != null && resizingTextHandle != null)
    {
        var element = editElements.FirstOrDefault(el => el.Id == resizingTextId);
        if (element != null)
        {
            // canvas rect を取得（キャッシュ利用）
            var canvasRect = await GetCanvasRect();
            var mouseCanvasX = (e.ClientX - canvasRect.left) / zoomLevel;
            var mouseCanvasY = (e.ClientY - canvasRect.top) / zoomLevel;

            var dx = mouseCanvasX - dragStartTextMouseCanvasX;
            var dy = mouseCanvasY - dragStartTextMouseCanvasY;

            double newX = dragStartTextElementX;
            double newY = dragStartTextElementY;
            double newWidth = dragStartTextElementWidth;
            double newHeight = dragStartTextElementHeight;
            int newFontSize = dragStartTextFontSize;

            switch (resizingTextHandle)
            {
                case "nw":
                    newWidth = Math.Max(dragStartTextElementWidth - dx, 6);
                    newHeight = Math.Max(dragStartTextElementHeight - dy, 6);
                    newX = dragStartTextElementX + (dragStartTextElementWidth - newWidth);
                    newY = dragStartTextElementY + (dragStartTextElementHeight - newHeight);
                    if (element.FitTextToArea)
                    {
                        newFontSize = Math.Max(6, (int)Math.Round(newHeight));
                        var maxLineWidthNW = await JSRuntime.InvokeAsync<double>(
                            "measureMaxLineWidth",
                            element.Text,
                            newFontSize * zoomLevel,
                            element.FontFamily
                        );
                        newWidth = (maxLineWidthNW / zoomLevel) + (newFontSize * 0.5);
                        newX = dragStartTextElementX + (dragStartTextElementWidth - newWidth);
                    }
                    break;
                case "ne":
                    newWidth = Math.Max(dragStartTextElementWidth + dx, 6);
                    newHeight = Math.Max(dragStartTextElementHeight - dy, 6);
                    newX = dragStartTextElementX;
                    newY = dragStartTextElementY + (dragStartTextElementHeight - newHeight);
                    if (element.FitTextToArea)
                    {
                        newFontSize = Math.Max(6, (int)Math.Round(newHeight));
                        var maxLineWidthNE = await JSRuntime.InvokeAsync<double>(
                            "measureMaxLineWidth",
                            element.Text,
                            newFontSize * zoomLevel,
                            element.FontFamily
                        );
                        newWidth = (maxLineWidthNE / zoomLevel) + (newFontSize * 0.5);
                    }
                    break;
                case "sw":
                    newWidth = Math.Max(dragStartTextElementWidth - dx, 6);
                    newHeight = Math.Max(dragStartTextElementHeight + dy, 6);
                    newX = dragStartTextElementX + (dragStartTextElementWidth - newWidth);
                    newY = dragStartTextElementY;
                    if (element.FitTextToArea)
                    {
                        newFontSize = Math.Max(6, (int)Math.Round(newHeight));
                        var maxLineWidthSW = await JSRuntime.InvokeAsync<double>(
                            "measureMaxLineWidth",
                            element.Text,
                            newFontSize * zoomLevel,
                            element.FontFamily
                        );
                        newWidth = (maxLineWidthSW / zoomLevel) + (newFontSize * 0.5);
                        newX = dragStartTextElementX + (dragStartTextElementWidth - newWidth);
                    }
                    break;
                case "se":
                    newWidth = Math.Max(dragStartTextElementWidth + dx, 6);
                    newHeight = Math.Max(dragStartTextElementHeight + dy, 6);
                    newX = dragStartTextElementX;
                    newY = dragStartTextElementY;
                    if (element.FitTextToArea)
                    {
                        newFontSize = Math.Max(6, (int)Math.Round(newHeight));
                        var maxLineWidthSE = await JSRuntime.InvokeAsync<double>(
                            "measureMaxLineWidth",
                            element.Text,
                            newFontSize * zoomLevel,
                            element.FontFamily
                        );
                        newWidth = (maxLineWidthSE / zoomLevel) + (newFontSize * 0.5);
                    }
                    break;
                case "n":
                    newHeight = Math.Max(dragStartTextElementHeight - dy, 6);
                    newY = dragStartTextElementY + (dragStartTextElementHeight - newHeight);
                    if (element.FitTextToArea)
                    {
                        newFontSize = Math.Max(6, (int)Math.Round(newHeight));
                        var maxLineWidthN = await JSRuntime.InvokeAsync<double>(
                            "measureMaxLineWidth",
                            element.Text,
                            newFontSize * zoomLevel,
                            element.FontFamily
                        );
                        newWidth = (maxLineWidthN / zoomLevel) + (newFontSize * 0.5);
                        newX = dragStartTextElementX + (dragStartTextElementWidth - newWidth) / 2.0;
                    }
                    else
                    {
                        newWidth = dragStartTextElementWidth;
                        newX = dragStartTextElementX;
                    }
                    break;
                case "s":
                    newHeight = Math.Max(dragStartTextElementHeight + dy, 6);
                    newY = dragStartTextElementY;
                    if (element.FitTextToArea)
                    {
                        newFontSize = Math.Max(6, (int)Math.Round(newHeight));
                        var maxLineWidthS = await JSRuntime.InvokeAsync<double>(
                            "measureMaxLineWidth",
                            element.Text,
                            newFontSize * zoomLevel,
                            element.FontFamily
                        );
                        newWidth = (maxLineWidthS / zoomLevel) + (newFontSize * 0.5);
                        newX = dragStartTextElementX + (dragStartTextElementWidth - newWidth) / 2.0;
                    }
                    else
                    {
                        newWidth = dragStartTextElementWidth;
                        newX = dragStartTextElementX;
                    }
                    break;
                case "w":
                    newWidth = Math.Max(dragStartTextElementWidth - dx, 6);
                    newX = dragStartTextElementX + (dragStartTextElementWidth - newWidth);
                    newY = dragStartTextElementY;
                    if (element.FitTextToArea)
                    {
                        newFontSize = element.FontSize;
                    }
                    break;
                case "e":
                    newWidth = Math.Max(dragStartTextElementWidth + dx, 6);
                    newX = dragStartTextElementX;
                    newY = dragStartTextElementY;
                    if (element.FitTextToArea)
                    {
                        newFontSize = element.FontSize;
                    }
                    break;
            }

            newWidth = Math.Max(newWidth, 6);
            newHeight = Math.Max(newHeight, 6);

            element.X = Math.Round(newX, 3);
            element.Y = Math.Round(newY, 3);
            element.Width = Math.Round(newWidth, 3);
            element.Height = Math.Round(newHeight, 3);
            if (element.FitTextToArea)
            {
                element.FontSize = newFontSize;
                fontSize = newFontSize;
            }
            changed = true;
        }
    }

    // --- 既存の画像リサイズ / ドラッグ処理（そのまま） ---
    // 画像リサイズ
    if (resizingImageId != null && resizingHandle != null)
    {
        var element = editElements.FirstOrDefault(el => el.Id == resizingImageId);
        if (element == null) return;
        var dx = (e.ClientX - dragStartMouseX) / zoomLevel;
        var dy = (e.ClientY - dragStartMouseY) / zoomLevel;
        ResizeImageElement(element, resizingHandle, dx, dy);
        changed = true;
    }
    // 画像ドラッグ
    else if (draggingImageId != null)
    {
        var element = editElements.FirstOrDefault(el => el.Id == draggingImageId);
        if (element == null) return;
        var dx = (e.ClientX - dragStartMouseX) / zoomLevel;
        var dy = (e.ClientY - dragStartMouseY) / zoomLevel;
        element.X = dragStartImageX + dx;
        element.Y = dragStartImageY + dy;
        changed = true;
    }
    // テキスト要素のドラッグ
    else if (draggingElementId != null)
    {
        var element = editElements.FirstOrDefault(el => el.Id == draggingElementId);
        if (element == null) return;
        var dx = (e.ClientX - dragStartMouseX) / zoomLevel;
        var dy = (e.ClientY - dragStartMouseY) / zoomLevel;
        element.X = dragStartElementX + dx;
        element.Y = dragStartElementY + dy;
        changed = true;
    }

    if (changed) StateHasChanged();
}

    [JSInvokable]
    public async Task OnImageBase64Loaded(string base64, double width, double height)
    {
        // canvas の実表示サイズを取得して、その中で画像が最大で表示されるサイズを決める
        var canvasSelector = $"#pdf-canvas-{canvasUniqueId}";
        var canvasRect = await JSRuntime.InvokeAsync<RectDto>("getElementRect", canvasSelector);

        // フォールバックは displayWidth/displayHeight（既に Redraw で設定済み）
        var availW = canvasRect.width > 0 ? canvasRect.width : pageWidth * zoomLevel;
        var availH = canvasRect.height > 0 ? canvasRect.height : pageHeight * zoomLevel;

        // 親（canvas）に対して画像を占める最大比率（例: 50%）
        double maxRatio = 0.5;
        double maxWidth = Math.Max(1, availW * maxRatio);
        double maxHeight = Math.Max(1, availH * maxRatio);

        double scale = Math.Min(maxWidth / width, maxHeight / height);
        if (scale > 1) scale = 1;

        double displayW = width * scale;
        double displayH = height * scale;

        // element.Width/Height は「ページ座標単位」で格納しているので、表示ピクセル -> ページ座標に戻す
        var element = new EditElement
        {
            Type = ElementType.Image,
            X = 100,
            Y = 100,
            Width = displayW / zoomLevel,
            Height = displayH / zoomLevel,
            ImageOriginalWidth = width,
            ImageOriginalHeight = height,
            ImageUrl = base64
        };
        editElements.Add(element);
        StateHasChanged();
    }

    private string inputFileKey = Guid.NewGuid().ToString();

    private async Task OnImageSelected(InputFileChangeEventArgs e)
    {
        var files = e.GetMultipleFiles();
        if (files == null || files.Count == 0)
        {
            _ = MessageService.ShowAsync("ファイルが選択されていません。", MessageType.Warn);
            return;
        }

        var file = files[0];
        var contentType = file.ContentType?.ToLower() ?? "";

        try
        {
            // 最大サイズを指定（例: 5MB = 5 * 1024 * 1024）
            const long maxSize = 5 * 1024 * 1024;
            using var stream = file.OpenReadStream(maxSize);
            using var ms = new MemoryStream();
            await stream.CopyToAsync(ms);
            var base64 = $"data:{contentType};base64,{Convert.ToBase64String(ms.ToArray())}";
            if (contentType == "image/png" || contentType == "image/jpeg")
            {
                var size = await JSRuntime.InvokeAsync<SizeDto>("getImageSizeFromBase64", base64);
                await OnImageBase64Loaded(base64, size.width, size.height);
            }
            else if (contentType == "image/gif" || contentType == "image/bmp" ||
                    contentType == "image/webp" || contentType == "image/svg+xml")
            {
                var result = await JSRuntime.InvokeAsync<ImageConvertResult>("convertImageToPngBase64AndSize", base64,contentType);
                await OnImageBase64Loaded(result.pngBase64, result.width, result.height);
            }
            else
            {
                _ = MessageService.ShowAsync("対応していない画像形式です。PNG, JPEG, GIF, BMP, WebP, SVGのみ追加できます。", MessageType.Warn);
                return;
            }
        }
        catch (IOException ex)
        {
            _ = MessageService.ShowAsync("画像サイズが大きすぎます（最大5MBまで）。", MessageType.Warn);
            Console.WriteLine($"画像サイズエラー: {ex.Message}");
        }
        catch (Exception ex)
        {
            _ = MessageService.ShowAsync("画像の読み込みに失敗しました。", MessageType.Error);
            Console.WriteLine($"画像読み込みエラー: {ex.Message}");
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        Console.WriteLine("Rendered EditPage component");
        if (firstRender)
        {
            try{

                await MessageService.ShowLoadingAsync("読み込み中...");

                _dotNetRef = DotNetObjectReference.Create(this);
                //await JSRuntime.InvokeVoidAsync("registerGlobalMouseUp", _dotNetRef);
                //await JSRuntime.InvokeVoidAsync("registerGlobalMouseMove", _dotNetRef);
                await JSRuntime.InvokeVoidAsync("registerEditPageMouseHandlers", _dotNetRef);
                //await JSRuntime.InvokeVoidAsync("registerEditPageResize", _dotNetRef);
                // 初期コンテナサイズを取得
                var size = await JSRuntime.InvokeAsync<SizeDto>("updateEditContainerSize");
                containerWidth = size.width;
                containerHeight = size.height;

                var allPages = PdfDataService.GetModel().Pages;
                var pageItem = allPages.FirstOrDefault(p => p.FileId == FileId && p.OriginalPageIndex == PageIndex);

                if (pageItem == null)
                {
                    Navigation.NavigateTo("/edit");
                    return;
                }

                fileName = pageItem.FileName ?? "";

                // ここで元データを保持
                originalPageData = pageItem.PageData;

                cachedPageSource = await JSRuntime.InvokeAsync<PageSourceInfo>("getPageSourceInfo", safeFileId, PageIndex, pageItem.PageData);
                if (cachedPageSource == null)
                {
                    cachedPageSource = new PageSourceInfo { 
                        origW = pageWidth, 
                        origH = pageHeight, 
                        dpr = await JSRuntime.InvokeAsync<double>("getDevicePixelRatio")
                    };
                }

                // 回転角度を考慮して幅・高さを入れ替え
                var rotateAngle = pageItem.RotateAngle;
                if (rotateAngle % 180 != 0)
                {
                    pageWidth = (int)cachedPageSource.origH;
                    pageHeight = (int)cachedPageSource.origW;
                }
                else
                {
                    pageWidth = (int)cachedPageSource.origW;
                    pageHeight = (int)cachedPageSource.origH;
                }

                // 初期表示時にキャンバス/親要素の実サイズを取得して、ページ全体が見える倍率に合わせる
                await RedrawPdfPage(applyFit: true);

                StateHasChanged();

            }catch(Exception ex)
            {
                Console.WriteLine($"初期化エラー: {ex.Message}");
            }finally{
                await MessageService.HideLoadingAsync();

            }

        }
    }

    public async ValueTask DisposeAsync()
    {
        //await JSRuntime.InvokeVoidAsync("unregisterGlobalMouseUp");
        //await JSRuntime.InvokeVoidAsync("unregisterGlobalMouseMove");
        await JSRuntime.InvokeVoidAsync("unregisterEditPageMouseHandlers");
        //await JSRuntime.InvokeVoidAsync("unregisterEditPageResize");
        _dotNetRef?.Dispose();
    }

    [JSInvokable]
    public async Task OnWindowResized(double width, double height)
    {
        containerWidth = width;
        containerHeight = height;
        // 必要に応じて再描画
        await InvokeAsync(StateHasChanged);
    }

    private async void NavigateBack()
    {
        if (hasSaved)
        {
            var confirmed = await JSRuntime.InvokeAsync<bool>("confirm", "ページ遷移すると、追加した要素の再編集できなくなります。本当に移動しますか？");
            if (!confirmed)
                return;
        }
        //JavaScript interop で history.back() を使うのも検討
        Navigation.NavigateTo("/edit");
    }

    private async void ZoomIn()
    {
        zoomLevel = Math.Min(zoomLevel * 1.2, 5.0);
        await RedrawPdfPage();
        Console.WriteLine($"ZoomIn: zoomLevel={zoomLevel}");
    }

    private async void ZoomOut()
    {
        zoomLevel = Math.Max(zoomLevel / 1.2, 0.1);
        await RedrawPdfPage();
        Console.WriteLine($"ZoomOut: zoomLevel={zoomLevel}");
    }

    private async void FitToScreen()
    {
        offsetX = 0;
        offsetY = 0;
        await RedrawPdfPage(applyFit: true);
        Console.WriteLine("FitToScreen executed");
    }

    private async void FitToWidth()
    {
        offsetX = 0;
        offsetY = 0;
        
        var src = cachedPageSource;
        if (src == null)
        {
            src = new PageSourceInfo
            {
                origW = pageWidth,
                origH = pageHeight,
                dpr = 1.0
            };
        }

        // 利用可能な幅に合わせてズームレベルを計算（余白を考慮）
        var availW = Math.Max(1, containerWidth - (PAGE_MARGIN_X * 2));
        var logicalW = Math.Max(1, src.origW);
        
        // 小数点第3位で丸める
        zoomLevel = Math.Round(Math.Max(0.1, Math.Min(availW / logicalW, 5.0)), 3);
        await RedrawPdfPage();
    }

    private async void FitToHeight()
    {
        offsetX = 0;
        offsetY = 0;
        
        var src = cachedPageSource;
        if (src == null)
        {
            src = new PageSourceInfo
            {
                origW = pageWidth,
                origH = pageHeight,
                dpr = 1.0
            };
        }

        // 利用可能な高さに合わせてズームレベルを計算（余白を考慮）
        var availH = Math.Max(1, containerHeight - (PAGE_MARGIN_Y * 2));
        var logicalH = Math.Max(1, src.origH);
        
        zoomLevel = Math.Round(Math.Max(0.1, Math.Min(availH / logicalH, 5.0)), 3);
        await RedrawPdfPage();
    }

    private async void FitToBoth()
    {
        offsetX = 0;
        offsetY = 0;
        
        var src = cachedPageSource;
        if (src == null)
        {
            src = new PageSourceInfo
            {
                origW = pageWidth,
                origH = pageHeight,
                dpr = 1.0
            };
        }

        // 縦横両方に合わせる（大きい方の倍率を使用、余白を考慮）
        var availW = Math.Max(1, containerWidth - (PAGE_MARGIN_X * 2));
        var availH = Math.Max(1, containerHeight - (PAGE_MARGIN_Y * 2));
        var logicalW = Math.Max(1, src.origW);
        var logicalH = Math.Max(1, src.origH);
        
        // 両方いっぱいに表示（はみ出しても良い）
        zoomLevel = Math.Round(Math.Max(0.1, Math.Min(Math.Max(availW / logicalW, availH / logicalH), 5.0)), 3);
        Console.WriteLine($"FitToBoth: availW={availW}, availH={availH}, logicalW={logicalW}, logicalH={logicalH}, zoomLevel={zoomLevel}");
        await RedrawPdfPage();
    }

    private async void SetToActualSize()
    {
        offsetX = 0;
        offsetY = 0;
        zoomLevel = 1.0; // 100% = 実際のPDFサイズ
        Console.WriteLine($"SetToActualSize: zoomLevel={zoomLevel}");
        await RedrawPdfPage();
    }
    private class RectDto
    {
        public double left { get; set; }
        public double top { get; set; }
        public double width { get; set; }
        public double height { get; set; }
    }

    public class PageSourceInfo {
        public double origW { get; set; } 
        public double origH { get; set; } 
        public double cssW { get; set; } 
        public double cssH { get; set; } 
        public double backingW { get; set; } 
        public double backingH { get; set; } 
        public double dpr { get; set; }
    }

    // PDF再描画用メソッド
    private async Task RedrawPdfPage(bool applyFit = false)
    {
        var allPages = PdfDataService.GetModel().Pages;
        var pageItem = allPages.FirstOrDefault(p => p.FileId == FileId && p.OriginalPageIndex == PageIndex);
        if (pageItem == null) return;

        if (applyFit)
        {
            // 初回表示時は待機させてfitScaleの正確に取得（異常値だと描画が真っ白になる）
            await InvokeAsync(StateHasChanged);
            await JSRuntime.InvokeVoidAsync("waitForNextFrame");
        }
        var src = cachedPageSource;
        if (src == null)
        {
            src = new PageSourceInfo
            {
                origW = pageWidth,
                origH = pageHeight,
                dpr = 1.0
            };
        }

        // 編集領域コンテナの可用サイズを取得
        var availW = Math.Max(1, containerWidth - (PAGE_MARGIN_X * 2));
        var availH = Math.Max(1, containerHeight - (PAGE_MARGIN_Y * 2));

        // origW/origH を基準にフィット（これで横長なら横幅いっぱい、縦長なら縦幅いっぱい）
        var logicalW = Math.Max(1, src.origW);
        var logicalH = Math.Max(1, src.origH);
        double fitScale = Math.Min(availW / logicalW, availH / logicalH);
        if (double.IsNaN(fitScale) || fitScale <= 0) fitScale = 1.0;

        if (applyFit)
        {
            zoomLevel = 1.0;
        }
        var rotateAngle = pageItem.RotateAngle;

        await JSRuntime.InvokeVoidAsync("drawPdfPageToCanvas", canvasUniqueId, pageItem?.PageData ?? "", zoomLevel, rotateAngle);
    }

    private void SetTool(EditTool tool)
    {
        currentTool = tool;
        selectedElementIds.Clear();
    }

    private void OnCanvasMouseDown(MouseEventArgs e)
    {
        // テキストエリアのドラッグ中はページ移動を開始しない
        if (draggingElementId != null) return;

        if (currentTool == EditTool.Select)
        {
            lastMouseX = e.ClientX;
            lastMouseY = e.ClientY;
        }
    }

    private void OnCanvasMouseUp(MouseEventArgs e)
    {
        draggingElementId = null;
    }

    private void OnCanvasWheel(WheelEventArgs e)
    {
        if (e.DeltaY < 0)
            ZoomIn();
        else
            ZoomOut();
    }

    // C#で座標を受け取るクラス
    private class CanvasCoords
    {
        public double x { get; set; }
        public double y { get; set; }
    }
    private async Task OnPageClick(MouseEventArgs e)
    {
        // カラーピッカーが開いている場合は何もしない
        if (ignoreNextPageClick)
        {
            ignoreNextPageClick = false;
            return;
        }

        // JSでクリックターゲットのタグ名を取得
        //var tagName = await JSRuntime.InvokeAsync<string>("getTagNameFromEvent", e);
        //if (tagName == "INPUT" || tagName == "BUTTON") return;

        // すでにテキスト編集中の要素があれば追加しない
        var editingElement = editElements.FirstOrDefault(el => el.IsEditing);
        if (editingElement != null)
        {
            // ここで全てのIsEditingをfalseにしておく
            foreach (var el in editElements)
                el.IsEditing = false;
            StateHasChanged();
            return;
        }

        // 選択中が1つ以上なら、選択解除だけして終了
        if (selectedElementIds.Count > 0)
        {
            selectedElementIds.Clear();
            ResetFontToDefault();
            return;
        }

        // テキストボックス新規追加
        if (currentTool == EditTool.Text)
        {
            // JSで正確なキャンバス座標を取得
            var coords = await JSRuntime.InvokeAsync<CanvasCoords>(
            "getCanvasCoords",
            $"#pdf-canvas-{canvasUniqueId}",
            e.ClientX,
            e.ClientY,
            zoomLevel
            );

            // テキストボックス追加位置をカーソルの上端に合わせる
            var adjustedY = coords.y - fontSize;

            var element = new EditElement
            {
                Type = ElementType.Text,
                X = coords.x,
                Y = adjustedY,
                Text = "入力...",
                FontSize = fontSize,
                Color = textColor,
                IsEditing = true,
                FontFamily = DefaultFontFamily,
                FitTextToArea = uiFitTextToArea
            };
            editElements.Add(element);

            // 実行しないと新規作成したテキストボックスが表示されない
            StateHasChanged();
            await InvokeAsync(StateHasChanged);
            await Task.Yield();
            try
            {
                await textInputRef.FocusAsync();
                await JSRuntime.InvokeVoidAsync("selectAllTextarea", textInputRef);
                await JSRuntime.InvokeVoidAsync("autoResizeTextarea", textInputRef);
            }
            catch
            {
                // フォーカス失敗は無視
            }
        }
        else
        {
            selectedElementIds.Clear();
            ResetFontToDefault();
        }
    }

    // 選択された要素のIDを格納
    private void SelectElement(string elementId, bool multi = false)
    {
        // すべての編集中状態を解除
        foreach (var el in editElements)
            el.IsEditing = false;

        if (multi)
        {
            if (!selectedElementIds.Contains(elementId))
                selectedElementIds.Add(elementId);
        }
        else
        {
            selectedElementIds.Clear();
            selectedElementIds.Add(elementId);
        }

        var selected = editElements.FirstOrDefault(el => el.Id == elementId);
        if (selected != null)
        {
            // 日本語なら選択フォントが Noto 系なら尊重、そうでなければ Noto Sans を使う
            if (ContainsJapanese(selected.Text))
                fontFamily = IsNotoFamily(selected.FontFamily) ? selected.FontFamily : FontFamilyNotoSans;
            else
                fontFamily = selected.FontFamily;
            if (selected.Type == ElementType.Text)
            {
                _fontSize = selected.FontSize;
                uiFitTextToArea = selected.FitTextToArea;
            }
        }

        StateHasChanged();
    }

    private void FinishTextEdit(EditElement element)
    {
        if (ignoreTextBlur)
        {
            ignoreTextBlur = false;
            // ツールバー操作時は編集中を維持
            return;
        }

        element.IsEditing = false;
        fontFamily = ResolveFontForText(element.Text, element.FontFamily);

        // blur による直後の page click で新規追加されないようにする
        ignoreNextPageClick = true;

        // 念のため短時間後に自動解除（例: 300ms）。不要なら削除可。
        _ = Task.Run(async () =>
        {
            await Task.Delay(300);
            ignoreNextPageClick = false;
            await InvokeAsync(StateHasChanged);
        });

        StateHasChanged();
    }

    private async Task OnTextKeyPress(KeyboardEventArgs e, EditElement element)
    {
        if (e.Key == "Enter")
        {
            element.IsEditing = false;
            await textInputRef.FocusAsync();
        }
    }

    private void DeleteElement(string elementId)
    {
        editElements.RemoveAll(e => e.Id == elementId);
        selectedElementIds.Remove(elementId);

        // フォントサイズをデフォルトに戻す
        if (selectedElementIds.Count == 0)
        {
            ResetFontToDefault();
        }

    }

    private List<EditElement> GetElementsForSave(int pageWidth, int pageHeight, int rotateAngle)
    {
        var result = new List<EditElement>();
        foreach (var el in editElements)
        {
            var newEl = new EditElement
            {
                Id = el.Id,
                Type = el.Type,
                Text = el.Text,
                FontSize = el.FontSize,
                Color = el.Color,
                FontFamily = el.FontFamily,
                IsBold = el.IsBold,
                ImageUrl = el.ImageUrl,
                ImageOriginalWidth = el.ImageOriginalWidth,
                ImageOriginalHeight = el.ImageOriginalHeight,
                LineHeight = el.LineHeight
            };

            if (rotateAngle == 90)
            {
                newEl.X = el.Y +  el.Height;
                newEl.Y = pageWidth - el.X -el.Height;
                newEl.Width = el.Height;
                newEl.Height = el.Width;
                //newEl.Rotation = (el.Rotation - 90 + 360) % 360;
                newEl.Rotation = rotateAngle; // ← PDF-libは左回転
            }
            else if (rotateAngle == 180)
            {
                newEl.X = pageWidth - el.X;
                newEl.Y = pageHeight - el.Y - el.Height - (el.FontSize * 0.5);
                newEl.Width = el.Width;
                newEl.Height = el.Height;
                newEl.Rotation = rotateAngle;
            }
            else if (rotateAngle == 270)
            {
                newEl.X = pageHeight - el.Y - el.Height - (el.FontSize * 0.5);
                newEl.Y = el.X - el.Height - (el.FontSize * 0.5);
                newEl.Width = el.Height;
                newEl.Height = el.Width;
                newEl.Rotation = rotateAngle;
            }
            else
            {
                newEl.X = el.X;
                newEl.Y = el.Y;
                newEl.Width = el.Width;
                newEl.Height = el.Height;
                newEl.Rotation = 0;
            }
            result.Add(newEl);
        }
        return result;
    }

    private async Task SaveChanges()
    {

        // 現在のページを取得
        var allPages = PdfDataService.GetModel().Pages;
        var pageItem = allPages.FirstOrDefault(p => p.FileId == FileId && p.OriginalPageIndex == PageIndex);

        if (pageItem != null)
        {
            try
            {
                await MessageService.ShowLoadingAsync("保存中...");
                var elementsForSave = GetElementsForSave(pageWidth, pageHeight, pageItem.RotateAngle);
                var editJson = JsonSerializer.Serialize(elementsForSave);

                // 元データ（originalPageData）に編集要素を追加して新PDF生成
                var newPdfBase64 = await JSRuntime.InvokeAsync<string>(
                    "editPdfPageWithElements",
                    originalPageData, // extractPdfPageで取得したPDF Base64
                    editJson
                );
                pageItem.PageData = newPdfBase64;
                pageItem.Thumbnail = "";
                
                var newThumbnail = await JSRuntime.InvokeAsync<string>(
                    "generatePdfThumbnailFromPageData", pageItem.PageData);
                pageItem.Thumbnail = newThumbnail;

                _ = MessageService.ShowAsync($"変更を保存しました", type: MessageType.Success);
                hasSaved = true;
            }
            catch (Exception ex)
            {
                _ = MessageService.ShowAsync($"保存時エラー: {ex.Message}",type: MessageType.Error);
                Console.WriteLine($"保存時エラー: {ex}");
            }
            finally
            {
                await MessageService.HideLoadingAsync();
            }
        }
        else
        {
            _ = MessageService.ShowAsync("ページ情報が見つかりません", type: MessageType.Error);
        }
    }
}
