@page "/edit/page/{FileId}/{PageIndex:int}"
@using NoCloudPdf.Models
@using Microsoft.AspNetCore.Components.Web
@using Microsoft.AspNetCore.Components
@using NoCloudPdf.Services
@inject IJSRuntime JS
@inject NavigationManager Navigation
@inject PdfDataService PdfDataService

<div class="edit-page-container h-screen flex flex-col">
    <!-- ヘッダー -->
    <div class="bg-white shadow-sm border-b px-4 py-3 flex items-center justify-between">
        <div class="flex items-center gap-4">
            <button @onclick="NavigateBack" class="text-gray-600 hover:text-gray-800">
                <i class="fa-solid fa-arrow-left text-xl"></i>
            </button>
            <h1 class="text-lg font-semibold">ページ編集</h1>
            @if (!string.IsNullOrEmpty(fileName))
            {
                <span class="text-sm text-gray-500">@fileName - ページ @(PageIndex + 1)</span>
            }
        </div>
        <div class="flex items-center gap-3">
            <button @onclick="SaveChanges" class="bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded">
                保存
            </button>
        </div>
    </div>

    <!-- ツールバー -->
    <div class="bg-gray-50 border-b px-4 py-2 flex items-center gap-4">
        <!-- ズーム -->
        <div class="flex items-center gap-2">
            <button @onclick="ZoomOut" class="p-2 hover:bg-gray-200 rounded">
                <i class="fa-solid fa-minus"></i>
            </button>
            <span class="text-sm font-medium w-16 text-center">@((int)(zoomLevel * 100))%</span>
            <button @onclick="ZoomIn" class="p-2 hover:bg-gray-200 rounded">
                <i class="fa-solid fa-plus"></i>
            </button>
            <button @onclick="FitToScreen" class="px-3 py-1 text-sm bg-gray-200 hover:bg-gray-300 rounded">
                画面に合わせる
            </button>
        </div>

        <div class="h-6 w-px bg-gray-300"></div>

        <!-- ツール選択 -->
        <div class="flex items-center gap-2">
            <button @onclick="() => SetTool(EditTool.Select)"
                class="p-2 rounded @(currentTool == EditTool.Select ? "bg-blue-100 text-blue-600" : "hover:bg-gray-200")">
                <i class="fa-solid fa-mouse-pointer"></i>
            </button>
            <button @onclick="() => SetTool(EditTool.Text)"
                class="p-2 rounded @(currentTool == EditTool.Text ? "bg-blue-100 text-blue-600" : "hover:bg-gray-200")">
                <i class="fa-solid fa-font"></i>
            </button>
            <button @onclick="() => SetTool(EditTool.Image)"
                class="p-2 rounded @(currentTool == EditTool.Image ? "bg-blue-100 text-blue-600" : "hover:bg-gray-200")">
                <i class="fa-solid fa-image"></i>
            </button>
        </div>

        @if (currentTool == EditTool.Text)
        {
            <div class="h-6 w-px bg-gray-300"></div>
            <div class="flex items-center gap-2">
                <select class="text-sm border rounded px-2 py-1 w-20 focus:ring-2 focus:ring-blue-200 focus:border-blue-400"
                    value="@(editElements.FirstOrDefault(el => el.IsEditing)?.FontSize ?? fontSize)"
                    @onchange="OnFontSizeChanged" @onmousedown="() => ignoreTextBlur = true">
                    <option value="10">10px</option>
                    <option value="11">11px</option>
                    <option value="12">12px</option>
                    <option value="13">13px</option>
                    <option value="14">14px</option>
                    <option value="15">15px</option>
                    <option value="16">16px</option>
                    <option value="18">18px</option>
                    <option value="20">20px</option>
                    <option value="22">22px</option>
                    <option value="24">24px</option>
                    <option value="28">28px</option>
                    <option value="32">32px</option>
                    <option value="36">36px</option>
                    <option value="40">40px</option>
                    <option value="48">48px</option>
                    <option value="56">56px</option>
                    <option value="64">64px</option>
                </select>
                <input type="number" min="6" max="128" step="1"
                    class="text-sm border rounded px-2 py-1 w-16 focus:ring-2 focus:ring-blue-200 focus:border-blue-400"
                    value="@(editElements.FirstOrDefault(el => el.IsEditing)?.FontSize ?? fontSize)"
                    @onchange="OnFontSizeChanged" @onmousedown="() => ignoreTextBlur = true" placeholder="手入力" />
                <span class="text-xs text-gray-500">px</span>

                <select class="text-sm border rounded px-2 py-1 w-28 focus:ring-2 focus:ring-blue-200 focus:border-blue-400"
                    value="@(editElements.FirstOrDefault(el => el.IsEditing)?.FontFamily ?? fontFamily)"
                    @onchange="OnFontFamilyChanged" @onmousedown="() => ignoreTextBlur = true">
                    <option value="sans-serif">標準（ゴシック）</option>
                    <option value="serif">明朝体</option>
                    <option value="monospace">等幅</option>
                    <option value="Arial, Helvetica, sans-serif">Arial</option>
                    <option value="Times New Roman, serif">Times New Roman</option>
                    <option value="Meiryo, sans-serif">メイリオ</option>
                    <option value="Yu Gothic, sans-serif">游ゴシック</option>
                </select>
                <input type="color"
                    class="w-8 h-8 border rounded focus:ring-2 focus:ring-blue-200 focus:border-blue-400"
                    value="@CurrentTextColor"
                    @oninput="OnTextColorInput"
                    @onfocus="() => ignoreNextPageClick = true"
                    @onblur="OnColorPickerBlur"
                    @onclick:stopPropagation @onmousedown="() => ignoreTextBlur = true"/>
            </div>
        }
        @if (currentTool == EditTool.Image)
        {
            <label class="flex items-center gap-1 text-sm">
                <input type="checkbox" @bind="keepAspectRatio" />
                アスペクト比固定
            </label>
            <button class="px-3 py-1 bg-gray-200 text-gray-800 rounded hover:bg-gray-300"
                    @onclick="TriggerImageInput">
                画像を追加
            </button>
        }
    </div>

    <!-- メインエディタエリア -->
    <div class="edit-canvas-container h-full w-full overflow-auto flex justify-center items-center
            @(currentTool == EditTool.Text ? "cursor-text" : (isDragging && currentTool == EditTool.Select ? "cursor-grabbing" : "cursor-grab"))"
            @onmousedown="OnCanvasMouseDown" @onmousemove="OnCanvasMouseMove" @onmouseup="OnElementMouseUp"
            @onwheel="OnCanvasWheel">

            <div class="edit-canvas-wrapper relative"
                style="transform: translate(@(offsetX)px, @(offsetY)px) scale(@zoomLevel); transform-origin: 0 0;">

                <!-- PDF ページ -->
                <div class="pdf-page bg-white shadow-lg relative"
                    style="width: @(pageWidth* zoomLevel)px; height: @(pageHeight* zoomLevel)px;"
                    @onclick="OnPageClick">

                    <canvas id="pdf-canvas-@safeFileId-@PageIndex" width="@(pageWidth* zoomLevel)"
                        height="@(pageHeight* zoomLevel)"
                        style="width: @(pageWidth* zoomLevel)px; height: @(pageHeight* zoomLevel)px;"
                        class="absolute inset-0"></canvas>

                    <!-- 編集要素 -->
                    @foreach (var element in editElements)
                    {
                        @if (element.Type == ElementType.Text)
                        {
                            <div class="edit-element text-element absolute cursor-move select-none
                                @(element.IsEditing
                                    ? "border-2 border-blue-600 bg-blue-50"
                                    : (selectedElementIds.Contains(element.Id)
                                        ? "border-2 border-blue-600"
                                        : "border-2 border-transparent"))"
                                style="left: @(element.X * zoomLevel)px; top: @(element.Y * zoomLevel)px; font-size: @(element.FontSize * zoomLevel)px; color: @element.Color; font-family: @(element.FontFamily);"
                                @onmousedown="(e) => OnElementMouseDown(e, element)"
                                @onmouseup="OnElementMouseUp"
                                @onmousemove="OnElementMouseMove"
                                >
                                @if (element.IsEditing)
                                {
                                    <input type="text" @bind="element.Text" @onblur="() => FinishTextEdit(element)"
                                        @onkeypress="(e) => OnTextKeyPress(e, element)"
                                        class="border-none outline-none bg-transparent"
                                        style="font-size: @(element.FontSize)px; color: @element.Color;" @ref="textInputRef"
                                        @onclick:stopPropagation @onmousedown:stopPropagation />
                                }
                                else
                                {
                                    <span @onclick="() => { if (!element.IsEditing) SelectElement(element.Id); }"
                                        @ondblclick="() => StartTextEdit(element)" @onclick:stopPropagation
                                        @ondblclick:stopPropagation
                                        style="font-size: @(element.FontSize * zoomLevel)px; color: @element.Color; font-family: @(element.FontFamily);"
                                        >
                                        @element.Text
                                    </span>
                                }
                                @if (selectedElementIds.Contains(element.Id))
                                {
                                    <div class="element-handles absolute inset-[-4px] pointer-events-none">
                                        <div class="handle handle-nw absolute w-2 h-2 bg-blue-600 border border-white pointer-events-auto cursor-nw-resize top-[-4px] left-[-4px]"></div>
                                        <div class="handle handle-ne absolute w-2 h-2 bg-blue-600 border border-white pointer-events-auto cursor-ne-resize top-[-4px] right-[-4px]"></div>
                                        <div class="handle handle-sw absolute w-2 h-2 bg-blue-600 border border-white pointer-events-auto cursor-sw-resize bottom-[-4px] left-[-4px]"></div>
                                        <div class="handle handle-se absolute w-2 h-2 bg-blue-600 border border-white pointer-events-auto cursor-se-resize bottom-[-4px] right-[-4px]"></div>
                                        @if (!element.IsEditing)
                                        {
                                            @if (currentTool == EditTool.Text)
                                            {
                                                <button class="edit-btn absolute top-[-12px] right-[12px] w-5 h-5 bg-blue-600 text-white border-none rounded-full cursor-pointer pointer-events-auto flex items-center justify-center text-xs z-20 hover:bg-blue-700"
                                                    @onclick="() => StartTextEdit(element)" @onclick:stopPropagation title="テキスト編集">
                                                    <i class="fa-solid fa-pen"></i>
                                                </button>
                                            }
                                        }
                                        <button class="delete-btn absolute top-[-12px] right-[-12px] w-5 h-5 bg-red-500 text-white border-none rounded-full cursor-pointer pointer-events-auto flex items-center justify-center text-xs hover:bg-red-600"
                                            @onclick="() => DeleteElement(element.Id)" @onclick:stopPropagation title="削除">
                                            <i class="fa-solid fa-times"></i>
                                        </button>
                                    </div>
                                }
                            </div>
                        }
                        else if (element.Type == ElementType.Image)
                        {
                             <div class="edit-element image-element absolute select-none cursor-move
                                @(selectedElementIds.Contains(element.Id) ? "border-2 border-blue-600" : "border-2 border-transparent")"
                                style="left: @(element.X * zoomLevel)px; top: @(element.Y * zoomLevel)px; width: @(element.Width * zoomLevel)px; height: @(element.Height * zoomLevel)px;"
                                @onmousedown="(e) => OnImageMouseDown(e, element)"
                                @onmouseup="OnImageMouseUp"
                                @onmousemove="OnImageMouseMove"
                                @onclick="() => { if (currentTool == EditTool.Image) SelectElement(element.Id); }"
                                @onclick:stopPropagation
                            >
                                <img src="@element.ImageUrl" class="w-full h-full object-contain pointer-events-none" style="object-fit:@(keepAspectRatio ? "contain" : "fill");" />
                                @if (selectedElementIds.Contains(element.Id) && currentTool == EditTool.Image)
                                {
                                    <div class="element-handles absolute inset-0 pointer-events-none">
                                        @foreach (var handle in new[] { "nw", "n", "ne", "e", "se", "s", "sw", "w" })
                                        {
                                            <div class="handle handle-@handle absolute bg-blue-600 border border-white w-2 h-2 pointer-events-auto"
                                                style="@GetHandleStyle(handle, element)"
                                                @onmousedown="(e) => OnImageResizeMouseDown(e, element, handle)"
                                                @onmousedown:stopPropagation />
                                        }
                                    </div>
                                }
                                @if (selectedElementIds.Contains(element.Id))
                                {
                                    <button class="delete-btn absolute top-[-20px] right-[-20px] w-5 h-5 bg-red-500 text-white border-none rounded-full cursor-pointer pointer-events-auto flex items-center justify-center text-xs hover:bg-red-600"
                                            @onclick="() => DeleteElement(element.Id)" @onclick:stopPropagation title="削除">
                                        <i class="fa-solid fa-times"></i>
                                    </button>
                                }
                            </div>
                        }
                    }
                </div>
            </div>
        
    </div>

    <!-- ファイルアップロード用の隠しinput -->
   <input type="file" @ref="fileInputRef" @onchange="OnImageSelected" accept="image/*" style="display: none;" />
</div>


@code {
    private DotNetObjectReference<EditPage>? _dotNetRef;

    [Parameter] public string FileId { get; set; } = "";
    [Parameter] public int PageIndex { get; set; }
    // 例: FileIdをピリオドなしに変換(cssセレクタでピリオドがクラス名として解釈されるため)
    private string GetSafeId(string fileId) =>
    fileId.Replace(".", "_").Replace("/", "_").Replace("\\", "_");

    private string safeFileId = "";
    protected override void OnParametersSet()
    {
        safeFileId = GetSafeId(FileId);
    }
    private string fileName = "";
    private int pageWidth = 595;
    private int pageHeight = 842;
    private double zoomLevel = 1.0;
    private double offsetX = 0;
    private double offsetY = 0;

    private string? draggingElementId = null;
    private double dragStartMouseX = 0;
    private double dragStartMouseY = 0;
    private double dragStartElementX = 0;
    private double dragStartElementY = 0;

    private string? draggingImageId = null;
    private string? resizingImageId = null;
    private string? resizingHandle = null;
    private double dragStartImageX, dragStartImageY;
    private double dragStartImageWidth, dragStartImageHeight;

    private EditTool currentTool = EditTool.Select;
    private bool isDragging = false;
    private double lastMouseX = 0;
    private double lastMouseY = 0;

    private bool ignoreNextPageClick = false;
    private bool ignoreTextBlur = false;

    // 選択された要素のIDリスト
    private List<string> selectedElementIds = new();

    private string fontFamily = "sans-serif";

    private void OnFontFamilyChanged(ChangeEventArgs e)
    {
        var value = e.Value?.ToString() ?? "sans-serif";
        var editingElement = editElements.FirstOrDefault(el => el.IsEditing);
        if (editingElement != null)
        {
            editingElement.FontFamily = value;
        }
        else if (selectedElementIds.Count > 0)
        {
            foreach (var el in editElements.Where(el => selectedElementIds.Contains(el.Id)))
                el.FontFamily = value;
        }
        else
        {
            fontFamily = value;
        }
        StateHasChanged();
    }
    private List<EditElement> editElements = new();

    private ElementReference textInputRef;
    private ElementReference fileInputRef;

    private enum EditTool { Select, Text, Image }
    private enum ElementType { Text, Image }

    private class EditElement
    {
        public string Id { get; set; } = Guid.NewGuid().ToString();
        public ElementType Type { get; set; }
        public double X { get; set; }
        public double Y { get; set; }
        public double Width { get; set; } = 100;
        public double Height { get; set; } = 20;
        public string Text { get; set; } = "";
        public int FontSize { get; set; } = 16;
        public string Color { get; set; } = "#000000";
        public string ImageUrl { get; set; } = "";
        public bool IsEditing { get; set; } = false;
        public string FontFamily { get; set; } = "sans-serif"; 
    public double ImageOriginalWidth { get; set; }
    public double ImageOriginalHeight { get; set; }
    }

    private string _textColor = "#000000";
    private string textColor
    {
        get => _textColor;
        set
        {
            _textColor = value;

            // 編集中の要素があればそれだけ
            var editingElement = editElements.FirstOrDefault(el => el.IsEditing);
            if (editingElement != null)
            {
                editingElement.Color = value;
            }
            // 選択中なら全て
            else if (selectedElementIds.Count > 0)
            {
                foreach (var el in editElements.Where(el => selectedElementIds.Contains(el.Id)))
                    el.Color = value;
            }
            StateHasChanged();
        }
    }

    private void OnColorPickerBlur(FocusEventArgs e)
    {
        ignoreNextPageClick = true;
    }

    private void OnTextColorInput(ChangeEventArgs e)
    {
        var value = e.Value?.ToString() ?? "#000000";
        textColor = value; // setterで編集中・選択中要素にも反映される
    }

    private string CurrentTextColor
    {
        get
        {
            var editingElement = editElements.FirstOrDefault(el => el.IsEditing);
            if (editingElement != null)
                return editingElement.Color;
            else if (selectedElementIds.Count > 0)
            {
                var selected = editElements.FirstOrDefault(el => selectedElementIds.Contains(el.Id));
                if (selected != null)
                    return selected.Color;
            }
            return textColor;
        }
        set
        {
            textColor = value;
        }
    }

    private int _fontSize = 16;
    private int fontSize
    {
        get => _fontSize;
        set
        {
            _fontSize = value;
            var editingElement = editElements.FirstOrDefault(el => el.IsEditing);
            if (editingElement != null)
            {
                editingElement.FontSize = value;
            }
        }
    }

    private string GetHandleStyle(string handle, EditElement element)
    {
        var w = element.Width * zoomLevel;
        var h = element.Height * zoomLevel;
        var positions = new Dictionary<string, string>
        {
            ["nw"] = "top:-4px;left:-4px;cursor:nw-resize;",
            ["n"]  = $"top:-4px;left:{w/2-4}px;cursor:n-resize;",
            ["ne"] = $"top:-4px;right:-4px;cursor:ne-resize;",
            ["e"]  = $"top:{h/2-4}px;right:-4px;cursor:e-resize;",
            ["se"] = $"bottom:-4px;right:-4px;cursor:se-resize;",
            ["s"]  = $"bottom:-4px;left:{w/2-4}px;cursor:s-resize;",
            ["sw"] = $"bottom:-4px;left:-4px;cursor:sw-resize;",
            ["w"]  = $"top:{h/2-4}px;left:-4px;cursor:w-resize;"
        };
        return positions[handle] + "position:absolute;width:8px;height:8px;z-index:10;";
    }

    private void OnElementMouseDown(MouseEventArgs e, EditElement element)
    {
        if (element.Type != ElementType.Text || !selectedElementIds.Contains(element.Id)) return;
        draggingElementId = element.Id;
        dragStartMouseX = e.ClientX;
        dragStartMouseY = e.ClientY;
        dragStartElementX = element.X;
        dragStartElementY = element.Y;
    }

    private void OnElementMouseMove(MouseEventArgs e)
    {
        if (draggingElementId == null) return;
        var element = editElements.FirstOrDefault(el => el.Id == draggingElementId);
        if (element == null) return;

        // マウスの移動量をズーム倍率で補正
        var dx = (e.ClientX - dragStartMouseX) / zoomLevel;
        var dy = (e.ClientY - dragStartMouseY) / zoomLevel;
        element.X = dragStartElementX + dx;
        element.Y = dragStartElementY + dy;
        StateHasChanged();
    }

    private void OnElementMouseUp(MouseEventArgs e)
    {
        draggingElementId = null;
    }

    private void OnFontSizeChanged(ChangeEventArgs e)
    {
        int value;
        if (!int.TryParse(e.Value?.ToString(), out value))
        {
            value = 16; // デフォルト値
        }
        // 編集中の要素があればそれだけ
        var editingElement = editElements.FirstOrDefault(el => el.IsEditing);
        if (editingElement != null)
        {
            editingElement.FontSize = value;
        }
        // 選択中なら全て
        else if (selectedElementIds.Count > 0)
        {
            foreach (var el in editElements.Where(el => selectedElementIds.Contains(el.Id)))
                el.FontSize = value;
        }
        else
        {
            fontSize = value;
        }
        StateHasChanged();
    }

    private void StartTextEdit(EditElement element)
    {
        foreach (var el in editElements)
            el.IsEditing = false;

        element.IsEditing = true;
        selectedElementIds.Clear();
        selectedElementIds.Add(element.Id);
        StateHasChanged();
    }

    private bool keepAspectRatio = true;

    private void OnImageMouseDown(MouseEventArgs e, EditElement element)
    {
        if (currentTool != EditTool.Image || !selectedElementIds.Contains(element.Id)) return;
        draggingImageId = element.Id;
        dragStartMouseX = e.ClientX;
        dragStartMouseY = e.ClientY;
        dragStartImageX = element.X;
        dragStartImageY = element.Y;
    }
    
    private void OnImageMouseMove(MouseEventArgs e)
    {
        if (draggingImageId != null)
        {
            var element = editElements.FirstOrDefault(el => el.Id == draggingImageId);
            if (element == null) return;
            var dx = (e.ClientX - dragStartMouseX) / zoomLevel;
            var dy = (e.ClientY - dragStartMouseY) / zoomLevel;
            element.X = dragStartImageX + dx;
            element.Y = dragStartImageY + dy;
            StateHasChanged();
        }
        else if (resizingImageId != null && resizingHandle != null)
        {
            var element = editElements.FirstOrDefault(el => el.Id == resizingImageId);
            if (element == null) return;
            var dx = (e.ClientX - dragStartMouseX) / zoomLevel;
            var dy = (e.ClientY - dragStartMouseY) / zoomLevel;
            ResizeImageElement(element, resizingHandle, dx, dy);
            StateHasChanged();
        }
    }
    
    private void OnImageMouseUp(MouseEventArgs e)
    {
        draggingImageId = null;
        resizingImageId = null;
        resizingHandle = null;
    }
    
    private void OnImageResizeMouseDown(MouseEventArgs e, EditElement element, string handle)
    {
        resizingImageId = element.Id;
        resizingHandle = handle;
        dragStartMouseX = e.ClientX;
        dragStartMouseY = e.ClientY;
        dragStartImageX = element.X;
        dragStartImageY = element.Y;
        dragStartImageWidth = element.Width;
        dragStartImageHeight = element.Height;
    }

    private void ResizeImageElement(EditElement element, string handle, double dx, double dy)
    {
        double minSize = 20;
        double aspect = element.ImageOriginalWidth > 0 && element.ImageOriginalHeight > 0
            ? element.ImageOriginalWidth / element.ImageOriginalHeight
            : 1.0;
    
        double newX = dragStartImageX;
        double newY = dragStartImageY;
        double newWidth = dragStartImageWidth;
        double newHeight = dragStartImageHeight;
    
        if (keepAspectRatio)
        {
            switch (handle)
            {
                case "nw":
                    // 左上：XとYを増やし、幅・高さを減らす
                    {
                        double delta = Math.Min(dx, dy);
                        newWidth = Math.Max(dragStartImageWidth - delta, minSize);
                        newHeight = Math.Max(newWidth / aspect, minSize);
                        newX = dragStartImageX + (dragStartImageWidth - newWidth);
                        newY = dragStartImageY + (dragStartImageHeight - newHeight);
                    }
                    break;
                case "ne":
                    // 右上：Yを増やし、幅・高さを増やす
                    {
                        double delta = Math.Min(-dx, dy);
                        newWidth = Math.Max(dragStartImageWidth + dx, minSize);
                        newHeight = Math.Max(newWidth / aspect, minSize);
                        newY = dragStartImageY + (dragStartImageHeight - newHeight);
                    }
                    break;
                case "se":
                    // 右下：幅・高さを増やす
                    {
                        double delta = Math.Max(dx, dy);
                        newWidth = Math.Max(dragStartImageWidth + dx, minSize);
                        newHeight = Math.Max(newWidth / aspect, minSize);
                    }
                    break;
                case "sw":
                    // 左下：Xを増やし、幅・高さを増やす
                    {
                        double delta = Math.Min(dx, -dy);
                        newWidth = Math.Max(dragStartImageWidth - dx, minSize);
                        newHeight = Math.Max(newWidth / aspect, minSize);
                        newX = dragStartImageX + (dragStartImageWidth - newWidth);
                    }
                    break;
                case "n":
                    // 上：Yを増やし、高さを減らす、幅も連動
                    {
                        newHeight = Math.Max(dragStartImageHeight - dy, minSize);
                        newWidth = Math.Max(newHeight * aspect, minSize);
                        newY = dragStartImageY + (dragStartImageHeight - newHeight);
                    }
                    break;
                case "s":
                    // 下：高さを増やす、幅も連動
                    {
                        newHeight = Math.Max(dragStartImageHeight + dy, minSize);
                        newWidth = Math.Max(newHeight * aspect, minSize);
                    }
                    break;
                case "e":
                    // 右：幅を増やす、高さも連動
                    {
                        newWidth = Math.Max(dragStartImageWidth + dx, minSize);
                        newHeight = Math.Max(newWidth / aspect, minSize);
                    }
                    break;
                case "w":
                    // 左：Xを増やし、幅を減らす、高さも連動
                    {
                        newWidth = Math.Max(dragStartImageWidth - dx, minSize);
                        newHeight = Math.Max(newWidth / aspect, minSize);
                        newX = dragStartImageX + (dragStartImageWidth - newWidth);
                    }
                    break;
            }
        }
        else
        {
            // アスペクト比無視
            switch (handle)
            {
                case "nw":
                    newX = dragStartImageX + dx;
                    newY = dragStartImageY + dy;
                    newWidth = Math.Max(dragStartImageWidth - dx, minSize);
                    newHeight = Math.Max(dragStartImageHeight - dy, minSize);
                    break;
                case "n":
                    newY = dragStartImageY + dy;
                    newHeight = Math.Max(dragStartImageHeight - dy, minSize);
                    break;
                case "ne":
                    newY = dragStartImageY + dy;
                    newWidth = Math.Max(dragStartImageWidth + dx, minSize);
                    newHeight = Math.Max(dragStartImageHeight - dy, minSize);
                    break;
                case "e":
                    newWidth = Math.Max(dragStartImageWidth + dx, minSize);
                    break;
                case "se":
                    newWidth = Math.Max(dragStartImageWidth + dx, minSize);
                    newHeight = Math.Max(dragStartImageHeight + dy, minSize);
                    break;
                case "s":
                    newHeight = Math.Max(dragStartImageHeight + dy, minSize);
                    break;
                case "sw":
                    newX = dragStartImageX + dx;
                    newWidth = Math.Max(dragStartImageWidth - dx, minSize);
                    newHeight = Math.Max(dragStartImageHeight + dy, minSize);
                    break;
                case "w":
                    newX = dragStartImageX + dx;
                    newWidth = Math.Max(dragStartImageWidth - dx, minSize);
                    break;
            }
        }
    
        element.X = newX;
        element.Y = newY;
        element.Width = newWidth;
        element.Height = newHeight;
    }

    [JSInvokable]
    public void OnGlobalMouseUp()
    {
        draggingElementId = null;
        draggingImageId = null;
        resizingImageId = null;
        resizingHandle = null;
        isDragging = false;
        StateHasChanged();
    }

    [JSInvokable]
    public void OnImageBase64Loaded(string base64, double width, double height)
    {
        // 最大サイズをページサイズの50%に制限
        double maxWidth = pageWidth * 0.5;
        double maxHeight = pageHeight * 0.5;

        double scale = Math.Min(maxWidth / width, maxHeight / height);
        // scaleが1以上なら縮小不要
        if (scale > 1) scale = 1;

        double displayWidth = width * scale;
        double displayHeight = height * scale;

        var element = new EditElement
        {
            Type = ElementType.Image,
            X = 100,
            Y = 100,
            Width = displayWidth,
            Height = displayHeight,
            ImageOriginalWidth = width,
            ImageOriginalHeight = height,
            ImageUrl = base64
        };
        editElements.Add(element);
        StateHasChanged();
    }
    
    private async Task OnImageSelected(ChangeEventArgs e)
    {
        // input要素のElementReferenceを渡す
        await JS.InvokeVoidAsync("readImageAsBase64", fileInputRef, DotNetObjectReference.Create(this));
        // 同じファイルを連続で選択してもonchangeが発火しない仕様なのでクリアしておく
        await JS.InvokeVoidAsync("clearFileInput", fileInputRef);
    }
    
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _dotNetRef = DotNetObjectReference.Create(this);
            await JS.InvokeVoidAsync("registerGlobalMouseUp", _dotNetRef);

            var allPages = PdfDataService.GetModel().Pages;
            var pageItem = allPages.FirstOrDefault(p => p.FileId == FileId && p.OriginalPageIndex == PageIndex);

            if (pageItem == null)
            {
                Navigation.NavigateTo("/edit");
                return;
            }

            fileName = pageItem?.FileName ?? "";
            await JS.InvokeVoidAsync("setupEditPage", safeFileId, PageIndex, pageItem?.PageData ?? "");
        }
    }

    public async ValueTask DisposeAsync()
    {
        await JS.InvokeVoidAsync("unregisterGlobalMouseUp");
        _dotNetRef?.Dispose();
    }

    private void NavigateBack()
    {
        //JavaScript interop で history.back() を使うのも検討
        Navigation.NavigateTo("/edit");
    }

    private async void ZoomIn()
    {
        zoomLevel = Math.Min(zoomLevel * 1.2, 5.0);
        await RedrawPdfPage();
    }

    private async void ZoomOut()
    {
        zoomLevel = Math.Max(zoomLevel / 1.2, 0.1);
        await RedrawPdfPage();
    }

    private async void FitToScreen()
    {
        zoomLevel = 1.0;
        offsetX = 0;
        offsetY = 0;
        await RedrawPdfPage();
    }

    // PDF再描画用メソッドを追加
    private async Task RedrawPdfPage()
    {
        var allPages = PdfDataService.GetModel().Pages;
        var pageItem = allPages.FirstOrDefault(p => p.FileId == FileId && p.OriginalPageIndex == PageIndex);
        await JS.InvokeVoidAsync("setupEditPage", safeFileId, PageIndex, pageItem?.PageData ?? "", zoomLevel);
    }

    private void SetTool(EditTool tool)
    {
        currentTool = tool;
        selectedElementIds.Clear();
    }

    private void OnCanvasMouseDown(MouseEventArgs e)
    {
        // テキストエリアのドラッグ中はページ移動を開始しない
        if (draggingElementId != null) return;

        if (currentTool == EditTool.Select)
        {
            isDragging = true;
            lastMouseX = e.ClientX;
            lastMouseY = e.ClientY;
        }
    }

    private void OnCanvasMouseMove(MouseEventArgs e)
    {
        if (draggingElementId != null) return;

        if (isDragging && currentTool == EditTool.Select)
        {
            var deltaX = e.ClientX - lastMouseX;
            var deltaY = e.ClientY - lastMouseY;
            offsetX += deltaX;
            offsetY += deltaY;
            lastMouseX = e.ClientX;
            lastMouseY = e.ClientY;
        }
    }

    private void OnCanvasMouseUp(MouseEventArgs e)
    {
        isDragging = false;
        draggingElementId = null;
    }

    private void OnCanvasWheel(WheelEventArgs e)
    {
        if (e.DeltaY < 0)
            ZoomIn();
        else
            ZoomOut();
    }

    // C#で座標を受け取るクラス
    private class CanvasCoords
    {
        public double x { get; set; }
        public double y { get; set; }
    }
    private async Task OnPageClick(MouseEventArgs e)
    {
        // カラーピッカーが開いている場合は何もしない
        if (ignoreNextPageClick)
        {
            ignoreNextPageClick = false;
            return;
        }
        
        // JSでクリックターゲットのタグ名を取得
        var tagName = await JS.InvokeAsync<string>("getTagNameFromEvent", e);
        if (tagName == "INPUT" || tagName == "BUTTON") return;

        // すでにテキスト編集中の要素があれば追加しない
        var editingElement = editElements.FirstOrDefault(el => el.IsEditing);
        if (editingElement != null)
        {
            // ここで全てのIsEditingをfalseにしておく
            foreach (var el in editElements)
                el.IsEditing = false;
            StateHasChanged();
            return;
        }

        // 選択中が1つ以上なら、選択解除だけして終了
        if (selectedElementIds.Count > 0)
        {
            selectedElementIds.Clear();
            StateHasChanged();
            return;
        }

        if (currentTool == EditTool.Text)
        {
            // JSで正確なキャンバス座標を取得
            var coords = await JS.InvokeAsync<CanvasCoords>(
            "getCanvasCoords",
            $"#pdf-canvas-{safeFileId}-{PageIndex}",
            e.ClientX,
            e.ClientY,
            offsetX,
            offsetY,
            zoomLevel
            );

            var element = new EditElement
            {
                Type = ElementType.Text,
                X = coords.x,
                Y = coords.y,
                Text = "テキスト",
                FontSize = fontSize,
                Color = textColor,
                IsEditing = true,
                FontFamily = fontFamily 
            };
            editElements.Add(element);
        }
        else
        {
            selectedElementIds.Clear();
        }
    }

private async Task TriggerImageInput()
{
    await fileInputRef.FocusAsync();
    await JS.InvokeVoidAsync("triggerFileInput", fileInputRef);
}

    // 選択された要素のIDを格納
    private void SelectElement(string elementId, bool multi = false)
    {
        // すべての編集中状態を解除
        foreach (var el in editElements)
            el.IsEditing = false;

        if (multi)
        {
            if (!selectedElementIds.Contains(elementId))
                selectedElementIds.Add(elementId);
        }
        else
        {
            selectedElementIds.Clear();
            selectedElementIds.Add(elementId);
        }

        var selected = editElements.FirstOrDefault(el => el.Id == elementId);
        if (selected != null)
            fontFamily = selected.FontFamily;

        StateHasChanged();
    }

    private void FinishTextEdit(EditElement element)
    {
        if (ignoreTextBlur)
        {
            ignoreTextBlur = false;
            // ツールバー操作時は編集中を維持
            return;
        }
        element.IsEditing = false;
        fontFamily = element.FontFamily;
    }

    private async Task OnTextKeyPress(KeyboardEventArgs e, EditElement element)
    {
        if (e.Key == "Enter")
        {
            element.IsEditing = false;
            await textInputRef.FocusAsync();
        }
    }

    private void DeleteElement(string elementId)
    {
        editElements.RemoveAll(e => e.Id == elementId);
        selectedElementIds.Remove(elementId);

        // 画像削除後にもinputをクリア
        _ = JS.InvokeVoidAsync("clearFileInput", fileInputRef);
    }

    private async Task SaveChanges()
    {
        // 現在のページを取得
        var allPages = PdfDataService.GetModel().Pages;
        var pageItem = allPages.FirstOrDefault(p => p.FileId == FileId && p.OriginalPageIndex == PageIndex);

        if (pageItem != null)
        {
            // 編集要素を保存（必要に応じてシリアライズ）
            //pageItem.PageData = JsonSerializer.Serialize(editElements);
            var newThumbnail = await JS.InvokeAsync<string>("generateThumbnail", safeFileId, PageIndex);
            pageItem.Thumbnail = newThumbnail;

            

            // 必要ならPdfDataService.Save()などで永続化
            // await PdfDataService.SaveAsync();

            await JS.InvokeVoidAsync("alert", "変更を保存しました");
        }
        else
        {
            await JS.InvokeVoidAsync("alert", "ページ情報が見つかりません");
        }
    }
}
