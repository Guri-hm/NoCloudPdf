@page "/merge"
@implements IDisposable
@inject IJSRuntime JSRuntime
@inject PdfDataService PdfDataService
@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.AspNetCore.Components.Web
@using Microsoft.JSInterop
@using System.IO
@using ClientPdfApp.Models
@using ClientPdfApp.Services
@using ClientPdfApp.Components

<PageTitle>結合</PageTitle>

@if (IsFilesLoaded && !showMergedResult)
{
    <div id="drop-area" class="relative min-h-screen">
        <div class="drop-cover pointer-events-none absolute inset-0 m-4 flex items-center justify-center z-[100] transition-all duration-200 @(isDragOver ? "opacity-100" : "opacity-0")">
            <div class="w-full h-full bg-gray-700/70 rounded-xl border-2 border-dashed border-blue-300 flex items-center justify-center transition-all duration-200
                @(isDragOver ? "scale-100" : "scale-70")">
                <span class="text-white text-2xl font-bold">ここにファイルをドロップ</span>
            </div>
        </div>
        <!-- 上部固定バー（編集モード） -->
        <div class="sticky top-0 left-0 w-full max-w-full bg-gray-800 text-white shadow z-50">
            <div class="flex items-center justify-between px-4 py-2 overflow-x-auto scrollbar-thin scrollbar-thumb-gray-400 scrollbar-track-gray-200">
                <div class="flex gap-2 items-center">
                    <!-- 表示切替ボタングループ -->
                    <div class="inline-flex shadow overflow-hidden border border-gray-500 rounded-lg bg-gray-700 h-10">
                        <button
                            class="px-4 py-1 font-bold focus:outline-none transition
                                @(IsFileMode ? "bg-blue-300 text-gray-800 hover:bg-blue-400" : "bg-gray-700 text-gray-200 hover:bg-gray-600")
                                rounded-s-lg border-e border-gray-500 h-full flex items-center gap-2"
                            @onclick="SwitchToFileMode">
                            <svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 24 24"
                                class="w-5 h-5 mr-1">
                                <path fill-rule="evenodd"
                                    d="M2 2.002h14v2h2l4 4v14H8v-2H2zm1 17h5v-2H5v-1h3v-2H5v-1h3v-2H5v-1h3v-6h7v-1H3zm6 0v2h12v-12h-4v-4H9zm9-11V5.417l2.586 2.585zm-7 4h8v1h-8zm8 3h-8v1h8zm-2 3h-6v1h6z">
                                </path>
                            </svg>
                            <span class="ml-2 hidden xl:inline whitespace-nowrap">ファイル</span>
                        </button>
                        <button
                            class="px-4 py-1 font-bold focus:outline-none transition
                                @(IsPageMode ? "bg-blue-300 text-gray-800 hover:bg-blue-400" : "bg-gray-700 text-gray-200 hover:bg-gray-600")
                                rounded-e-lg h-full flex items-center gap-2"
                            @onclick="SwitchToPageMode">
                            <svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 24 24"
                                class="w-5 h-5 mr-1">
                                <path fill-rule="evenodd"
                                    d="M5 3h5v7H5zm-1 8V2h7v9zm10-8h5v7h-5zm-1 8V2h7v9zm-3 3H5v7h5zm-6-1v9h7v-9zm10 1h5v7h-5zm-1 8v-9h7v9z"
                                    clip-rule="evenodd"></path>
                            </svg>
                            <span class="ml-2 hidden xl:inline whitespace-nowrap">ページ</span>
                        </button>
                    </div>
                    <!-- 回転ボタングループ -->
                    <div class="inline-flex shadow overflow-hidden border border-gray-500 rounded-lg bg-gray-700 h-10">
                        <button
                            class="px-4 py-1 font-bold focus:outline-none transition text-white border-e border-gray-500 h-full hover:bg-gray-600"
                            @onclick="RotateAllLeft" title="左回転">
                            <i class="fa-solid fa-rotate-left"></i>
                            <span class="ml-2 hidden xl:inline">左</span>
                        </button>
                        <button class="px-4 py-1 font-bold focus:outline-none transition text-white h-full hover:bg-gray-600"
                            @onclick="RotateAllRight" title="右回転">
                            <i class="fa-solid fa-rotate-right"></i>
                            <span class="ml-2 hidden xl:inline">右</span>
                        </button>
                    </div>
                    <!-- 追加ボタングループ -->
                    <div class="inline-flex shadow border border-gray-500 rounded-lg bg-gray-700 h-10 ml-2 relative">
                        <button
                            class="px-4 py-1 font-bold focus:outline-none transition text-white h-full bg-gray-700 hover:bg-gray-600 rounded-lg flex items-center"
                            @onclick="ToggleAddMenu" title="追加">
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor" class="mr-2">
                                <path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z" />
                            </svg>
                            <span class="hidden xl:inline">追加</span>
                            <svg width="16" height="16" viewBox="0 0 20 20" fill="currentColor" class="ml-2">
                                <polygon points="5,8 10,13 15,8" />
                            </svg>
                        </button>
                        @if (showAddMenu)
                        {
                            <div id="addMenu"
                                class="absolute top-full left-0 mt-1 min-w-[120px] bg-white rounded-lg shadow-lg z-50 border border-gray-300">
                                <button
                                    class="w-full text-left px-4 py-2 hover:bg-blue-50 text-gray-800 rounded-t-lg whitespace-nowrap"
                                    @onclick="() => InsertBlankPage(DisplayItems.Count)">空白ページを追加</button>
                                <button
                                    class="w-full text-left px-4 py-2 hover:bg-blue-50 text-gray-800 rounded-b-lg whitespace-nowrap"
                                    @onclick="AddPdfFile">ドキュメントを追加</button>
                            </div>
                        }
                    </div>
                    <div class="inline-flex shadow overflow-hidden border border-gray-500 rounded-lg bg-gray-700 h-10 ml-2">
                        <button
                            class="px-4 py-1 font-bold focus:outline-none transition text-white h-full bg-gray-700 hover:bg-gray-600 flex items-center"
                            @onclick="ReverseOrder" title="逆順">
                            <svg width="20" height="20" viewBox="0 0 21 21" fill="none" class="mr-2"
                                style="display:inline-block;vertical-align:middle;">
                                <g stroke="currentColor" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M4.5 8.5l-4 4 4 4" />
                                    <path d="M12.5 12.5h-12" />
                                    <path d="M8.5.5l4 4-4 4" />
                                    <path d="M12.5 4.5h-12" />
                                </g>
                            </svg>
                            <span class="hidden xl:inline">逆順</span>
                        </button>
                    </div>
                    <div class="inline-flex shadow border border-gray-500 rounded-lg bg-gray-700 h-10 ml-2 relative">
                        <button
                            class="px-4 py-1 font-bold focus:outline-none transition text-white h-full bg-gray-700 hover:bg-gray-600 rounded-lg flex items-center"
                            @onclick="ToggleSortMenu" title="並び替え">
                            <i class="fa-solid fa-arrow-down-a-z"></i>
                            <svg width="14" height="14" viewBox="0 0 20 20" fill="currentColor" class="ml-2"></svg>
                            <span class="hidden xl:inline">並び替え</span>
                        </button>
                        @if (showSortMenu)
                        {
                            <div id="sortMenu"
                                class="absolute top-full left-0 mt-1 min-w-[120px] bg-white rounded-lg shadow-lg z-50 border border-gray-300">
                                <button
                                    class="w-full text-left px-4 py-2 hover:bg-blue-50 text-gray-800 rounded-t-lg whitespace-nowrap"
                                    @onclick="() => SelectSort(true)">名前（昇順）</button>
                                <button
                                    class="w-full text-left px-4 py-2 hover:bg-blue-50 text-gray-800 rounded-b-lg whitespace-nowrap"
                                    @onclick="() => SelectSort(false)">名前（降順）</button>
                            </div>
                        }
                    </div>
                </div>
                <div class="flex-1 flex justify-end min-w-[120px]">
                    <button
                        class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-8 rounded-lg flex items-center gap-3 min-w-[44px] transition hidden md:flex"
                        @onclick="MergePDFs" style="height: 44px;">
                        <span class="flex-1 text-center hidden xl:inline">結合</span>
                        <i class="fa-solid fa-arrow-right text-xl ml-2"></i>
                    </button>
                </div>
            </div>
        </div>

        <!-- サムネイル編集エリア -->
        <div class="md:p-0 p-3">
            @if (DisplayItems != null && DisplayItems.Any())
            {
                <div class="flex flex-col gap-1 p-2 md:flex-row md:flex-wrap md:gap-4 md:p-6" id="sortable-container">
                    @for (int i = 0; i < DisplayItems.Count; i++)
                    {
                        <ThumbnailCard Item="DisplayItems[i]"
                                    Index="i"
                                    DisplayItemsCount="DisplayItems.Count"
                                    IsFileMode="IsFileMode"
                                    IsPageMode="IsPageMode"
                                    OnShowPreview="args => ShowPreviewAsync(args.fileIndex, args.pageIndex)"
                                    OnInsertButtonClick="args => HandleInsertButtonClick(args.position, args.e)"
                                    OnSwapWithNext="SwapWithNext"
                                    OnReloadPageItem="ReloadPageItem" />
                    }

                    <!-- 追加エリアは別divとして配置 -->
                    <div class="hidden md:flex items-center relative insert-button-container non-sortable"
                        data-position="@DisplayItems.Count">
                        <button
                            class="w-6 h-6 bg-blue-500/60 hover:bg-blue-600 hover:bg-opacity-100 text-white rounded-full flex items-center justify-center insert-button transition-all duration-200"
                            data-position="@DisplayItems.Count" @onclick="@((e) => HandleInsertButtonClick(DisplayItems.Count, e))">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor" class="w-3 h-3">
                                <path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z" />
                            </svg>
                        </button>
                    </div>
                    <div class="w-full md:w-24 h-full flex items-center justify-center border-2 border-dashed border-blue-400 rounded-lg cursor-pointer hover:bg-blue-50 transition non-sortable"
                        @onclick="OpenFileDialog">
                        <div class="flex flex-col items-center justify-center text-blue-500 p-4">
                            <i class="fa-thin fa-plus text-3xl mb-2"></i>
                            <span class="text-sm font-semibold">PDF，画像ファイルを追加</span>
                        </div>
                    </div>
                </div>
            }
            else
            {
                <!-- 初期状態：ファイル選択を促すメッセージ -->
                <div class="w-full text-center py-20">
                    <p class="text-neutral-500 text-lg mb-4">PDFファイルを選択してください</p>
                    <button class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg"
                        @onclick="OpenFileDialog">
                        ファイルを選択
                    </button>
                </div>
            }
        </div>
    </div>
}
@if (previewIndex >= 0)
{
    <div class="fixed inset-0 flex items-center justify-center z-50 bg-black/70" @onclick="ClosePreview">
        <button
            class="absolute top-8 right-8 w-12 h-12 flex items-center justify-center bg-white rounded-full shadow z-10 hover:bg-neutral-200 text-black text-3xl"
            @onclick="ClosePreview" title="閉じる">
            &times;
        </button>
        @if (isPreviewLoading)
        {
            <div class="flex flex-col items-center justify-center">
                <div class="animate-spin rounded-full h-16 w-16 border-b-2 border-blue-600 mb-4"></div>
                <span class="text-white">プレビュー画像を生成中...</span>
            </div>
        }
        else if (!string.IsNullOrEmpty(previewImageUrl))
        {
            <img src="@previewImageUrl" class="max-w-[90vw] max-h-[90vh] object-contain mx-auto"
                style="width:auto; height:auto;" draggable="false" @onclick:stopPropagation />
        }
        <!-- プレビュー下部の操作バー -->
        <div class="absolute bottom-8 left-1/2 -translate-x-1/2 flex bg-black/60 px-0 rounded-lg min-h-12 shadow-lg"
            @onclick:stopPropagation>
            <div class="flex w-full items-stretch divide-x divide-gray-400 rounded-lg">
                <button
                    class="icon-btn flex-1 flex items-center justify-center py-4 px-4 hover:bg-gray-700 transition rounded-l-lg"
                    @onclick="() => MovePreview(-1)"
                    disabled="@(IsFileMode? CurrentFilePageIndex == 0 : previewIndex == 0)">
                    <i class="text-white fa-solid fa-chevron-left"></i>
                </button>
                <div class="flex-1 px-2 flex items-center justify-center text-white font-bold whitespace-nowrap">
                    @if (IsFileMode && CurrentFilePageCount > 1)
                    {
                        <input type="number" min="1" max="@CurrentFilePageCount" value="@(CurrentFilePageIndex + 1)"
                            class="w-12 h-full text-center rounded bg-gray-800 text-white border border-gray-400 mx-1"
                            style="appearance: none; -moz-appearance: textfield;" @onchange="OnPreviewPageInputChanged" />
                        <span>/ @CurrentFilePageCount</span>
                    }
                </div>
                <button class="icon-btn flex-1 flex items-center justify-center py-4 px-4 hover:bg-gray-700 transition"
                    @onclick="() => MovePreview(1)"
                    disabled="@(IsFileMode? CurrentFilePageIndex == CurrentFilePageCount - 1 : (DisplayItems != null && DisplayItems.Any() ? previewIndex == DisplayItems.Count - 1 : true))">
                    <i class="text-white fa-solid fa-chevron-right"></i>
                </button>
                <button class="icon-btn flex-1 flex items-center justify-center py-4 px-4 hover:bg-gray-700 transition"
                    @onclick="RotatePreviewLeft">
                    <i class="text-white fa-solid fa-rotate-left"></i>
                </button>
                <button class="icon-btn flex-1 flex items-center justify-center py-4 px-4 hover:bg-gray-700 transition"
                    @onclick="RotatePreviewRight">
                    <i class="text-white fa-solid fa-rotate-right"></i>
                </button>
                <button
                    class="icon-btn flex-1 flex items-center justify-center py-4 px-4 hover:bg-gray-700 transition rounded-r-lg"
                    @onclick="RemoveItemFromPreview">
                    <i class="text-white fa-solid fa-trash"></i>
                </button>
            </div>
        </div>
    </div>
}
@if (!IsFilesLoaded && !showMergedResult)
{
    <!-- 初期画面：ファイル選択 -->
    <SelectFilePanel OnOpenFileDialog="OpenFileDialog" isLoading="isLoading" progress="progress" />
}

@if (showMergedResult && !string.IsNullOrEmpty(mergedPdfUrl))
{
    <!-- PC: 横並び, タブレット以下: 縦並び -->
    <div class="sticky top-0 left-0 w-full bg-gray-800 text-white shadow z-50" style="height: 4rem;">
        <div class="flex items-center px-4 py-2 h-16">
            <button
                class="px-4 py-1 font-bold focus:outline-none transition text-white bg-gray-700 hover:bg-gray-600 rounded-lg flex items-center gap-2"
                @onclick="BackToEdit">
                <i class="fa-solid fa-arrow-left"></i>
                編集に戻る
            </button>
        </div>
    </div>

    <!-- メインエリア -->
    <div class="overflow-hidden h-[calc(100vh-4rem)]">
        <div class="flex flex-col md:flex-row h-full">
            <!-- PDFプレビュー -->
            <div class="flex-1 h-full bg-neutral-100 overflow-hidden">
                <div class="w-full h-full overflow-auto flex flex-col items-center py-8 gap-8">
                    @for (int i = 0; i < mergedPageCount; i++)
                    {
    <canvas id="merged-canvas-@i"
            class="shadow-lg border border-gray-300 rounded bg-white"
            style="width:90%; max-width:800px;">
    </canvas>
                    }
                </div>
            </div>
            <!-- 情報パネル（PCのみ表示） -->
            <div class="hidden md:flex flex-col w-full max-w-xs bg-white border-l border-gray-200 shadow-lg h-full p-6 justify-center items-center">
                <div class="flex flex-col items-center gap-4">
                    <div class="flex items-center gap-2 text-green-600 text-2xl font-bold">
                        <i class="fa-solid fa-check-circle"></i>
                        <span>完了</span>
                    </div>
                    <div class="text-gray-800 font-semibold truncate w-full text-center">@mergedFileName</div>
                    <div class="text-gray-600 text-sm">サイズ: @mergedFileSize</div>
                    <div class="text-gray-600 text-sm">ページ数: @mergedPageCount</div>
                    <div class="relative w-full mt-4">
                        <div class="flex w-full">
                            <!-- メインボタン -->
                            <button class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-l-lg flex-1 transition"
                                    @onclick="DownloadMergedPdf">
                                ダウンロード
                            </button>
                            <!-- ドロップダウンボタン -->
                            <button class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-2 rounded-r-lg border-l border-blue-700 flex items-center transition"
                                    @onclick="() => showDownloadMenu = !showDownloadMenu">
                                <i class="fa-solid fa-caret-down"></i>
                            </button>
                        </div>
                        @if (showDownloadMenu)
                        {
                            <div id="downloadMenu" class="absolute right-0 mt-1 w-full bg-white border border-gray-300 rounded-lg shadow-lg z-50">
                                <button class="w-full text-left px-4 py-2 hover:bg-blue-50 text-gray-800 rounded-t-lg"
                                        @onclick="() => { DownloadMergedPdf(); showDownloadMenu = false; }">
                                    PDFでダウンロード
                                </button>
                                <button class="w-full text-left px-4 py-2 hover:bg-blue-50 text-gray-800 rounded-b-lg"
                                        @onclick="() => { DownloadMergedPng(); showDownloadMenu = false; }">
                                    PNG画像でダウンロード
                                </button>
                            </div>

                        }
                    </div>
                    <button class="bg-neutral-500 hover:bg-neutral-600 text-white font-bold py-2 px-6 rounded-lg w-full flex items-center justify-center mt-4"
                        @onclick="StartNew">
                        <i class="fa-solid fa-rotate-right mr-2"></i>
                        新規作成
                    </button>
                </div>
            </div>
        </div>
        <!-- タブレット/スマホ用: 下部スライドアップメニュー -->
        <div class="md:hidden fixed bottom-0 left-0 w-full z-[200]">
            <div class="@($"transition-transform duration-300 bg-white border-t border-gray-300 shadow-lg p-4 { (isMenuOpen ? "translate-y-0" : "translate-y-full") }")"
                 style="will-change: transform;">
                <div class="flex flex-col items-center gap-4">
                    <div class="flex items-center gap-2 text-green-600 text-2xl font-bold">
                        <i class="fa-solid fa-check-circle"></i>
                        <span>完了</span>
                    </div>
                    <div class="text-gray-800 font-semibold truncate w-full text-center">@mergedFileName</div>
                    <div class="text-gray-600 text-sm">サイズ: @mergedFileSize</div>
                    <div class="text-gray-600 text-sm">ページ数: @mergedPageCount</div>
<div class="relative w-full mt-4">
                <div class="flex w-full">
                    <button class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-l-lg flex-1 transition"
                            @onclick="DownloadMergedPdf">
                        ダウンロード
                    </button>
                    <button class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-2 rounded-r-lg border-l border-blue-700 flex items-center transition"
                            @onclick="() => showDownloadMenu = !showDownloadMenu">
                        <i class="fa-solid fa-caret-down"></i>
                    </button>
                </div>
                @if (showDownloadMenu)
                {
                    <div class="absolute right-0 mt-1 w-full bg-white border border-gray-300 rounded-lg shadow-lg z-50">
                        <button class="w-full text-left px-4 py-2 hover:bg-blue-50 text-gray-800 rounded-t-lg"
                                @onclick="() => { DownloadMergedPdf(); showDownloadMenu = false; }">
                            PDFでダウンロード
                        </button>
                        <button class="w-full text-left px-4 py-2 hover:bg-blue-50 text-gray-800 rounded-b-lg"
                                @onclick="() => { DownloadMergedPng(); showDownloadMenu = false; }">
                            PNG画像でダウンロード
                        </button>
                    </div>
                }
            </div>
            <button class="bg-neutral-500 hover:bg-neutral-600 text-white font-bold py-2 px-6 rounded-lg w-full flex items-center justify-center mt-4"
                @onclick="StartNew">
                <i class="fa-solid fa-rotate-right mr-2"></i>
                新規作成
            </button>
                </div>
                <button class="absolute top-2 right-4 text-2xl text-gray-500" @onclick="() => isMenuOpen = false">
                    <i class="fa-solid fa-xmark"></i>
                </button>
            </div>
            <!-- 展開ボタン -->
            @if (!isMenuOpen)
            {
                <button
                    class="fixed bottom-4 left-1/2 -translate-x-1/2 z-[201] bg-white rounded-full shadow px-8 py-3 border border-gray-300 flex items-center gap-3 text-lg font-bold hover:bg-blue-50 transition"
                    style="min-width: 260px;"
                    @onclick="() => isMenuOpen = true">
                    <i class="fa-solid fa-check-circle text-green-600 text-2xl"></i>
                    <span>完了</span>
                    <i class="fa-solid fa-chevron-up ml-2"></i>
                </button>
            }
        </div>
        <!-- メニュー展開時はPDFのスクロールを禁止 -->
        @if (isMenuOpen)
        {
            <div class="fixed inset-0 bg-black/30 z-[199]" style="touch-action:none;" @onclick="() => isMenuOpen = false"></div>
        }
    </div>
}
@if (isBusy)
{
    <div class="fixed inset-0 flex items-center justify-center z-[100] bg-black/40">
        <div class="flex flex-col items-center">
            <div class="animate-spin rounded-full h-16 w-16 border-b-4 border-blue-600 mb-4"></div>
            <span class="text-white font-bold text-lg">処理中です...</span>
        </div>
    </div>
}
<!-- メッセージ表示エリア -->
@if (!string.IsNullOrEmpty(errorMessage) || !string.IsNullOrEmpty(warnMessage))
{
    <MessageBar Message="@(errorMessage ?? warnMessage)"
                IsError="@(errorMessage != null)"
                OnClose="ClearAllMessages" />
}

<!-- ファイル選択用の隠しinput -->
<InputFile OnChange="HandleFileSelectionAsync" multiple style="display: none;" id="fileInput" />
<InputFile OnChange="HandleInsertFileSelectionAsync" style="display: none;" id="insertFileInput" />


@code {
    protected override void OnInitialized()
    {
        PdfDataService.OnChange += OnServiceChanged;
    }

    private void OnServiceChanged()
    {
        InvokeAsync(StateHasChanged);
    }

    public void Dispose()
    {
        PdfDataService.OnChange -= OnServiceChanged;
    }
    private bool isLoading = false;
    private bool showMergedResult = false;
    private bool isBusy = false;
    private int progress = 0;
    private string? mergedPdfUrl;
    private string? errorMessage;
    private string? warnMessage;
    private const int MessageDurationMs = 5000;
    private bool showSortMenu = false;
    private bool showAddMenu = false;
    // 統一アーキテクチャ対応プロパティ
    private DisplayMode CurrentDisplayMode => PdfDataService.GetModel().CurrentMode;
    private List<DisplayItem> DisplayItems => PdfDataService.GetDisplayItems();
    private bool IsFilesLoaded => DisplayItems.Any();
    private bool IsFileMode => CurrentDisplayMode == DisplayMode.File;
    private bool IsPageMode => CurrentDisplayMode == DisplayMode.Page;

    private int previewIndex = -1;

    private string? previewImageUrl = null;
    private bool isPreviewLoading = false;
    // ファイル単位表示時の現在ページ番号（0始まり）
    private int CurrentFilePageIndex => GetCurrentFilePageIndex();
    // ファイル単位表示時の総ページ数
    private int CurrentFilePageCount => GetCurrentFilePageCount();

    // ファイル単位表示時のファイル内ページ番号（0始まり）
    // プレビュー中のファイル内で、何ページ目を表示しているか
    private int filePageIndex = 0;
    private DotNetObjectReference<Merge>? _dotNetRef;
    private bool isDragOver = false;
    private bool isMenuOpen = false;
    private string mergedFileName = ""; 
    private string mergedFileSize = ""; 
    private int mergedPageCount = 0;
    private bool showDownloadMenu = false;
    private int GetCurrentFilePageIndex()
    {
        if (!IsFileMode || previewIndex < 0 || previewIndex >= DisplayItems.Count)
            return 0;
        return filePageIndex;
    }
    private int GetCurrentFilePageCount()
    {
        if (!IsFileMode || previewIndex < 0 || previewIndex >= DisplayItems.Count)
            return 1;
        return DisplayItems[previewIndex].PageCount;
    }
    private async Task ToggleAddMenu()
    {
        showAddMenu = !showAddMenu;
        if (showAddMenu)
        {
            showSortMenu = false;
            await JSRuntime.InvokeVoidAsync("registerOutsideClick", "addMenu", DotNetObjectReference.Create(this));
        }
    }
    [JSInvokable]
    public void CloseAddMenu()
    {
        showAddMenu = false;
        StateHasChanged();
    }

    private async Task AddPdfFile()
    {
        showAddMenu = false;
        await OpenFileDialog();
    }
    private async Task ToggleSortMenu()
    {
        showSortMenu = !showSortMenu;
        if (showSortMenu)
        {
            showAddMenu = false;
            await JSRuntime.InvokeVoidAsync("registerOutsideClick", "sortMenu", DotNetObjectReference.Create(this));
        }
    }

    [JSInvokable]
    public void CloseSortMenu()
    {
        showSortMenu = false;
        StateHasChanged();
    }
    private async Task MovePreview(int direction)
    {
        if (IsFileMode)
        {
            var pageCount = DisplayItems[previewIndex].PageCount;
            var nextPage = filePageIndex + direction;
            if (nextPage >= 0 && nextPage < pageCount)
            {
                filePageIndex = nextPage;
                await ShowPreviewAsync(previewIndex, filePageIndex);
            }
        }
        else
        {
            var nextIndex = previewIndex + direction;
            if (nextIndex >= 0 && nextIndex < DisplayItems.Count)
            {
                await ShowPreviewAsync(nextIndex);
            }
        }
    }
    private async Task OnPreviewPageInputChanged(ChangeEventArgs e)
    {
        if (!IsFileMode) return;

        if (int.TryParse(e.Value?.ToString(), out int inputPage))
        {
            // 1以上、最大ページ数以下のみ有効
            if (inputPage >= 1 && inputPage <= CurrentFilePageCount)
            {
                filePageIndex = inputPage - 1;
                await ShowPreviewAsync(previewIndex, filePageIndex);
            }
        }
    }
    private async Task RotatePreviewLeft()
    {
        if (previewIndex >= 0 && previewIndex < DisplayItems.Count)
        {
            await PdfDataService.RotateItemAsync(previewIndex, -90);
            await ShowPreviewAsync(previewIndex);
        }
    }

    private async Task RotatePreviewRight()
    {
        if (previewIndex >= 0 && previewIndex < DisplayItems.Count)
        {
            await PdfDataService.RotateItemAsync(previewIndex, 90);
            await ShowPreviewAsync(previewIndex);
        }
    }


    private async Task ShowPreviewAsync(int fileIndex, int pageIndex = 0)
    {
        previewIndex = fileIndex;
        filePageIndex = pageIndex;
        previewImageUrl = null;
        isPreviewLoading = true;
        StateHasChanged();

        try
        {
            if (IsFileMode)
            {
                // 修正: 残っているページリストからOriginalPageIndexを取得して渡す
                var fileId = DisplayItems[fileIndex].Id;
                var model = PdfDataService.GetModel();
                var filePages = model.Pages.Where(p => p.FileId == fileId).OrderBy(p => p.OriginalPageIndex).ToList();
                if (pageIndex >= 0 && pageIndex < filePages.Count)
                {
                    var page = filePages[pageIndex];
                    previewImageUrl = await PdfDataService.GetPreviewImageAsync(fileId, page.OriginalPageIndex);
                }
                else
                {
                    previewImageUrl = null;
                }
            }
            else
            {
                // ページ単位表示時は従来通り
                previewImageUrl = await PdfDataService.GetPreviewImageAsync(DisplayItems[fileIndex].Id);
            }
        }
        catch
        {
            // 失敗時はサムネイル表示
            previewImageUrl = DisplayItems[fileIndex].Thumbnail;
        }
        isPreviewLoading = false;
        StateHasChanged();
    }


    private void ClosePreview()
    {
        previewIndex = -1;
        StateHasChanged();
    }
    // 表示モード切り替えメソッド
    private async Task SwitchToFileMode()
    {
        if (IsFileMode) return;
        PdfDataService.SwitchDisplayMode(DisplayMode.File);
        StateHasChanged();
        await Task.Delay(100); // DOM更新待ち

        // JavaScript再初期化
        try
        {
            await JSRuntime.InvokeVoidAsync("initializeDragDrop");
            await JSRuntime.InvokeVoidAsync("initializeSortable");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error reinitializing JS: {ex.Message}");
        }

    }

    private async Task SwitchToPageMode()
    {
        if (IsPageMode) return;

        // 即座にページ単位モードに切り替える（読み込み完了を待たない）
        PdfDataService.SwitchDisplayMode(DisplayMode.Page);
        StateHasChanged();
        await Task.Delay(100); // DOM更新待ち

        // JavaScript再初期化
        try
        {
            await JSRuntime.InvokeVoidAsync("initializeDragDrop");
            await JSRuntime.InvokeVoidAsync("initializeSortable");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error reinitializing JS: {ex.Message}");
        }

        // バックグラウンドで残りのページ読み込みを継続（UI をブロックしない）
        _ = Task.Run(async () =>
        {
            try
            {
                await PdfDataService.EnsureAllPagesLoadedAsync();
                await InvokeAsync(() =>
        {
            StateHasChanged(); // 読み込み完了時にUIを更新
        });
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error in background page loading: {ex.Message}");
                await InvokeAsync(() =>
        {
            ShowWarn($"一部ページの読み込みに失敗しました。問題のあるページは「読み込みエラー」と表示されます。");
            StateHasChanged();
        });
            }
        });
    }

    public class MergePageDto
    {
        public string FileId { get; set; } = "";
        public string FileName { get; set; } = "";
        public string PageData { get; set; } = "";
        public bool IsPdf { get; set; }
        public int RotateAngle { get; set; }
    }
    // PDF結合処理
    private async Task MergePDFs()
    {
        try
        {
            isBusy = true;
            StateHasChanged();
            await Task.Yield();

            Console.WriteLine("Starting PDF merge process...");
            // 1. PageItemリストを取得
            var mergeItems = PdfDataService.GetModel().Pages;

            // 準備できていないページがある場合は中断
            var notReadyCount = mergeItems.Count(item => string.IsNullOrEmpty(item.PageData) || item.HasError);
            if (notReadyCount > 0)
            {
                Console.WriteLine($"Not ready pages: {notReadyCount}");
                ShowWarn($"PDFの読み込みが完了していないページが {notReadyCount} ページあります。");
                return;
            }

            if (mergeItems.Count == 0)
            {
                ShowError("結合対象がありません。");
                Console.WriteLine("No items selected.");
                return;
            }

            errorMessage = null;

            // 2. JSに渡すためのデータを整形
            var mergeData = mergeItems.Select(item => new MergePageDto
            {
                FileId = item.FileId,
                FileName = item.FileName,
                PageData = item.PageData,
                IsPdf = Path.GetExtension(item.FileName).ToLowerInvariant() == ".pdf",
                RotateAngle = item.RotateAngle % 360
            }).ToList();

            // 3. JSで結合処理
            mergedPdfUrl = await JSRuntime.InvokeAsync<string>("mergePDFPages", mergeData);

            if (!string.IsNullOrEmpty(mergedPdfUrl))
            {
                mergedFileName = $"merge_{DateTime.Now:yyyyMMddHHmm}.pdf";
                mergedFileSize = await JSRuntime.InvokeAsync<string>("getPdfFileSize", mergedPdfUrl);
                mergedPageCount = mergeItems.Count;

                showMergedResult = true;
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"An error occurred: {ex.Message}");
            ShowError("PDF/画像の結合中にエラーが発生しました。");
        }
        finally
        {
            isBusy = false;
            StateHasChanged();
        }
    }

    // アイテム削除
    private void RemovePage(int index)
    {

        try
        {
            PdfDataService.RemoveItem(index);
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error removing item {index}: {ex.Message}");
            errorMessage = $"削除に失敗しました: {ex.Message}";
        }
    }


    // ファイルダイアログを開く
    private async Task OpenFileDialog()
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("openFileDialog", "fileInput");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error opening file dialog: {ex.Message}");
            errorMessage = $"ファイル選択ダイアログの表示に失敗しました: {ex.Message}";
        }
    }

    // その他のメソッド
    private void BackToEdit()
    {
        showMergedResult = false;
        StateHasChanged();
    }

    private void StartNew()
    {
        PdfDataService.Clear();
        showMergedResult = false;
        mergedPdfUrl = null;
        errorMessage = null;
        StateHasChanged();
    }

    private void ClearErrorMessage()
    {
        errorMessage = null;
        StateHasChanged();
    }

    // 隣接サムネイルとの入れ替え機能
    private void SwapWithNext(int index)
    {
        try
        {
            var currentCount = DisplayItems.Count;

            if (index >= 0 && index < currentCount - 1)
            {
                var nextIndex = index + 1;
                Console.WriteLine($"Swapping {index} with {nextIndex}");

                // 統一データサービスを使用して入れ替え
                PdfDataService.SwapItems(index, nextIndex);
                StateHasChanged();

                Console.WriteLine($"Swap completed successfully");
            }
            else
            {
                Console.WriteLine($"Invalid swap: index={index}, count={currentCount}");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error in SwapWithNext: {ex.Message}");
            errorMessage = $"サムネイルの入れ替えに失敗しました: {ex.Message}";
        }
    }

    // 回転処理
    private async Task RotatePage(int index, int angle = 90)
    {
        if (index >= 0 && index < DisplayItems.Count)
        {
            try
            {
                await PdfDataService.RotateItemAsync(index, angle);
                StateHasChanged();
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error rotating item {index}: {ex.Message}");
                errorMessage = $"アイテム {index + 1} の回転に失敗しました: {ex.Message}";
            }
        }
    }

    private async Task RotateFile(string fileId)
    {
        await PdfDataService.RotateFileAsync(fileId, 90);
        StateHasChanged();
    }

    private Task RotateAllLeft() => RotateAll(-90);
    private Task RotateAllRight() => RotateAll(90);
    private async Task RotateAll(int angle)
    {
        isBusy = true;
        StateHasChanged();

        if (IsFileMode)
        {
            foreach (var file in DisplayItems)
            {
                await PdfDataService.RotateFileAsync(file.Id, angle);
            }
        }
        else
        {
            for (int i = 0; i < DisplayItems.Count; i++)
            {
                await PdfDataService.RotateItemAsync(i, angle);
            }
        }

        isBusy = false;
        StateHasChanged();
    }

    private async void RemoveItemFromPreview()
    {
        if (IsFileMode)
        {
            var fileId = DisplayItems[previewIndex].Id;
            int removedPageIndex = filePageIndex;

            PdfDataService.RemovePageFromFile(fileId, removedPageIndex);
            await InvokeAsync(StateHasChanged);

            var items = DisplayItems;
            var newIndex = items.FindIndex(x => x.Id == fileId);

            if (newIndex >= 0 && items[newIndex].PageCount > 0)
            {
                int pageCount = items[newIndex].PageCount;
                // インデックス再計算
                filePageIndex = (removedPageIndex >= pageCount) ? pageCount - 1 : removedPageIndex;
                if (filePageIndex < 0) filePageIndex = 0;
                previewIndex = newIndex;

                await ShowPreviewAsync(previewIndex, filePageIndex);
            }
            else
            {
                // ファイル自体が消えた場合、次のインデックスにプレビューを移動
                if (items.Count > 0)
                {
                    previewIndex = Math.Min(previewIndex, items.Count - 1);
                    filePageIndex = 0;
                    await ShowPreviewAsync(previewIndex, filePageIndex);
                }
                else
                {
                    ClosePreview();
                }
            }
        }
        else
        {
            PdfDataService.RemoveItem(previewIndex);
            var items = DisplayItems;
            if (items.Count > 0)
            {
                previewIndex = Math.Min(previewIndex, items.Count - 1);
                await ShowPreviewAsync(previewIndex);
            }
            else
            {
                ClosePreview();
            }
        }
    }
    private async Task DuplicateItem(int index)
    {
        if (IsFileMode)
        {
            var fileItem = DisplayItems[index];
            await PdfDataService.DuplicateItemAsync(fileItem.Id, true, index + 1);
        }
        else if (IsPageMode)
        {
            var pageItem = DisplayItems[index];
            await PdfDataService.DuplicateItemAsync(pageItem.Id, false, index + 1);
        }
        StateHasChanged();
    }

    // 挿入ボタンクリック処理
    private async Task HandleInsertButtonClick(int position, MouseEventArgs e)
    {

        try
        {
            // JavaScriptの挿入メニューを表示
            await JSRuntime.InvokeVoidAsync("showInsertMenuAtExactPosition", position, e.ClientX, e.ClientY);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error showing insert menu: {ex.Message}");
            errorMessage = $"メニュー表示に失敗しました: {ex.Message}";
        }
    }

    // 静的インスタンスで現在のコンポーネントを参照（JavaScript連携用）
    private static Merge? _currentInstance;

    // JavaScript から呼び出される並び替えメソッド
    [JSInvokable("UpdateOrder")]
    public static async Task UpdateOrder(int oldIndex, int newIndex)
    {
        Console.WriteLine($"UpdateOrder called with oldIndex: {oldIndex}, newIndex: {newIndex}");

        if (_currentInstance != null)
        {
            Console.WriteLine($"Current instance found, calling UpdateOrderInternal");
            await _currentInstance.UpdateOrderInternal(oldIndex, newIndex);
        }
        else
        {
            Console.WriteLine($"ERROR: Current instance is null!");
        }
    }

    // 実際の並び替え処理
    private async Task UpdateOrderInternal(int oldIndex, int newIndex)
    {
        try
        {
            Console.WriteLine($"UpdateOrderInternal called: {oldIndex} -> {newIndex}");

            if (oldIndex >= 0 && oldIndex < DisplayItems.Count &&
            newIndex >= 0 && newIndex < DisplayItems.Count &&
            oldIndex != newIndex)
            {
                // 統一データサービスを使用して並び替え
                PdfDataService.MoveItem(oldIndex, newIndex);

                Console.WriteLine($"Successfully moved item from {oldIndex} to {newIndex}");

                // DOM更新
                await InvokeAsync(async () =>
                {
                    StateHasChanged();
                    await Task.Delay(100);
                    await JSRuntime.InvokeVoidAsync("initializeSortable");
                });
            }
            else
            {
                Console.WriteLine($"Invalid move operation: oldIndex={oldIndex}, newIndex={newIndex}, count={DisplayItems.Count}");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error in UpdateOrderInternal: {ex.Message}");
            errorMessage = $"並び替えに失敗しました: {ex.Message}";
        }
    }

    // JavaScript から呼び出される空白ページ挿入メソッド
    [JSInvokable("InsertBlankPageFromJS")]
    public static Task InsertBlankPageFromJS(int position)
    {
        // インスタンス参照が必要なら、staticフィールドで管理
        if (_currentInstance != null)
        {
            return _currentInstance.InsertBlankPage(position);
        }
        return Task.CompletedTask;
    }

    // JavaScript から呼び出されるPDF挿入メソッド
    [JSInvokable("InsertPdfAtPositionFromJS")]
    public static async Task InsertPdfAtPositionFromJS(int position)
    {
        if (_currentInstance != null)
        {
            await _currentInstance.InsertPdfAtPosition(position);
        }
    }

    // 空白ページを挿入
    private async Task InsertBlankPage(int position)
    {
        showAddMenu = false;

        int insertPosition;
        if (IsFileMode)
        {
            int pageInsertPosition = 0;
            for (int i = 0; i < position && i < DisplayItems.Count; i++)
            {
                pageInsertPosition += DisplayItems[i].PageCount;
            }
            insertPosition = pageInsertPosition;
        }
        else
        {
            insertPosition = position;
        }

        await PdfDataService.InsertBlankPageAsync(insertPosition);
        StateHasChanged();
    }

    // PDF挿入
    private async Task InsertPdfAtPosition(int position)
    {
        try
        {
            Console.WriteLine($"Opening file dialog for PDF insertion at position {position}");

            // JavaScriptでファイルダイアログを開く
            await JSRuntime.InvokeVoidAsync("openInsertFileDialog", "insertFileInput");

            // 挿入位置を保存（ファイル選択後に使用）
            insertPosition = position;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error opening insert file dialog: {ex.Message}");
            errorMessage = $"ファイル選択ダイアログの表示に失敗しました: {ex.Message}";
        }
    }

    private int insertPosition = -1;

    // 挿入用ファイル選択処理
    private async Task HandleFileSelectionAsync(InputFileChangeEventArgs e)
{
    await HandleFileInputAsync(e);
}

private async Task HandleInsertFileSelectionAsync(InputFileChangeEventArgs e)
{
    if (insertPosition >= 0)
    {
        await HandleFileInputAsync(e, insertPosition);
        insertPosition = -1;
    }
}
   private async Task HandleFileInputAsync(InputFileChangeEventArgs e, int? insertPosition = null)
{
    if (e.FileCount == 0) return;

    isLoading = true;
    progress = 0;
    errorMessage = null;
    const long maxFileSize = 52428800; // 50MB

    foreach (var file in e.GetMultipleFiles())
    {
        var ext = Path.GetExtension(file.Name).ToLowerInvariant();
        try
        {
            using var stream = file.OpenReadStream(maxFileSize);
            using var memoryStream = new MemoryStream();
            await stream.CopyToAsync(memoryStream);
            var fileData = memoryStream.ToArray();

            bool success = false;
            if (PdfDataService.SupportedPdfExtensions.Contains(ext))
            {
                success = await PdfDataService.AddOrInsertPdfFileAsync(file.Name, fileData, insertPosition);
            }
            else if (PdfDataService.SupportedImageExtensions.Contains(ext))
            {
                if (insertPosition.HasValue)
                    success = await PdfDataService.AddOrInsertImageFileAsync(file.Name, fileData, insertPosition);
                else
                    success = await PdfDataService.AddOrInsertImageFileAsync(file.Name, fileData);
            }
            else
            {
                errorMessage = $"未対応のファイル形式です: {file.Name}";
            }

            if (!success)
            {
                errorMessage = $"ファイルの処理に失敗しました: {file.Name}";
            }
        }
        catch (Exception ex)
        {
            errorMessage = $"ファイル処理エラー: {file.Name} - {ex.Message}";
        }
    }

    isLoading = false;
    StateHasChanged();
}

    private Task ReverseOrder()
    {
        isBusy = true;
        StateHasChanged();

        if (IsFileMode)
        {
            // ファイル単位：ファイルごと逆順
            var model = PdfDataService.GetModel();
            var fileIds = DisplayItems.Select(x => x.Id).Reverse().ToList();
            PdfDataService.ReorderFiles(fileIds);
        }
        else if (IsPageMode)
        {
            // ページ単位：ページごと逆順
            PdfDataService.ReversePages();
        }

        StateHasChanged();
        isBusy = false;
        return Task.CompletedTask;
    }

    private void SelectSort(bool ascending)
    {
        showSortMenu = false;
        SortByName(ascending);
    }
    private void SortByName(bool ascending)
    {
        if (IsFileMode)
        {
            var sorted = ascending
            ? DisplayItems.OrderBy(x => x.DisplayName).Select(x => x.Id).ToList()
            : DisplayItems.OrderByDescending(x => x.DisplayName).Select(x => x.Id).ToList();
            PdfDataService.ReorderFiles(sorted);
        }
        else if (IsPageMode)
        {
            PdfDataService.SortPagesByName(ascending);
        }
        StateHasChanged();
    }



private async Task HandleDroppedFilesAsync(IReadOnlyList<IBrowserFile> files)
{
    isLoading = true;
    progress = 0;
    errorMessage = null;
    const long maxFileSize = 52428800; // 50MB

    foreach (var file in files)
    {
        var ext = Path.GetExtension(file.Name).ToLowerInvariant();
        try
        {
            using var stream = file.OpenReadStream(maxFileSize);
            using var memoryStream = new MemoryStream();
            await stream.CopyToAsync(memoryStream);
            var fileData = memoryStream.ToArray();

            bool success = false;
            if (PdfDataService.SupportedPdfExtensions.Contains(ext))
            {
                success = await PdfDataService.AddOrInsertPdfFileAsync(file.Name, fileData, null);
            }
            else if (PdfDataService.SupportedImageExtensions.Contains(ext))
            {
                success = await PdfDataService.AddOrInsertImageFileAsync(file.Name, fileData);
            }
            else
            {
                errorMessage = $"未対応のファイル形式です: {file.Name}";
            }

            if (!success)
            {
                errorMessage = $"ファイルの処理に失敗しました: {file.Name}";
            }
        }
        catch (Exception ex)
        {
            errorMessage = $"ファイル処理エラー: {file.Name} - {ex.Message}";
        }
    }

    isLoading = false;
    StateHasChanged();
}

[JSInvokable]
    public async Task OnJsFileDropped(string fileName, string contentType, string base64Data)
    {
        var fileData = Convert.FromBase64String(base64Data);

        bool success = false;
        var ext = Path.GetExtension(fileName).ToLowerInvariant();
        if (PdfDataService.SupportedPdfExtensions.Contains(ext))
        {
            success = await PdfDataService.AddOrInsertPdfFileAsync(fileName, fileData, null);
        }
        else if (PdfDataService.SupportedImageExtensions.Contains(ext))
        {
            success = await PdfDataService.AddOrInsertImageFileAsync(fileName, fileData,null);
        }
        else
        {
            errorMessage = $"未対応のファイル形式です: {fileName}";
        }

        if (!success)
        {
            errorMessage = $"ファイルの処理に失敗しました: {fileName}";
        }

        StateHasChanged();
    }
    private bool _renderedMergedPages = false;
    private bool _dropAreaRegistered = false;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _currentInstance = this;
            _dotNetRef = DotNetObjectReference.Create(this);
        }
        // 初期画面のときのみ登録
        if (!IsFilesLoaded && !showMergedResult)
        {
            await JSRuntime.InvokeVoidAsync("registerSelectDropArea", _dotNetRef);
        }
        if (showDownloadMenu)
            {
                await JSRuntime.InvokeVoidAsync(
                    "registerOutsideClickForDownloadMenu",
                    "downloadMenu",
                    DotNetObjectReference.Create(this)
                );
            }
        // drop-areaが表示され、まだ登録していない場合のみ
        if (!_dropAreaRegistered && IsFilesLoaded && DisplayItems.Any())
        {
            await JSRuntime.InvokeVoidAsync("registerDropArea", "drop-area", _dotNetRef);
            _dropAreaRegistered = true;
        }
        else if (_dropAreaRegistered && (!IsFilesLoaded || !DisplayItems.Any()))
        {
            // drop-areaが消えたらフラグを戻す（必要ならJSでunregisterも）
            _dropAreaRegistered = false;
        }
        if (IsFilesLoaded && DisplayItems.Any())
        {
            foreach (var item in DisplayItems)
            {
                await JSRuntime.InvokeVoidAsync(
                "drawImageToCanvas",
                $"thumb-{item.Id}",
                item.Thumbnail
                );
            }
        }

        // 毎回ドラッグ&ドロップとソート機能を再初期化（DOM更新時に必要）
        if (IsFilesLoaded && DisplayItems.Any())
        {
            await InvokeAsync(async () =>
            {
                try
                {
                    await Task.Delay(50); // DOM更新完了を待つ
                    await JSRuntime.InvokeVoidAsync("initializeDragDrop");
                    await JSRuntime.InvokeVoidAsync("initializeSortable");
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Error initializing interactions: {ex.Message}");
                }
            });
        }
        if (showMergedResult && !string.IsNullOrEmpty(mergedPdfUrl) && mergedPageCount > 0 && !_renderedMergedPages)
        {
            _renderedMergedPages = true;
            var canvasIds = Enumerable.Range(0, mergedPageCount)
                                    .Select(i => $"merged-canvas-{i}")
                                    .ToArray();
            await JSRuntime.InvokeVoidAsync("renderPdfPages", mergedPdfUrl, canvasIds);
        }
        else if (!showMergedResult)
        {
            _renderedMergedPages = false;
        }
    }
    [JSInvokable]
    public void SetDragOver(bool over)
    {
        isDragOver = over;
        StateHasChanged();
    }
    [JSInvokable]
    public void CloseDownloadMenu()
    {
        showDownloadMenu = false;
        StateHasChanged();
    }
    private async void DownloadMergedPdf()
    {
        if (string.IsNullOrEmpty(mergedPdfUrl) || string.IsNullOrEmpty(mergedFileName))
            return;

        try
        {
            await JSRuntime.InvokeVoidAsync(
                "downloadFileFromUrl",
                mergedPdfUrl,
                mergedFileName,
                "application/pdf"
            );
        }
        catch (Exception ex)
        {
            errorMessage = $"PDFのダウンロードに失敗しました: {ex.Message}";
            StateHasChanged();
        }
    }

private async void ShowError(string msg)
{
    errorMessage = msg;
    warnMessage = null;
    StateHasChanged();
    await Task.Delay(5000);
    if (errorMessage == msg) // 他のメッセージで上書きされていなければ
    {
        errorMessage = null;
        StateHasChanged();
    }
}


private async void ShowWarn(string msg)
{
    Console.WriteLine($"ShowWarn called with message: {msg}");
    warnMessage = msg;
    errorMessage = null;
    StateHasChanged();
    await Task.Delay(5000);
    if (warnMessage == msg)
    {
        warnMessage = null;
        StateHasChanged();
    }
}

    private void ClearAllMessages()
    {
        errorMessage = null;
        warnMessage = null;
        StateHasChanged();
    }

    private async void DownloadMergedPng()
    {
        if (string.IsNullOrEmpty(mergedPdfUrl) || string.IsNullOrEmpty(mergedFileName))
        return;

        try
        {
            // JSでPNGまたはZIPダウンロードを実行
            await JSRuntime.InvokeVoidAsync(
                "downloadMergedPngOrZip",
                mergedPdfUrl,
                mergedFileName,
                mergedPageCount // ページ数
            );
        }
        catch (Exception ex)
        {
            errorMessage = $"PNGダウンロードに失敗しました: {ex.Message}";
            StateHasChanged();
        }
    }
        private async Task ReloadPageItem(DisplayItem item)
    {
        // ページ単位の場合のみ対応
        if (item.RawData is PageItem pageItem)
        {
            pageItem.IsLoading = true;
            pageItem.HasError = false;
            StateHasChanged();

            // ページ再読み込み（ファイルIDとページインデックスで再実行）
            await PdfDataService.ReloadPageAsync(pageItem.FileId, pageItem.OriginalPageIndex);

            StateHasChanged();
        }
    }
}
