@page "/merge"
@implements IDisposable
@inject IJSRuntime JSRuntime
@inject PdfDataService PdfDataService
@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.AspNetCore.Components.Web
@using Microsoft.JSInterop
@using System.IO
@using ClientPdfApp.Models
@using ClientPdfApp.Services

<PageTitle>Merge</PageTitle>

@if (IsFilesLoaded && !showMergedResult)
{
    <!-- 上部固定バー（編集モード） -->
    <div class="sticky top-0 left-0 w-full bg-gray-800 text-white shadow z-50">
        <div class="flex items-center justify-between px-4 py-2">
            <div class="flex-1 flex items-center">
                <!-- 左寄せ：表示切替・回転ボタン -->
                <div class="flex gap-2 items-center">
                    <div class="inline-flex shadow rounded overflow-hidden border border-gray-500">
                        <button
                            class="px-4 py-1 font-bold focus:outline-none transition
                                                                                                                                                                                                                                                                                                                                                                                                                                                                @(IsFileMode ? "bg-blue-500 text-white" : "bg-gray-700 text-gray-200")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                rounded-s-lg border-e border-gray-500"
                            @onclick="SwitchToFileMode">
                            <i class="fa-solid fa-file mr-2"></i>ファイル
                        </button>
                        <button
                            class="px-4 py-1 font-bold focus:outline-none transition
                                                                                                                                                                                                                                                                                                                                                                                                                                                                @(IsPageMode ? "bg-blue-500 text-white" : "bg-gray-700 text-gray-200")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                rounded-e-lg"
                            @onclick="SwitchToPageMode">
                            <i class="fa-solid fa-file-lines mr-2"></i>ページ
                        </button>
                    </div>
                    <button
                        class="bg-neutral-500 hover:bg-neutral-600 text-white font-bold py-2 px-3 rounded-lg flex items-center gap-1"
                        @onclick="RotateAllLeft" title="左回転">
                        <i class="fa-solid fa-rotate-left"></i>
                    </button>
                    <button
                        class="bg-neutral-500 hover:bg-neutral-600 text-white font-bold py-2 px-3 rounded-lg flex items-center gap-1"
                        @onclick="RotateAllRight" title="右回転">
                        <i class="fa-solid fa-rotate-right"></i>
                    </button>
                </div>
                <!-- 右寄せ：結合ボタン -->
                <div class="flex-1 flex justify-end">
                    <button class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg"
                        @onclick="MergePDFs">
                        結合
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- サムネイル編集エリア -->
    <div class="pt-16">
        <div id="sortable-container" class="flex flex-wrap gap-4 p-6">
            @if (DisplayItems != null && DisplayItems.Any())
            {
                @for (int i = 0; i < DisplayItems.Count; i++)
                {
                    var index = i;
                    var item = DisplayItems[index];

                    <div class="sortable-item-container flex items-center gap-2" data-index="@index">
                        <!-- 左側の＋ボタン -->
                        <div class="flex items-center relative insert-button-container" data-position="@index"
                            style="flex-direction: column; align-items: center;">
                            <button
                                class="w-6 h-6 bg-blue-500/60 hover:bg-blue-600 hover:bg-opacity-100 text-white rounded-full flex items-center justify-center insert-button transition-all duration-200"
                                data-position="@index" @onclick="@((e) => HandleInsertButtonClick(index, e))">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor" class="w-3 h-3">
                                    <path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z" />
                                </svg>
                            </button>
                            <!-- 隣接サムネイルとの入れ替えボタン -->
                            @if (index > 0 && index < DisplayItems.Count)
                            {
                                <button class="swap-button px-2 py-1 bg-yellow-400 hover:bg-yellow-500 text-black rounded-lg"
                                    @onclick="() => SwapWithNext(index - 1)" title="次のサムネイルと入れ替え">
                                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#212529" stroke-width="2"
                                        stroke-linecap="round" stroke-linejoin="round">
                                        <polyline points="7 17 2 12 7 7" />
                                        <polyline points="17 7 22 12 17 17" />
                                        <line x1="2" y1="12" x2="22" y2="12" />
                                    </svg>
                                </button>
                            }
                        </div>

                        <!-- 右側のサムネイル -->
                        <div class="thumbnail-item relative group thumbnail-container">
                            @{
                                var isMultiPage = IsFileMode && item.PageInfo.Contains("ページ");
                            }

                            <!-- サムネイル画像部分 -->
                            <div class="@(isMultiPage ? "thumbnail-stack" : "")">
                                <div
                                    class="w-24 h-32 flex items-center justify-center overflow-hidden @(isMultiPage ? "stack-layer" : "")">
                                    @if (item.IsLoading)
                                    {
                                        <div class="page-loading w-full h-full"></div>
                                    }
                                    else if (item.HasError)
                                    {
                                        <div class="page-error w-full h-full">
                                            読み込み<br />エラー
                                        </div>
                                    }
                                    else if (!string.IsNullOrEmpty(item.Thumbnail))
                                    {
                                        <img src="@item.Thumbnail"
                                            class="max-w-full max-h-full object-contain border border-neutral-300 @(IsPageMode ? "thumbnail-loaded" : "")"
                                            draggable="false" />
                                    }
                                </div>

                                @if (isMultiPage && item.PageInfo.Contains("ページ"))
                                {
                                    var pageCountMatch = System.Text.RegularExpressions.Regex.Match(item.PageInfo, @"(\d+)ページ");
                                    if (pageCountMatch.Success)
                                    {
                                        <div class="page-count-badge">
                                            @pageCountMatch.Groups[1].Value
                                        </div>
                                    }
                                }
                            </div>

                            <!-- ファイル情報表示 -->
                            <div class="file-info">
                                <div class="file-name" title="@item.DisplayName">
                                    @item.DisplayName
                                </div>
                                @if (IsPageMode && !string.IsNullOrEmpty(item.PageInfo))
                                {
                                    <div class="page-number">
                                        @item.PageInfo
                                    </div>
                                }
                            </div>

                            <!-- サブメニュー -->
                            <div class="menu-overlay absolute top-2 right-2 bg-white shadow rounded-lg p-1 flex-col"
                                style="display: none; z-index: 20;">
                                <button class="text-red-500 hover:text-red-700 p-1" @onclick="() => RemovePage(index)" title="削除">
                                    <i class="fas fa-trash"></i>
                                </button>
                                <button class="text-blue-500 hover:text-blue-700 p-1 mt-1"
                                    @onclick="() => (IsFileMode ? RotateFile(item.Id) : RotatePage(index))" title="回転">
                                    <i class="fa-solid fa-rotate-right"></i>
                                </button>
                                <button class="text-purple-500 hover:text-purple-700 p-1 mt-1"
                                    @onclick="() => ShowPreviewAsync(index)" title="拡大プレビュー">
                                    <i class="fa-solid fa-magnifying-glass"></i>
                                </button>
                                @if (isMultiPage)
                                {
                                    <button class="text-green-500 hover:text-green-700 p-1 mt-1" @onclick="() => ExpandFile(index)"
                                        title="全ページを展開">
                                        <i class="fa-solid fa-expand"></i>
                                    </button>
                                }
                            </div>
                        </div>
                    </div>
                }

                <!-- 最後尾の固定＋ボタン -->
                <div class="non-sortable flex items-center relative insert-button-container"
                    data-position="@DisplayItems.Count">
                    <button
                        class="w-6 h-6 bg-blue-500/60 hover:bg-blue-600 hover:bg-opacity-100 text-white rounded-full flex items-center justify-center insert-button transition-all duration-200"
                        data-position="@DisplayItems.Count" @onclick="@((e) => HandleInsertButtonClick(DisplayItems.Count, e))">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor" class="w-3 h-3">
                            <path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z" />
                        </svg>
                    </button>
                </div>
            }
            else
            {
                <!-- サムネイルが0個の場合は最初の＋ボタンのみ -->
                <div class="flex items-center relative insert-button-container" data-position="0">
                    <button
                        class="w-6 h-6 bg-blue-500/60 hover:bg-blue-600 hover:bg-opacity-100 text-white rounded-full flex items-center justify-center insert-button transition-all duration-200"
                        data-position="0" @onclick="@((e) => HandleInsertButtonClick(0, e))">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor" class="w-3 h-3">
                            <path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z" />
                        </svg>
                    </button>
                </div>
                <!-- 初期状態：ファイル選択を促すメッセージ -->
                <div class="w-full text-center py-20">
                    <p class="text-neutral-500 text-lg mb-4">PDFファイルを選択してください</p>
                    <button class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg"
                        @onclick="OpenFileDialog">
                        ファイルを選択
                    </button>
                </div>
            }
        </div>
    </div>
}
@if (previewIndex >= 0)
{
    <div class="fixed inset-0 flex items-center justify-center z-50 bg-black/70" @onclick="ClosePreview">
        <button class="absolute top-8 right-8 text-3xl text-neutral-200 hover:text-red-400 z-10" @onclick="ClosePreview"
            title="閉じる">
            &times;
        </button>
        @if (isPreviewLoading)
        {
            <div class="flex flex-col items-center justify-center">
                <div class="animate-spin rounded-full h-16 w-16 border-b-2 border-blue-600 mb-4"></div>
                <span class="text-white">プレビュー画像を生成中...</span>
            </div>
        }
        else if (!string.IsNullOrEmpty(previewImageUrl))
        {
            <img src="@previewImageUrl" class="max-w-[90vw] max-h-[90vh] object-contain mx-auto"
                style="width:auto; height:auto;" draggable="false" @onclick:stopPropagation />
        }
        <!-- プレビュー下部の操作バー -->
        <div class="absolute bottom-8 left-1/2 -translate-x-1/2 flex bg-black/60 px-0 rounded-lg min-h-12 shadow-lg"
            @onclick:stopPropagation>
            <div class="flex w-full items-stretch divide-x divide-gray-400 rounded-lg">
                <button
                    class="icon-btn flex-1 flex items-center justify-center py-4 px-4 hover:bg-gray-700 transition rounded-l-lg"
                    @onclick="() => MovePreview(-1)"
                    disabled="@(IsFileMode? CurrentFilePageIndex == 0 : previewIndex == 0)">
                    <i class="text-white fa-solid fa-chevron-left"></i>
                </button>
                <div class="flex-1 px-2 flex items-center justify-center text-white font-bold whitespace-nowrap">
                    @if (IsFileMode && CurrentFilePageCount > 1)
                    {
                        <input type="number" min="1" max="@CurrentFilePageCount" value="@(CurrentFilePageIndex + 1)"
                            class="w-12 h-full text-center rounded bg-gray-800 text-white border border-gray-400 mx-1"
                            style="appearance: none; -moz-appearance: textfield;" @onchange="OnPreviewPageInputChanged" />
                        <span>/ @CurrentFilePageCount</span>
                    }
                </div>
                <button class="icon-btn flex-1 flex items-center justify-center py-4 px-4 hover:bg-gray-700 transition"
                    @onclick="() => MovePreview(1)"
                    disabled="@(IsFileMode? CurrentFilePageIndex == CurrentFilePageCount - 1 : (DisplayItems != null && DisplayItems.Any() ? previewIndex == DisplayItems.Count - 1 : true))">
                    <i class="text-white fa-solid fa-chevron-right"></i>
                </button>
                <button class="icon-btn flex-1 flex items-center justify-center py-4 px-4 hover:bg-gray-700 transition"
                    @onclick="RotatePreviewLeft">
                    <i class="text-white fa-solid fa-rotate-left"></i>
                </button>
                <button class="icon-btn flex-1 flex items-center justify-center py-4 px-4 hover:bg-gray-700 transition"
                    @onclick="RotatePreviewRight">
                    <i class="text-white fa-solid fa-rotate-right"></i>
                </button>
                <button
                    class="icon-btn flex-1 flex items-center justify-center py-4 px-4 hover:bg-gray-700 transition rounded-r-lg"
                    @onclick="() => RemovePage(previewIndex)">
                    <i class="text-white fa-solid fa-trash"></i>
                </button>
            </div>
        </div>
    </div>
}
@if (showMergedResult && !string.IsNullOrEmpty(mergedPdfUrl))
{
    <!-- 結果表示モード -->
    <div class="fixed top-0 left-0 w-full bg-gray-800 text-white shadow z-50">
        <div class="flex items-center justify-between px-4 py-2">
            <span class="text-lg font-semibold">結合結果</span>
            <div class="flex gap-2">
                <button class="bg-neutral-500 hover:bg-neutral-600 text-white font-bold py-2 px-4 rounded-lg"
                    @onclick="BackToEdit">
                    編集に戻る
                </button>
                <button class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg" @onclick="StartNew">
                    新規作成
                </button>
            </div>
        </div>
    </div>

    <div class="pt-16">
        <div class="p-6">
            <iframe src="@mergedPdfUrl" class="w-full h-screen border-none" style="min-height: 800px;">
                お使いのブラウザはPDFの表示をサポートしていません。
                <a href="@mergedPdfUrl" target="_blank">こちらをクリック</a>してPDFを開いてください。
            </iframe>
        </div>
    </div>
}
@if (!IsFilesLoaded && !showMergedResult)
{
    <!-- 初期画面：ファイル選択 -->
    <div class="flex items-center justify-center min-h-screen bg-neutral-100">
        <div class="text-center">
            <h1 class="text-4xl font-bold text-neutral-800 mb-8">PDF Merger</h1>
            <div class="mb-8">
                <button class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg text-lg"
                    @onclick="OpenFileDialog">
                    PDFファイルを選択
                </button>
            </div>
            <div class="text-neutral-600">
                <p>✅ 複数のPDFファイルを選択して結合できます</p>
                <p class="text-sm mt-2">✅ <strong>元のページ番号が正しく表示されます</strong></p>
                <p class="text-sm mt-2">✅ ファイル単位・ページ単位の表示切り替え対応</p>
                <p class="text-sm mt-2">最大ファイルサイズ: 50MB</p>
            </div>

            @if (isLoading)
            {
                <div class="mt-8">
                    <div class="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto"></div>
                    <p class="mt-4 text-neutral-600">読み込み中... @progress%</p>
                </div>
            }
        </div>
    </div>
}

<!-- エラーメッセージ表示 -->
@if (!string.IsNullOrEmpty(errorMessage))
{
    <div class="fixed bottom-4 right-4 bg-red-500 text-white px-4 py-2 rounded-lg shadow z-50 max-w-md">
        <div class="flex items-start gap-2">
            <div class="flex-1">
                @errorMessage
            </div>
            <button class="text-white hover:text-neutral-200 ml-2" @onclick="ClearErrorMessage">
                ✕
            </button>
        </div>
    </div>
}

<!-- ファイル選択用の隠しinput -->
<InputFile OnChange="HandleFileSelectionAsync" multiple style="display: none;" id="fileInput" />
<InputFile OnChange="HandleInsertFileSelectionAsync" style="display: none;" id="insertFileInput" />


@code {
    protected override void OnInitialized()
    {
        PdfDataService.OnChange += OnServiceChanged;
    }

    private void OnServiceChanged()
    {
        InvokeAsync(StateHasChanged);
    }

    public void Dispose()
    {
        PdfDataService.OnChange -= OnServiceChanged;
    }
    private bool isLoading = false;
    private bool showMergedResult = false;
    private int progress = 0;
    private string? mergedPdfUrl;
    private string? errorMessage;

    // 統一アーキテクチャ対応プロパティ
    private DisplayMode CurrentDisplayMode => PdfDataService.GetModel().CurrentMode;
    private List<DisplayItem> DisplayItems => PdfDataService.GetDisplayItems();
    private bool IsFilesLoaded => DisplayItems.Any();
    private bool IsFileMode => CurrentDisplayMode == DisplayMode.File;
    private bool IsPageMode => CurrentDisplayMode == DisplayMode.Page;

    private int previewIndex = -1;

    private string? previewImageUrl = null;
    private bool isPreviewLoading = false;
    // ファイル単位表示時の現在ページ番号（0始まり）
    private int CurrentFilePageIndex => GetCurrentFilePageIndex();
    // ファイル単位表示時の総ページ数
    private int CurrentFilePageCount => GetCurrentFilePageCount();

    // ファイル単位表示時のファイル内ページ番号（0始まり）
    private int filePageIndex = 0;
    private int GetCurrentFilePageIndex()
    {
        if (!IsFileMode || previewIndex < 0 || previewIndex >= DisplayItems.Count)
            return 0;
        return filePageIndex;
    }
    private int GetCurrentFilePageCount()
    {
        if (!IsFileMode || previewIndex < 0 || previewIndex >= DisplayItems.Count)
            return 1;
        return DisplayItems[previewIndex].PageCount;
    }
    private async Task MovePreview(int direction)
    {
        if (IsFileMode)
        {
            var pageCount = DisplayItems[previewIndex].PageCount;
            var nextPage = filePageIndex + direction;
            if (nextPage >= 0 && nextPage < pageCount)
            {
                filePageIndex = nextPage;
                await ShowPreviewAsync(previewIndex, filePageIndex);
            }
        }
        else
        {
            var nextIndex = previewIndex + direction;
            if (nextIndex >= 0 && nextIndex < DisplayItems.Count)
            {
                await ShowPreviewAsync(nextIndex);
            }
        }
    }
    private async Task OnPreviewPageInputChanged(ChangeEventArgs e)
    {
        if (!IsFileMode) return;

        if (int.TryParse(e.Value?.ToString(), out int inputPage))
        {
            // 1以上、最大ページ数以下のみ有効
            if (inputPage >= 1 && inputPage <= CurrentFilePageCount)
            {
                filePageIndex = inputPage - 1;
                await ShowPreviewAsync(previewIndex, filePageIndex);
            }
        }
    }
    private async Task RotatePreviewLeft()
    {
        if (previewIndex >= 0 && previewIndex < DisplayItems.Count)
        {
            await PdfDataService.RotateItemAsync(previewIndex, -90);
            await ShowPreviewAsync(previewIndex);
        }
    }

    private async Task RotatePreviewRight()
    {
        if (previewIndex >= 0 && previewIndex < DisplayItems.Count)
        {
            await PdfDataService.RotateItemAsync(previewIndex, 90);
            await ShowPreviewAsync(previewIndex);
        }
    }


    private async Task ShowPreviewAsync(int fileIndex, int pageIndex = 0)
    {
        previewIndex = fileIndex;
        filePageIndex = pageIndex;
        previewImageUrl = null;
        isPreviewLoading = true;
        StateHasChanged();

        try
        {
            if (IsFileMode)
            {
                // ファイル単位表示時も GetPreviewImageAsync を使う（pageIndex を渡す）
                previewImageUrl = await PdfDataService.GetPreviewImageAsync(DisplayItems[fileIndex].Id, pageIndex);
            }
            else
            {
                // ページ単位表示時は従来通り
                previewImageUrl = await PdfDataService.GetPreviewImageAsync(DisplayItems[fileIndex].Id);
            }
        }
        catch
        {
            // 失敗時はサムネイル表示
            previewImageUrl = DisplayItems[fileIndex].Thumbnail;
        }
        isPreviewLoading = false;
        StateHasChanged();
    }


    private void ClosePreview()
    {
        previewIndex = -1;
        StateHasChanged();
    }
    // 表示モード切り替えメソッド
    private async Task SwitchToFileMode()
    {
        if (IsFileMode) return;
        PdfDataService.SwitchDisplayMode(DisplayMode.File);
        StateHasChanged();
        await Task.Delay(100); // DOM更新待ち

        // JavaScript再初期化
        try
        {
            await JSRuntime.InvokeVoidAsync("initializeDragDrop");
            await JSRuntime.InvokeVoidAsync("initializeSortable");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error reinitializing JS: {ex.Message}");
        }

        Console.WriteLine($"Switched to File mode. Items count: {DisplayItems.Count}");
    }
    // PageItem全件をコンソールに出力するテストボタン用メソッド
    private void PrintAllPageItems()
    {
        var model = PdfDataService.GetModel();
        if (model != null && model.Pages != null)
        {
            Console.WriteLine($"=== PageItem一覧 ({model.Pages.Count}) ===");
            for (int i = 0; i < model.Pages.Count; i++)
            {
                var p = model.Pages[i];
                Console.WriteLine($"[{i}] FileId={p.FileId}, Page={p.OriginalPageNumber}");
            }
        }
        else
        {
            Console.WriteLine("PageItemリストが取得できませんでした");
        }
    }
    private async Task SwitchToPageMode()
    {
        if (IsPageMode) return;
        Console.WriteLine("Switching to Page mode");

        // 即座にページ単位モードに切り替える（読み込み完了を待たない）
        PdfDataService.SwitchDisplayMode(DisplayMode.Page);
        StateHasChanged();
        await Task.Delay(100); // DOM更新待ち

        // JavaScript再初期化
        try
        {
            await JSRuntime.InvokeVoidAsync("initializeDragDrop");
            await JSRuntime.InvokeVoidAsync("initializeSortable");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error reinitializing JS: {ex.Message}");
        }

        // バックグラウンドで残りのページ読み込みを継続（UI をブロックしない）
        _ = Task.Run(async () =>
        {
            try
            {
                await PdfDataService.EnsureAllPagesLoadedAsync();
                await InvokeAsync(() =>
        {
            StateHasChanged(); // 読み込み完了時にUIを更新
        });
                Console.WriteLine("Background page loading completed");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error in background page loading: {ex.Message}");
                await InvokeAsync(() =>
        {
            errorMessage = $"一部ページの読み込みに失敗しました。問題のあるページは「読み込みエラー」と表示されます。";
            StateHasChanged();
        });
            }
        });
    }

    // ファイル選択処理
    private async Task HandleFileSelectionAsync(InputFileChangeEventArgs e)
    {
        if (e.FileCount == 0)
        {
            Console.WriteLine("No files selected");
            return;
        }

        isLoading = true;
        progress = 0;
        errorMessage = null;
        const long maxFileSize = 52428800; // 50MB

        var fileCount = 0;
        foreach (var file in e.GetMultipleFiles())
        {
            fileCount++;
            try
            {
                using var stream = file.OpenReadStream(maxFileSize);
                using var memoryStream = new MemoryStream();
                var buffer = new byte[8192];
                long totalBytesRead = 0;
                int bytesRead;

                while ((bytesRead = await stream.ReadAsync(buffer, 0, buffer.Length)) > 0)
                {
                    await memoryStream.WriteAsync(buffer, 0, bytesRead);
                    totalBytesRead += bytesRead;

                    progress = (int)((totalBytesRead / (double)file.Size) * 100);
                    StateHasChanged();
                }

                var pdfData = memoryStream.ToArray();

                // 統一データサービスを使用してファイルを追加
                var success = await PdfDataService.AddPdfFileAsync(file.Name, pdfData);
                if (!success)
                {
                    Console.WriteLine($"Failed to add file {file.Name}");
                    errorMessage = $"ファイル処理に失敗しました: {file.Name} - PDFファイルが破損しているか、サポートされていない形式の可能性があります。";
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error processing file {file.Name}: {ex.Message}");
                errorMessage = $"ファイル処理エラー: {file.Name} - {ex.Message}";
            }
        }

        isLoading = false;
        StateHasChanged();
    }

    // PDF結合処理
    private async Task MergePDFs()
    {
        try
        {
            Console.WriteLine("=== PDF結合開始 ===");

            var mergeData = PdfDataService.GetMergeData();
            if (mergeData.Count == 0)
            {
                errorMessage = "No PDF files to merge.";
                Console.WriteLine("No files selected.");
                return;
            }

            errorMessage = null;
            isLoading = true;
            StateHasChanged();

            // 並び替えられたページデータを使用してPDFを結合
            mergedPdfUrl = await JSRuntime.InvokeAsync<string>("mergePDFPages", mergeData);

            if (!string.IsNullOrEmpty(mergedPdfUrl))
            {
                // 結合成功：結果表示モードに切り替え
                showMergedResult = true;
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"An error occurred: {ex.Message}");
            errorMessage = "An error occurred while merging PDFs. Please try again.";
        }
        finally
        {
            isLoading = false;
            StateHasChanged();
        }
    }

    // アイテム削除
    private void RemovePage(int index)
    {

        try
        {
            PdfDataService.RemoveItem(index);
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error removing item {index}: {ex.Message}");
            errorMessage = $"削除に失敗しました: {ex.Message}";
        }
    }

    // ファイルダイアログを開く
    private async Task OpenFileDialog()
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("openFileDialog", "fileInput");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error opening file dialog: {ex.Message}");
            errorMessage = $"ファイル選択ダイアログの表示に失敗しました: {ex.Message}";
        }
    }

    // その他のメソッド
    private void BackToEdit()
    {
        showMergedResult = false;
        StateHasChanged();
    }

    private void StartNew()
    {
        PdfDataService.Clear();
        showMergedResult = false;
        mergedPdfUrl = null;
        errorMessage = null;
        StateHasChanged();
    }

    private void ClearErrorMessage()
    {
        errorMessage = null;
        StateHasChanged();
    }

    // 隣接サムネイルとの入れ替え機能
    private void SwapWithNext(int index)
    {
        try
        {
            var currentCount = DisplayItems.Count;

            if (index >= 0 && index < currentCount - 1)
            {
                var nextIndex = index + 1;
                Console.WriteLine($"Swapping {index} with {nextIndex}");

                // 統一データサービスを使用して入れ替え
                PdfDataService.SwapItems(index, nextIndex);
                StateHasChanged();

                Console.WriteLine($"Swap completed successfully");
            }
            else
            {
                Console.WriteLine($"Invalid swap: index={index}, count={currentCount}");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error in SwapWithNext: {ex.Message}");
            errorMessage = $"サムネイルの入れ替えに失敗しました: {ex.Message}";
        }
    }

    // 回転処理
    private async Task RotatePage(int index)
    {
        if (index >= 0 && index < DisplayItems.Count)
        {
            try
            {
                // 統一データサービスを使用して回転
                await PdfDataService.RotateItemAsync(index);
                StateHasChanged();
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error rotating item {index}: {ex.Message}");
                errorMessage = $"アイテム {index + 1} の回転に失敗しました: {ex.Message}";
            }
        }
    }

    private async Task RotateFile(string fileId)
    {
        await PdfDataService.RotateFileAsync(fileId);
        StateHasChanged();
    }

    private async Task RotateAllLeft()
    {
        for (int i = 0; i < DisplayItems.Count; i++)
        {
            // 左回転（90度）
            await PdfDataService.RotateItemAsync(i, -90);
        }
        StateHasChanged();
    }

    private async Task RotateAllRight()
    {
        for (int i = 0; i < DisplayItems.Count; i++)
        {
            await PdfDataService.RotateItemAsync(i);
        }
        StateHasChanged();
    }


    // ファイル展開機能（ファイル単位表示から特定のファイルの全ページを展開）
    private async Task ExpandFile(int fileIndex)
    {
        if (fileIndex >= 0 && fileIndex < DisplayItems.Count && IsFileMode)
        {
            try
            {
                // 統一データサービスを使用してファイル展開
                await PdfDataService.ExpandFileAsync(fileIndex);

                // ページ単位表示に切り替え
                await SwitchToPageMode();
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error expanding file: {ex.Message}");
                errorMessage = $"ファイル展開に失敗しました: {ex.Message}";
            }
        }
    }

    // 挿入ボタンクリック処理
    private async Task HandleInsertButtonClick(int position, MouseEventArgs e)
    {

        try
        {
            // JavaScriptの挿入メニューを表示
            await JSRuntime.InvokeVoidAsync("showInsertMenuAtExactPosition", position, e.ClientX, e.ClientY);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error showing insert menu: {ex.Message}");
            errorMessage = $"メニュー表示に失敗しました: {ex.Message}";
        }
    }

    // 静的インスタンスで現在のコンポーネントを参照（JavaScript連携用）
    private static Merge? _currentInstance;

    // JavaScript から呼び出される並び替えメソッド
    [JSInvokable("UpdateOrder")]
    public static async Task UpdateOrder(int oldIndex, int newIndex)
    {
        Console.WriteLine($"UpdateOrder called with oldIndex: {oldIndex}, newIndex: {newIndex}");

        if (_currentInstance != null)
        {
            Console.WriteLine($"Current instance found, calling UpdateOrderInternal");
            await _currentInstance.UpdateOrderInternal(oldIndex, newIndex);
        }
        else
        {
            Console.WriteLine($"ERROR: Current instance is null!");
        }
    }

    // 実際の並び替え処理
    private async Task UpdateOrderInternal(int oldIndex, int newIndex)
    {
        try
        {
            Console.WriteLine($"UpdateOrderInternal called: {oldIndex} -> {newIndex}");

            if (oldIndex >= 0 && oldIndex < DisplayItems.Count &&
            newIndex >= 0 && newIndex < DisplayItems.Count &&
            oldIndex != newIndex)
            {
                // 統一データサービスを使用して並び替え
                PdfDataService.MoveItem(oldIndex, newIndex);

                Console.WriteLine($"Successfully moved item from {oldIndex} to {newIndex}");

                // DOM更新
                await InvokeAsync(async () =>
                {
                    StateHasChanged();
                    await Task.Delay(100);
                    await JSRuntime.InvokeVoidAsync("initializeSortable");
                });
            }
            else
            {
                Console.WriteLine($"Invalid move operation: oldIndex={oldIndex}, newIndex={newIndex}, count={DisplayItems.Count}");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error in UpdateOrderInternal: {ex.Message}");
            errorMessage = $"並び替えに失敗しました: {ex.Message}";
        }
    }

    // JavaScript から呼び出される空白ページ挿入メソッド
    [JSInvokable("InsertBlankPageFromJS")]
    public static async Task InsertBlankPageFromJS(int position)
    {
        if (_currentInstance != null)
        {
            await _currentInstance.InsertBlankPage(position);
        }
    }

    // JavaScript から呼び出されるPDF挿入メソッド
    [JSInvokable("InsertPdfAtPositionFromJS")]
    public static async Task InsertPdfAtPositionFromJS(int position)
    {
        if (_currentInstance != null)
        {
            await _currentInstance.InsertPdfAtPosition(position);
        }
    }

    // 空白ページを挿入
    private async Task InsertBlankPage(int position)
    {
        try
        {
            // 統一データサービスを使用して空白ページ挿入
            await PdfDataService.InsertBlankPageAsync(position);
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error inserting blank page: {ex.Message}");
            errorMessage = $"空白ページの挿入に失敗しました: {ex.Message}";
        }
    }

    // PDF挿入
    private async Task InsertPdfAtPosition(int position)
    {
        try
        {
            Console.WriteLine($"Opening file dialog for PDF insertion at position {position}");

            // JavaScriptでファイルダイアログを開く
            await JSRuntime.InvokeVoidAsync("openInsertFileDialog", "insertFileInput");

            // 挿入位置を保存（ファイル選択後に使用）
            insertPosition = position;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error opening insert file dialog: {ex.Message}");
            errorMessage = $"ファイル選択ダイアログの表示に失敗しました: {ex.Message}";
        }
    }

    private int insertPosition = -1;

    // 挿入用ファイル選択処理
    private async Task HandleInsertFileSelectionAsync(InputFileChangeEventArgs e)
    {
        if (e.FileCount > 0 && insertPosition >= 0)
        {
            try
            {
                // 挿入前のPageItemリストを出力
                var model = PdfDataService.GetModel();
                Console.WriteLine("=== 挿入前 PageItem一覧 ===");
                for (int i = 0; i < model.Pages.Count; i++)
                {
                    var p = model.Pages[i];
                    Console.WriteLine($"[{i}] FileId={p.FileId}, Page={p.OriginalPageNumber}");
                }

                var file = e.GetMultipleFiles().First();

                using var stream = file.OpenReadStream(52428800); // 50MB
                using var memoryStream = new MemoryStream();
                await stream.CopyToAsync(memoryStream);
                var pdfData = memoryStream.ToArray();

                // ファイル単位表示の場合、insertPositionはファイル単位のインデックス
                // ページ単位の挿入位置に変換する必要がある
                int pageInsertPosition = insertPosition;
                if (IsFileMode)
                {
                    // ファイル単位表示の場合、挿入位置は「何番目のファイルの後か」
                    // そのファイルまでのページ数を合計してページ挿入位置に変換
                    pageInsertPosition = 0;
                    for (int i = 0; i < insertPosition && i < DisplayItems.Count; i++)
                    {
                        pageInsertPosition += DisplayItems[i].PageCount;
                    }
                }

                Console.WriteLine($"insertPosition={insertPosition}, pageInsertPosition={pageInsertPosition}");

                // 統一データサービスを使用してファイルを挿入
                await PdfDataService.InsertPdfFileAsync(pageInsertPosition, file.Name, pdfData);
                StateHasChanged();

                insertPosition = -1; // リセット

                // 挿入後のPageItemリストを出力
                model = PdfDataService.GetModel();
                Console.WriteLine("=== 挿入後 PageItem一覧 ===");
                for (int i = 0; i < model.Pages.Count; i++)
                {
                    var p = model.Pages[i];
                    Console.WriteLine($"[{i}] FileId={p.FileId}, Page={p.OriginalPageNumber}");
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error inserting file: {ex.Message}");
                errorMessage = $"ファイル挿入に失敗しました: {ex.Message}";
                insertPosition = -1; // リセット
            }
        }
    }

    protected override void OnAfterRender(bool firstRender)
    {
        if (firstRender)
        {
            _currentInstance = this;
        }

        // 毎回ドラッグ&ドロップとソート機能を再初期化（DOM更新時に必要）
        if (IsFilesLoaded && DisplayItems.Any())
        {
            InvokeAsync(async () =>
            {
                try
                {
                    await Task.Delay(50); // DOM更新完了を待つ
                    await JSRuntime.InvokeVoidAsync("initializeDragDrop");
                    await JSRuntime.InvokeVoidAsync("initializeSortable");
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Error initializing interactions: {ex.Message}");
                }
            });
        }
    }
}
