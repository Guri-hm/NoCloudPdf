@page "/merge"
@inject IJSRuntime JSRuntime
@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.AspNetCore.Components.Web

<PageTitle>Merge</PageTitle>

@if (isFilesLoaded && !showMergedResult)
{
    <!-- 上部固定バー（編集モード） -->
    <div class="fixed top-0 left-0 w-full bg-gray-800 text-white shadow-md z-50">
        <div class="flex items-center justify-between px-4 py-2">
            <span class="text-lg font-semibold">PDF操作</span>
            <div class="flex gap-2">
                <!-- テスト用並び替えボタン -->
                <button class="bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 px-4 rounded"
                    @onclick="TestSwapFirstTwo">
                    テスト：1↔2
                </button>
                <button class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded" @onclick="MergePDFs">
                    結合
                </button>
            </div>
        </div>
    </div>

    <!-- サムネイル編集エリア -->
    <div class="pt-16"> <!-- 上部バーの高さ分余白 -->
        <div id="sortable-container" class="flex flex-wrap gap-2 p-4">
            @if (pageThumbnails != null && pageThumbnails.Any())
            {
                @* 各サムネイルの左側に＋ボタンを配置（並び替え対象） *@
                @for (int i = 0; i < pageThumbnails.Count; i++)
                {
                    var index = i;

                    <div class="sortable-item-container flex items-center gap-2" data-index="@i" data-id="@i">
                        @* 左側の＋ボタン *@
                        <div class="flex items-center">
                            <button
                                class="w-8 h-8 bg-blue-500 hover:bg-blue-600 text-white rounded-full flex items-center justify-center text-lg font-bold shadow-md"
                                @onclick="() => ToggleInsertMenu(i)">
                                +
                            </button>
                            @if (showInsertMenuIndex == i)
                            {
                                <div class="fixed inset-0 z-40" @onclick="() => ToggleInsertMenu(-1)"></div>
                                <div class="absolute top-10 left-0 bg-white border border-gray-300 rounded shadow-lg min-w-48 z-50">
                                    <button class="w-full px-4 py-2 text-left hover:bg-gray-100 border-b border-gray-200"
                                        @onclick="() => InsertBlankPage(i)">
                                        📄 空白ページの挿入
                                    </button>
                                    <button class="w-full px-4 py-2 text-left hover:bg-gray-100"
                                        @onclick="() => InsertPdfAtPosition(i)">
                                        📁 PDFを選択して挿入
                                    </button>
                                </div>
                            }
                        </div>

                        @* 右側のサムネイル *@
                        <div class="thumbnail-item relative group p-2">
                            <div class="w-24 h-32 flex items-center justify-center overflow-hidden">
                                <img src="@pageThumbnails[i]" class="max-w-full max-h-full object-contain border border-gray-300"
                                    draggable="false" />
                            </div>

                            <!-- サブメニュー -->
                            <div class="menu-overlay absolute top-0 right-0 bg-white shadow-md rounded p-1 flex-col"
                                style="display: none;">
                                <button class="text-red-500 hover:text-red-700 p-1" @onclick="() => RemovePage(index)">
                                    <i class="fas fa-trash"></i>
                                </button>
                                <button class="text-blue-500 hover:text-blue-700 p-1 mt-1" @onclick="() => RotatePage(index)">
                                    <i class="fa-solid fa-rotate-right"></i>
                                </button>
                            </div>
                        </div>
                    </div>
                }

                @* 最後尾の固定＋ボタン *@
                <div class="non-sortable flex items-center">
                    <button
                        class="w-8 h-8 bg-blue-500 hover:bg-blue-600 text-white rounded-full flex items-center justify-center text-lg font-bold shadow-md"
                        @onclick="() => ToggleInsertMenu(pageThumbnails.Count)">
                        +
                    </button>
                    @if (showInsertMenuIndex == pageThumbnails.Count)
                    {
                        <div class="fixed inset-0 z-40" @onclick="() => ToggleInsertMenu(-1)"></div>
                        <div class="absolute top-10 left-0 bg-white border border-gray-300 rounded shadow-lg min-w-48 z-50">
                            <button class="w-full px-4 py-2 text-left hover:bg-gray-100 border-b border-gray-200"
                                @onclick="() => InsertBlankPage(pageThumbnails.Count)">
                                📄 空白ページの挿入
                            </button>
                            <button class="w-full px-4 py-2 text-left hover:bg-gray-100"
                                @onclick="() => InsertPdfAtPosition(pageThumbnails.Count)">
                                📁 PDFを選択して挿入
                            </button>
                        </div>
                    }
                </div>
            }
            else
            {
                @* サムネイルが0個の場合は最初の＋ボタンのみ *@
                <div class="flex items-center">
                    <button
                        class="w-8 h-8 bg-blue-500 hover:bg-blue-600 text-white rounded-full flex items-center justify-center text-lg font-bold shadow-md"
                        @onclick="() => ToggleInsertMenu(0)">
                        +
                    </button>
                    @if (showInsertMenuIndex == 0)
                    {
                        <div class="fixed inset-0 z-40" @onclick="() => ToggleInsertMenu(-1)"></div>
                        <div class="absolute top-10 left-0 bg-white border border-gray-300 rounded shadow-lg min-w-48 z-50">
                            <button class="w-full px-4 py-2 text-left hover:bg-gray-100 border-b border-gray-200"
                                @onclick="() => InsertBlankPage(0)">
                                📄 空白ページの挿入
                            </button>
                            <button class="w-full px-4 py-2 text-left hover:bg-gray-100" @onclick="() => InsertPdfAtPosition(0)">
                                📁 PDFを選択して挿入
                            </button>
                        </div>
                    }
                </div>
            }
        </div>
    </div>
}

@* 結合結果表示画面 *@
@if (showMergedResult && !string.IsNullOrEmpty(mergedPdfUrl))
{
    <!-- 上部固定バー（結果表示モード） -->
    <div class="fixed top-0 left-0 w-full bg-gray-800 text-white shadow-md z-50">
        <div class="flex items-center justify-between px-4 py-2">
            <button class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded" @onclick="BackToEdit">
                ← 編集に戻る
            </button>
            <span class="text-lg font-semibold">結合結果プレビュー</span>
            <div></div> <!-- 右側のスペース確保 -->
        </div>
    </div>

    <!-- メインコンテンツエリア -->
    <div class="flex h-screen pt-16"> <!-- 上部バーの高さ分余白 -->
        <!-- 左側：PDFプレビューエリア -->
        <div class="flex-1 bg-gray-100 overflow-y-auto">
            <div class="p-4">
                <div id="pdf-preview-container" class="max-w-4xl mx-auto">
                    <iframe src="@mergedPdfUrl" class="w-full h-screen border-none" style="min-height: 800px;">
                    </iframe>
                </div>
            </div>
        </div>

        <!-- 右側：操作パネル -->
        <div class="w-80 bg-white border-l border-gray-300 p-6 overflow-y-auto">
            <div class="space-y-4">
                <h3 class="text-lg font-semibold text-gray-800 mb-4">操作メニュー</h3>

                <!-- ダウンロードボタン -->
                <div class="bg-blue-50 p-4 rounded-lg">
                    <h4 class="font-medium text-gray-700 mb-2">ファイル操作</h4>
                    <a href="@mergedPdfUrl" target="_blank" download="merged.pdf"
                        class="w-full bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-4 rounded flex items-center justify-center gap-2">
                        <i class="fas fa-download"></i>
                        PDFをダウンロード
                    </a>
                </div>

                <!-- 共有機能（将来の拡張用） -->
                <div class="bg-green-50 p-4 rounded-lg">
                    <h4 class="font-medium text-gray-700 mb-2">共有</h4>
                    <button
                        class="w-full bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded flex items-center justify-center gap-2"
                        @onclick="SharePDF">
                        <i class="fas fa-share"></i>
                        リンクをコピー
                    </button>
                </div>

                <!-- 印刷機能 -->
                <div class="bg-gray-50 p-4 rounded-lg">
                    <h4 class="font-medium text-gray-700 mb-2">出力</h4>
                    <button
                        class="w-full bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded flex items-center justify-center gap-2"
                        @onclick="PrintPDF">
                        <i class="fas fa-print"></i>
                        印刷
                    </button>
                </div>

                <!-- 新しい編集 -->
                <div class="bg-orange-50 p-4 rounded-lg">
                    <h4 class="font-medium text-gray-700 mb-2">新規作成</h4>
                    <button
                        class="w-full bg-orange-500 hover:bg-orange-600 text-white font-bold py-2 px-4 rounded flex items-center justify-center gap-2"
                        @onclick="StartNew">
                        <i class="fas fa-plus"></i>
                        新しいPDFを作成
                    </button>
                </div>

                <!-- ファイル情報 -->
                <div class="bg-gray-50 p-4 rounded-lg mt-6">
                    <h4 class="font-medium text-gray-700 mb-2">ファイル情報</h4>
                    <div class="text-sm text-gray-600 space-y-1">
                        <p><span class="font-medium">ページ数:</span> @pdfPageDataList.Count</p>
                        <p><span class="font-medium">作成日時:</span> @DateTime.Now.ToString("yyyy/MM/dd HH:mm")</p>
                    </div>
                </div>
            </div>
        </div>
    </div>
}

@* 初期ドロップゾーン *@
@if (!isFilesLoaded && !isLoading)
{
    <div id="drop-zone"
        class="flex items-center justify-center w-full h-screen border-2 border-dashed border-gray-400 cursor-pointer hover:bg-gray-100"
        @onclick="OpenFileDialog">
        <div class="text-center">
            <span class="text-2xl text-gray-500">ファイルをここにドラッグ＆ドロップ</span>
            <p class="text-sm text-gray-500 mt-2">またはクリックしてファイルを選択</p>
        </div>
    </div>
}

@* ローディング画面 *@
@if (isLoading)
{
    <div class="flex items-center justify-center w-full h-screen">
        <div class="text-center">
            <div class="w-64 h-4 bg-gray-200 rounded-full overflow-hidden">
                <div class="h-full bg-blue-500" style="width: @progress%;"></div>
            </div>
            <p class="text-sm text-gray-500 mt-2">読み込み中...</p>
        </div>
    </div>
}

@* エラーメッセージ *@
@if (!string.IsNullOrEmpty(errorMessage))
{
    <div class="fixed top-20 right-4 bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded z-50">
        @errorMessage
    </div>
}

<InputFile OnChange="HandleFileSelectionAsync" multiple="true" maxsize="52428800" style="display: none;"
    id="fileInput" />
<InputFile OnChange="HandleInsertFileSelectionAsync" style="display: none;" id="insertFileInput" />

<style>
    .thumbnail-item:hover .menu-overlay {
        display: flex !important;
    }

    .sortable-item-container {
        cursor: move;
    }
</style>

@code {
    private bool isFilesLoaded = false;
    private bool isLoading = false;
    private bool showMergedResult = false; // 結合結果表示フラグ
    private int progress = 0;

    private List<byte[]> pdfDataList = new();
    private List<string> pdfPageDataList = new();
    private string? mergedPdfUrl;
    private string? errorMessage;
    private List<string> pageThumbnails = new();

    // 静的インスタンスで現在のコンポーネントを参照（並び替え用）
    private static Merge? _currentInstance;

    // JavaScript から呼び出される並び替えメソッド
    [JSInvokable("UpdateOrder")]
    public static async Task UpdateOrder(int oldIndex, int newIndex)
    {
        Console.WriteLine($"UpdateOrder called with oldIndex: {oldIndex}, newIndex: {newIndex}");

        if (_currentInstance != null)
        {
            Console.WriteLine($"Current instance found, calling UpdateOrderInternal");
            await _currentInstance.UpdateOrderInternal(oldIndex, newIndex);
        }
        else
        {
            Console.WriteLine($"ERROR: Current instance is null!");
        }
    }
    // 処理中フラグを追加
    private bool isUpdatingOrder = false;
    // 実際の並び替え処理（DOM状態をBlazorに完全同期）
    // 実際の並び替え処理（完全修正版）
    private async Task UpdateOrderInternal(int oldIndex, int newIndex)
    {
        // 排他制御
        if (isUpdatingOrder)
        {
            Console.WriteLine("Order update already in progress, skipping...");
            return;
        }

        isUpdatingOrder = true;

        try
        {
            Console.WriteLine($"UpdateOrderInternal called: {oldIndex} -> {newIndex}");

            if (oldIndex >= 0 && oldIndex < pageThumbnails.Count &&
            newIndex >= 0 && newIndex < pageThumbnails.Count &&
            oldIndex != newIndex)
            {
                Console.WriteLine($"Moving data from index {oldIndex} to {newIndex}");

                // デバッグ：移動前の状態
                Console.WriteLine("=== BEFORE MOVE ===");
                for (int i = 0; i < pageThumbnails.Count; i++)
                {
                    var hash = pageThumbnails[i].GetHashCode();
                    Console.WriteLine($"Index {i}: Hash={hash}");
                }

                // シンプルで確実な方法：C#のCollectionsAPIを使用
                void MoveItem<T>(List<T> list, int from, int to)
                {
                    var item = list[from];
                    list.RemoveAt(from);
                    list.Insert(to, item);
                }

                // 実際のデータ移動
                MoveItem(pageThumbnails, oldIndex, newIndex);
                MoveItem(pdfPageDataList, oldIndex, newIndex);

                Console.WriteLine($"Moved item from {oldIndex} to {newIndex}");

                // デバッグ：移動後の状態
                Console.WriteLine("=== AFTER MOVE ===");
                for (int i = 0; i < pageThumbnails.Count; i++)
                {
                    var hash = pageThumbnails[i].GetHashCode();
                    Console.WriteLine($"Index {i}: Hash={hash}");
                }

                Console.WriteLine($"Data reordered successfully: {oldIndex} -> {newIndex}");

                // DOM更新
                await InvokeAsync(async () =>
                {
                    StateHasChanged();
                    await Task.Delay(100);
                    await JSRuntime.InvokeVoidAsync("initializeSortable");
                });

                Console.WriteLine("DOM management returned to Blazor");
            }
            else
            {
                Console.WriteLine($"Invalid move operation: oldIndex={oldIndex}, newIndex={newIndex}, count={pageThumbnails.Count}");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error in UpdateOrderInternal: {ex.Message}");
        }
        finally
        {
            isUpdatingOrder = false;
        }
    }

    private async Task TestSwapFirstTwo()
    {
        Console.WriteLine("=== テスト用並び替え開始 ===");

        if (pageThumbnails.Count >= 2)
        {
            Console.WriteLine($"Before swap - Thumbnails count: {pageThumbnails.Count}");
            Console.WriteLine($"Before swap - First thumbnail: {pageThumbnails[0].Substring(0, 50)}...");
            Console.WriteLine($"Before swap - Second thumbnail: {pageThumbnails[1].Substring(0, 50)}...");

            // 1. データを入れ替え
            var firstThumbnail = pageThumbnails[0];
            var firstPageData = pdfPageDataList[0];

            pageThumbnails[0] = pageThumbnails[1];
            pageThumbnails[1] = firstThumbnail;

            pdfPageDataList[0] = pdfPageDataList[1];
            pdfPageDataList[1] = firstPageData;

            Console.WriteLine($"After swap - First thumbnail: {pageThumbnails[0].Substring(0, 50)}...");
            Console.WriteLine($"After swap - Second thumbnail: {pageThumbnails[1].Substring(0, 50)}...");

            // 2. DOM更新
            Console.WriteLine("Calling StateHasChanged...");
            StateHasChanged();

            // 3. Sortable再初期化
            await Task.Delay(100);
            Console.WriteLine("Reinitializing sortable...");
            await JSRuntime.InvokeVoidAsync("initializeSortable");

            Console.WriteLine("=== テスト用並び替え完了 ===");
        }
        else
        {
            Console.WriteLine("Not enough thumbnails to swap (need at least 2)");
            errorMessage = "並び替えテストには最低2枚のサムネイルが必要です";
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (isFilesLoaded && firstRender)
        {
            await JSRuntime.InvokeVoidAsync("initializeSortable");
        }
    }

    // ...existing code...
    private async Task OpenFileDialog()
    {
        await JSRuntime.InvokeVoidAsync("openFileDialog", "fileInput");
    }

    // 削除処理（Blazorで完全管理）
    private void RemovePage(int index)
    {
        if (index >= 0 && index < pageThumbnails.Count)
        {
            pageThumbnails.RemoveAt(index);
            if (index < pdfPageDataList.Count)
            {
                pdfPageDataList.RemoveAt(index);
            }
            Console.WriteLine($"Page {index} removed.");

            // 重要：DOM再構築
            StateHasChanged();

            // Sortable再初期化
            InvokeAsync(async () =>
            {
                await Task.Delay(100);
                await JSRuntime.InvokeVoidAsync("initializeSortable");
            });
        }
    }

    // 回転処理（Blazorで完全管理）
    private async Task RotatePage(int index)
    {
        if (index >= 0 && index < pageThumbnails.Count)
        {
            try
            {
                Console.WriteLine($"Rotating page {index}...");

                // サムネイルを回転
                var thumbnail = pageThumbnails[index];
                var rotatedThumbnail = await JSRuntime.InvokeAsync<string>("rotateImage", thumbnail);
                if (rotatedThumbnail != null)
                {
                    pageThumbnails[index] = rotatedThumbnail;
                    Console.WriteLine($"Thumbnail {index} rotated successfully");
                }

                // 対応するPDFページも回転
                if (index < pdfPageDataList.Count)
                {
                    Console.WriteLine($"Rotating PDF page data {index}...");

                    var rotatedPageData = await JSRuntime.InvokeAsync<string>("rotatePDFPage", pdfPageDataList[index]);
                    if (rotatedPageData != null)
                    {
                        pdfPageDataList[index] = rotatedPageData;
                        Console.WriteLine($"PDF page data {index} rotated successfully");
                    }
                    else
                    {
                        Console.WriteLine($"rotatePDFPage returned null for page {index}");
                    }
                }

                Console.WriteLine($"Page {index} rotation completed.");

                // 重要：コメントアウトを解除
                StateHasChanged();

                // Sortable再初期化
                await Task.Delay(100);
                await JSRuntime.InvokeVoidAsync("initializeSortable");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error rotating page {index}: {ex.Message}");
                errorMessage = $"ページ {index + 1} の回転に失敗しました: {ex.Message}";
            }
        }
    }

    private async Task HandleFileSelectionAsync(InputFileChangeEventArgs e)
    {
        isLoading = true;
        progress = 0;
        const long maxFileSize = 52428800; // 50MB

        foreach (var file in e.GetMultipleFiles())
        {
            try
            {
                using var stream = file.OpenReadStream(maxFileSize);
                using var memoryStream = new MemoryStream();
                var buffer = new byte[8192];
                long totalBytesRead = 0;
                int bytesRead;

                while ((bytesRead = await stream.ReadAsync(buffer, 0, buffer.Length)) > 0)
                {
                    await memoryStream.WriteAsync(buffer, 0, bytesRead);
                    totalBytesRead += bytesRead;

                    progress = (int)((totalBytesRead / (double)file.Size) * 100);
                    StateHasChanged();
                }

                var pdfData = memoryStream.ToArray();
                pdfDataList.Add(pdfData);

                // JavaScript でサムネイルを生成
                var newThumbnails = await JSRuntime.InvokeAsync<List<string>>("renderPDFPages", pdfData);
                if (newThumbnails != null)
                {
                    Console.WriteLine($"Generated {newThumbnails.Count} thumbnails");
                    pageThumbnails.AddRange(newThumbnails);

                    // extractPDFPagesを安全に呼び出し
                    try
                    {
                        Console.WriteLine("Calling extractPDFPages...");
                        var pageDataList = await JSRuntime.InvokeAsync<List<string>>("extractPDFPages", pdfData);
                        if (pageDataList != null)
                        {
                            Console.WriteLine($"Extracted {pageDataList.Count} pages");
                            pdfPageDataList.AddRange(pageDataList);
                        }
                        else
                        {
                            Console.WriteLine("extractPDFPages returned null");
                        }
                    }
                    catch (Exception jsEx)
                    {
                        Console.WriteLine($"JavaScript error in extractPDFPages: {jsEx.Message}");
                        // ページデータの抽出に失敗した場合、サムネイルのみで続行
                        errorMessage = $"ページデータの抽出に失敗しました: {file.Name}";
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error processing file {file.Name}: {ex.Message}");
                errorMessage = $"Error processing file {file.Name}. Please try again.";
            }
        }

        isLoading = false;
        isFilesLoaded = true;
        StateHasChanged();

        await InitializeSortableAfterLoad();

        Console.WriteLine($"Total thumbnails: {pageThumbnails?.Count}");
        Console.WriteLine($"Total page data: {pdfPageDataList?.Count}");
    }

    // PDFを結合する処理（結果表示モードに切り替え）
    private async Task MergePDFs()
    {
        try
        {
            // デバッグ: 結合前のデータ順序を確認
            Console.WriteLine("=== 結合前のデータ順序 ===");
            for (int i = 0; i < pdfPageDataList.Count; i++)
            {
                Console.WriteLine($"Index {i}: {pdfPageDataList[i].Substring(0, 50)}...");
            }
            if (pdfPageDataList.Count == 0)
            {
                errorMessage = "No PDF files to merge.";
                Console.WriteLine("No files selected.");
                return;
            }

            errorMessage = null;

            // 並び替えられたページデータを使用してPDFを結合
            mergedPdfUrl = await JSRuntime.InvokeAsync<string>("mergePDFPages", pdfPageDataList);

            if (!string.IsNullOrEmpty(mergedPdfUrl))
            {
                // 結合成功：結果表示モードに切り替え
                showMergedResult = true;
                StateHasChanged();
                Console.WriteLine("Switched to result view mode");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"An error occurred: {ex.Message}");
            errorMessage = "An error occurred while merging PDFs. Please try again.";
        }
    }

    // 編集モードに戻る
    private void BackToEdit()
    {
        showMergedResult = false;
        StateHasChanged();

        // Sortableを再初期化
        InvokeAsync(async () =>
        {
            await Task.Delay(100);
            await JSRuntime.InvokeVoidAsync("initializeSortable");
        });
    }

    // 共有機能
    private async Task SharePDF()
    {
        if (!string.IsNullOrEmpty(mergedPdfUrl))
        {
            await JSRuntime.InvokeVoidAsync("navigator.clipboard.writeText", mergedPdfUrl);
            // 成功メッセージを表示（必要に応じて）
            Console.WriteLine("PDF URL copied to clipboard");
        }
    }

    // 印刷機能
    private async Task PrintPDF()
    {
        if (!string.IsNullOrEmpty(mergedPdfUrl))
        {
            await JSRuntime.InvokeVoidAsync("window.open", mergedPdfUrl, "_blank");
        }
    }

    // 新規作成
    private void StartNew()
    {
        // データをリセット
        pdfDataList.Clear();
        pdfPageDataList.Clear();
        pageThumbnails.Clear();
        mergedPdfUrl = null;
        errorMessage = null;
        showMergedResult = false;
        isFilesLoaded = false;

        StateHasChanged();
    }

    private async Task InitializeSortableAfterLoad()
    {
        if (isFilesLoaded && pageThumbnails.Any())
        {
            try
            {
                // DOMの更新を待つ
                await Task.Delay(200);

                Console.WriteLine("Initializing sortable after file load");
                await JSRuntime.InvokeVoidAsync("initializeSortable");

                Console.WriteLine("Sortable initialized successfully");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error initializing sortable: {ex.Message}");
            }
        }
    }

    protected override void OnAfterRender(bool firstRender)
    {
        if (firstRender)
        {
            _currentInstance = this;
            Console.WriteLine("Current instance set in OnAfterRenderAsync");
        }
    }

    private int showInsertMenuIndex = -1; // どの位置の挿入メニューを表示するか
    private int insertPosition = -1; // PDFを挿入する位置

    // 挿入メニューの表示/非表示を切り替え
    private void ToggleInsertMenu(int position)
    {
        if (showInsertMenuIndex == position)
        {
            Console.WriteLine($"Closing menu at position {position}");
            showInsertMenuIndex = -1; // 既に開いているメニューを閉じる
        }
        else if (position == -1)
        {
            Console.WriteLine("Closing menu from background click");
            showInsertMenuIndex = -1; // 背景クリックでメニューを閉じる
        }
        else
        {
            Console.WriteLine($"Opening menu at position {position}");
            showInsertMenuIndex = position; // 新しいメニューを開く
        }
        Console.WriteLine($"New showInsertMenuIndex: {showInsertMenuIndex}");
        StateHasChanged();
    }

    // 空白ページを挿入
    private async Task InsertBlankPage(int position)
    {
        try
        {
            Console.WriteLine($"Inserting blank page at position {position}");

            // 空白ページのPDFデータとサムネイルを生成
            var blankPageData = await JSRuntime.InvokeAsync<string>("createBlankPage");
            var blankThumbnail = await JSRuntime.InvokeAsync<string>("renderSinglePDFPage", blankPageData);

            if (blankPageData != null && blankThumbnail != null)
            {
                // 指定位置に挿入
                pageThumbnails.Insert(position, blankThumbnail);
                pdfPageDataList.Insert(position, blankPageData);

                Console.WriteLine($"Blank page inserted at position {position}");
                StateHasChanged();

                // Sortableを再初期化
                await Task.Delay(100);
                await InitializeSortableAfterLoad();
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error inserting blank page: {ex.Message}");
            errorMessage = $"空白ページの挿入に失敗しました: {ex.Message}";
        }
        finally
        {
            showInsertMenuIndex = -1; // メニューを閉じる
        }
    }

    // PDF挿入用のファイル選択
    private async Task InsertPdfAtPosition(int position)
    {
        insertPosition = position;
        showInsertMenuIndex = -1; // メニューを閉じる
        await JSRuntime.InvokeVoidAsync("openFileDialog", "insertFileInput");
    }

    // PDF挿入用のファイル処理
    private async Task HandleInsertFileSelectionAsync(InputFileChangeEventArgs e)
    {
        if (insertPosition == -1) return;

        const long maxFileSize = 52428800; // 50MB

        foreach (var file in e.GetMultipleFiles())
        {
            try
            {
                using var stream = file.OpenReadStream(maxFileSize);
                using var memoryStream = new MemoryStream();
                await stream.CopyToAsync(memoryStream);

                var pdfData = memoryStream.ToArray();

                // JavaScript でサムネイルを生成
                var newThumbnails = await JSRuntime.InvokeAsync<List<string>>("renderPDFPages", pdfData);
                var pageDataList = await JSRuntime.InvokeAsync<List<string>>("extractPDFPages", pdfData);

                if (newThumbnails != null && pageDataList != null)
                {
                    // 指定位置に挿入
                    for (int i = 0; i < newThumbnails.Count; i++)
                    {
                        pageThumbnails.Insert(insertPosition + i, newThumbnails[i]);
                        pdfPageDataList.Insert(insertPosition + i, pageDataList[i]);
                    }

                    Console.WriteLine($"Inserted {newThumbnails.Count} pages at position {insertPosition}");
                    StateHasChanged();

                    // Sortableを再初期化
                    await Task.Delay(100);
                    await InitializeSortableAfterLoad();
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error inserting PDF: {ex.Message}");
                errorMessage = $"PDFの挿入に失敗しました: {ex.Message}";
            }
        }

        insertPosition = -1; // リセット
    }
}