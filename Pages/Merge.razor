@page "/merge"
@inject IJSRuntime JSRuntime
@inject PdfDataService PdfDataService
@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.AspNetCore.Components.Web
@using Microsoft.JSInterop
@using System.IO
@using ClientPdfApp.Models
@using ClientPdfApp.Services

<PageTitle>Merge</PageTitle>

@if (IsFilesLoaded && !showMergedResult)
{
    <!-- 上部固定バー（編集モード） -->
    <div class="fixed top-0 left-0 w-full bg-gray-800 text-white shadow-md z-50">
        <div class="flex items-center justify-between px-4 py-2">
            <span class="text-lg font-semibold">PDF操作</span>
            <div class="flex gap-2 items-center">
                <!-- 表示切り替えスイッチ -->
                <div class="flex items-center gap-2 mr-4">
                    <span class="text-sm">表示:</span>
                    <button class="@(IsFileMode ? "bg-blue-500" : "bg-gray-600") hover:bg-blue-600 text-white py-1 px-3 rounded text-sm"
                        @onclick="SwitchToFileMode">
                        ファイル単位
                    </button>
                    <button class="@(IsPageMode ? "bg-blue-500" : "bg-gray-600") hover:bg-blue-600 text-white py-1 px-3 rounded text-sm"
                        @onclick="SwitchToPageMode">
                        ページ単位
                    </button>
                </div>
                <button class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded" @onclick="MergePDFs">
                    結合
                </button>
            </div>
        </div>
    </div>

    <!-- サムネイル編集エリア -->
    <div class="pt-16"> <!-- 上部バーの高さ分余白 -->
        <div id="sortable-container" class="flex flex-wrap gap-4 p-6">
            @if (DisplayItems != null && DisplayItems.Any())
            {
                @for (int i = 0; i < DisplayItems.Count; i++)
                {
                    var index = i;
                    var item = DisplayItems[index];

                    <div class="sortable-item-container flex items-center gap-2" data-index="@i">
                        @* 左側の＋ボタン *@
                        <div class="flex items-center relative insert-button-container" data-position="@i">
                            <button
                                class="w-6 h-6 bg-blue-500 bg-opacity-60 hover:bg-opacity-100 hover:bg-blue-600 text-white rounded-full flex items-center justify-center insert-button transition-all duration-200"
                                data-position="@i"
                                @onclick="@((e) => HandleInsertButtonClick(i, e))">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor" class="w-3 h-3">
                                    <path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/>
                                </svg>
                            </button>
                        </div>

                        @* 右側のサムネイル *@
                        <div class="thumbnail-item relative group thumbnail-container">
                            @{
                                var isMultiPage = IsFileMode && item.PageInfo.Contains("ページ");
                            }
                            
                            <!-- サムネイル画像部分 -->
                            <div class="@(isMultiPage ? "thumbnail-stack" : "")">
                                <div class="w-24 h-32 flex items-center justify-center overflow-hidden @(isMultiPage ? "stack-layer" : "")">
                                    @if (item.IsLoading)
                                    {
                                        <div class="page-loading w-full h-full"></div>
                                    }
                                    else if (item.HasError)
                                    {
                                        <div class="page-error w-full h-full">
                                            読み込み<br/>エラー
                                        </div>
                                    }
                                    else if (!string.IsNullOrEmpty(item.Thumbnail))
                                    {
                                        <img src="@item.Thumbnail" class="max-w-full max-h-full object-contain border border-gray-300 @(IsPageMode ? "thumbnail-loaded" : "")"
                                            draggable="false" />
                                    }
                                </div>
                                    
                                @if (isMultiPage && item.PageInfo.Contains("ページ"))
                                {
                                    var pageCountMatch = System.Text.RegularExpressions.Regex.Match(item.PageInfo, @"(\d+)ページ");
                                    if (pageCountMatch.Success)
                                    {
                                        <div class="page-count-badge">
                                            @pageCountMatch.Groups[1].Value
                                        </div>
                                    }
                                }
                            </div>
                            
                            <!-- ファイル情報表示 -->
                            <div class="file-info">
                                <div class="file-name" title="@item.DisplayName">
                                    @item.DisplayName
                                </div>
                                @if (IsPageMode && !string.IsNullOrEmpty(item.PageInfo))
                                {
                                    <div class="page-number">
                                        @item.PageInfo
                                    </div>
                                }
                            </div>

                            <!-- 隣接サムネイルとの入れ替えボタン -->
                            @if (index < DisplayItems.Count - 1)
                            {
                                <button class="swap-button btn btn-sm btn-warning position-absolute" 
                                        style="bottom: -8px; right: -8px; width: 24px; height: 24px; padding: 0; border-radius: 50%; font-size: 14px; z-index: 20; display: flex; align-items: center; justify-content: center;"
                                        @onclick="() => SwapWithNext(index)"
                                        title="次のサムネイルと入れ替え">
                                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#212529" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                        <polyline points="7 17 2 12 7 7" />
                                        <polyline points="17 7 22 12 17 17" />
                                        <line x1="2" y1="12" x2="22" y2="12" />
                                    </svg>
                                </button>
                            }

                            <!-- サブメニュー -->
                            <div class="menu-overlay absolute top-2 right-2 bg-white shadow-md rounded p-1 flex-col"
                                style="display: none; z-index: 20;">
                                <button class="text-red-500 hover:text-red-700 p-1" @onclick="() => RemovePage(index)">
                                    <i class="fas fa-trash"></i>
                                </button>
                                <button class="text-blue-500 hover:text-blue-700 p-1 mt-1" @onclick="() => RotatePage(index)">
                                    <i class="fa-solid fa-rotate-right"></i>
                                </button>
                                @if (isMultiPage)
                                {
                                    <button class="text-green-500 hover:text-green-700 p-1 mt-1" @onclick="() => ExpandFile(index)" 
                                            title="全ページを展開">
                                        <i class="fa-solid fa-expand"></i>
                                    </button>
                                }
                            </div>
                        </div>
                    </div>
                }

                @* 最後尾の固定＋ボタン *@
                <div class="non-sortable flex items-center relative insert-button-container" data-position="@DisplayItems.Count">
                    <button
                        class="w-6 h-6 bg-blue-500 bg-opacity-60 hover:bg-opacity-100 hover:bg-blue-600 text-white rounded-full flex items-center justify-center insert-button transition-all duration-200"
                        data-position="@DisplayItems.Count"
                        @onclick="@((e) => HandleInsertButtonClick(DisplayItems.Count, e))">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor" class="w-3 h-3">
                            <path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/>
                        </svg>
                    </button>
                </div>
            }
            else
            {
                @* サムネイルが0個の場合は最初の＋ボタンのみ *@
                <div class="flex items-center relative insert-button-container" data-position="0">
                    <button
                        class="w-6 h-6 bg-blue-500 bg-opacity-60 hover:bg-opacity-100 hover:bg-blue-600 text-white rounded-full flex items-center justify-center insert-button transition-all duration-200"
                        data-position="0"
                        @onclick="@((e) => HandleInsertButtonClick(0, e))">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor" class="w-3 h-3">
                            <path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/>
                        </svg>
                    </button>
                </div>
                <!-- 初期状態：ファイル選択を促すメッセージ -->
                <div class="w-full text-center py-20">
                    <p class="text-gray-500 text-lg mb-4">PDFファイルを選択してください</p>
                    <button class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded"
                        @onclick="OpenFileDialog">
                        ファイルを選択
                    </button>
                </div>
            }
        </div>
    </div>
}
@if (showMergedResult && !string.IsNullOrEmpty(mergedPdfUrl))
{
    <!-- 結果表示モード -->
    <div class="fixed top-0 left-0 w-full bg-gray-800 text-white shadow-md z-50">
        <div class="flex items-center justify-between px-4 py-2">
            <span class="text-lg font-semibold">結合結果</span>
            <div class="flex gap-2">
                <button class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded"
                    @onclick="BackToEdit">
                    編集に戻る
                </button>
                <button class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded"
                    @onclick="StartNew">
                    新規作成
                </button>
            </div>
        </div>
    </div>

    <div class="pt-16">
        <div class="p-6">
            <iframe src="@mergedPdfUrl" class="w-full h-screen border-none" style="min-height: 800px;">
                お使いのブラウザはPDFの表示をサポートしていません。
                <a href="@mergedPdfUrl" target="_blank">こちらをクリック</a>してPDFを開いてください。
            </iframe>
        </div>
    </div>
}
@if (!IsFilesLoaded && !showMergedResult)
{
    <!-- 初期画面：ファイル選択 -->
    <div class="flex items-center justify-center min-h-screen bg-gray-100">
        <div class="text-center">
            <h1 class="text-4xl font-bold text-gray-800 mb-8">PDF Merger</h1>
            <div class="mb-8">
                <button class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-6 rounded-lg text-lg"
                    @onclick="OpenFileDialog">
                    PDFファイルを選択
                </button>
            </div>
            <div class="text-gray-600">
                <p>✅ 複数のPDFファイルを選択して結合できます</p>
                <p class="text-sm mt-2">✅ <strong>元のページ番号が正しく表示されます</strong></p>
                <p class="text-sm mt-2">✅ ファイル単位・ページ単位の表示切り替え対応</p>
                <p class="text-sm mt-2">最大ファイルサイズ: 50MB</p>
            </div>
            
            @if (isLoading)
            {
                <div class="mt-8">
                    <div class="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-500 mx-auto"></div>
                    <p class="mt-4 text-gray-600">読み込み中... @progress%</p>
                </div>
            }
        </div>
    </div>
}

<!-- エラーメッセージ表示 -->
@if (!string.IsNullOrEmpty(errorMessage))
{
    <div class="fixed bottom-4 right-4 bg-red-500 text-white px-4 py-2 rounded shadow-lg z-50 max-w-md">
        <div class="flex items-start gap-2">
            <div class="flex-1">
                @errorMessage
            </div>
            <button class="text-white hover:text-gray-200 ml-2" @onclick="ClearErrorMessage">
                ✕
            </button>
        </div>
    </div>
}

<!-- ファイル選択用の隠しinput -->
<InputFile OnChange="HandleFileSelectionAsync" multiple style="display: none;" id="fileInput" />
<InputFile OnChange="HandleInsertFileSelectionAsync" style="display: none;" id="insertFileInput" />

<style>
    .thumbnail-item:hover .menu-overlay {
        display: flex !important;
    }

    .sortable-item-container {
        cursor: move;
    }

    /* 複数ページファイル用のスタックエフェクト */
    .thumbnail-stack {
        position: relative;
        margin: 8px; /* バッジのスペースを確保 */
    }

    .thumbnail-stack .stack-layer {
        position: relative;
        z-index: 3;
    }

    .thumbnail-stack::before {
        content: '';
        position: absolute;
        top: 4px;
        left: 4px;
        right: -4px;
        bottom: -4px;
        background: #f8f9fa;
        border: 1px solid #e5e7eb;
        border-radius: 6px;
        z-index: 1;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    }

    .thumbnail-stack::after {
        content: '';
        position: absolute;
        top: 8px;
        left: 8px;
        right: -8px;
        bottom: -8px;
        background: #f1f3f4;
        border: 1px solid #d1d5db;
        border-radius: 6px;
        z-index: 0;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
    }

    /* ページ数バッジ */
    .page-count-badge {
        position: absolute;
        top: -8px;
        right: -8px;
        background: #dc2626;
        color: white;
        border-radius: 50%;
        width: 24px;
        height: 24px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 11px;
        font-weight: bold;
        z-index: 10;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        border: 2px solid white;
        line-height: 1;
    }

    /* サムネイル画像の調整 */
    .thumbnail-stack .stack-layer img {
        border-radius: 4px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
    }

    /* コンテナの調整 */
    .thumbnail-container {
        padding: 8px;
        position: relative;
        min-width: 96px; /* サムネイル幅に合わせる */
        min-height: 160px; /* サムネイル高さ + ファイル情報表示エリア */
        display: flex;
        flex-direction: column;
        align-items: center;
        transition: transform 0.2s ease-in-out;
    }

    .thumbnail-container:hover {
        transform: scale(1.05);
    }

    /* ローディングアニメーション */
    .page-loading {
        position: relative;
        background: #f3f4f6;
        border: 2px dashed #d1d5db;
        border-radius: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
        min-height: 128px;
        animation: pulse 2s infinite;
    }

    .page-loading::before {
        content: '';
        width: 24px;
        height: 24px;
        border: 3px solid #e5e7eb;
        border-top: 3px solid #3b82f6;
        border-radius: 50%;
        animation: spin 1s linear infinite;
    }

    .page-error {
        position: relative;
        background: #fef2f2;
        border: 2px solid #fca5a5;
        border-radius: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
        min-height: 128px;
        color: #dc2626;
        font-size: 12px;
        text-align: center;
        padding: 8px;
    }

    @@keyframes pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.7; }
    }

    @@keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }

    /* サムネイル読み込み完了時のアニメーション */
    .thumbnail-loaded {
        animation: fadeIn 0.5s ease-in-out;
    }

    @@keyframes fadeIn {
        0% { opacity: 0; transform: scale(0.95); }
        100% { opacity: 1; transform: scale(1); }
    }
    
    /* ファイル情報表示スタイル */
    .file-info {
        margin-top: 4px;
        text-align: center;
        width: 100%;
        max-width: 96px; /* サムネイル幅(w-24 = 96px)に合わせる */
        position: relative;
    }
    
    .file-name {
        font-size: 10px;
        color: #374151;
        font-weight: 500;
        line-height: 1.2;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        padding: 0 2px;
        cursor: pointer;
    }
    
    .page-number {
        font-size: 9px;
        color: #6b7280;
        font-weight: 400;
        line-height: 1.1;
        margin-top: 1px;
    }
    
    /* 入れ替えボタン - 元のBootstrapスタイルに戻す */
    .swap-button {
        position: absolute;
        bottom: -8px;
        right: -8px;
        background: #ffc107 !important;
        color: #212529 !important;
        border: 1px solid #ffc107 !important;
        border-radius: 50% !important;
        width: 24px !important;
        height: 24px !important;
        font-size: 10px !important;
        display: flex !important;
        align-items: center !important;
        justify-content: center !important;
        cursor: pointer !important;
        z-index: 20 !important;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3) !important;
        transition: background 0.2s, border 0.2s !important;
        padding: 0 !important;
    }

    .swap-button:hover {
        background: #e0a800 !important;
        border-color: #d39e00 !important;
        /* transformやbox-shadow拡大をやめて、下方に下がる動きをなくす */
    }

    /* ドラッグ&ドロップ用のコンテナ修正 */
    .sortable-item-container {
        cursor: move;
        user-select: none;
        position: relative;
    }

    .sortable-item-container:hover {
        z-index: 10;
    }

    .sortable-item-container.ui-sortable-helper {
        z-index: 1000 !important;
        opacity: 0.8;
        transform: rotate(5deg);
    }
    
    /* 挿入メニュー用のスタイル - インライン管理方式 */
    .insert-menu.show {
        display: block !important;
    }
    
    .insert-menu.hide {
        display: none !important;
    }
    
    .insert-menu button:hover {
        background-color: #f3f4f6 !important;
    }
</style>

@code {
    private bool isLoading = false;
    private bool showMergedResult = false;
    private int progress = 0;
    private string? mergedPdfUrl;
    private string? errorMessage;

    // 統一アーキテクチャ対応プロパティ
    private DisplayMode CurrentDisplayMode => PdfDataService.GetModel().CurrentMode;
    private List<DisplayItem> DisplayItems => PdfDataService.GetDisplayItems();
    private bool IsFilesLoaded => DisplayItems.Any();
    private bool IsFileMode => CurrentDisplayMode == DisplayMode.File;
    private bool IsPageMode => CurrentDisplayMode == DisplayMode.Page;

    // 表示モード切り替えメソッド
    private async Task SwitchToFileMode()
    {
        if (IsFileMode) return;
        Console.WriteLine("Switching to File mode");
        PdfDataService.SwitchDisplayMode(DisplayMode.File);
        StateHasChanged();
        await Task.Delay(100); // DOM更新待ち
        
        // JavaScript再初期化
        try
        {
            await JSRuntime.InvokeVoidAsync("initializeDragDrop");
            await JSRuntime.InvokeVoidAsync("initializeSortable");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error reinitializing JS: {ex.Message}");
        }
        
        Console.WriteLine($"Switched to File mode. Items count: {DisplayItems.Count}");
    }

    private async Task SwitchToPageMode()
    {
        if (IsPageMode) return;
        Console.WriteLine("Switching to Page mode");
        
        // 即座にページ単位モードに切り替える（読み込み完了を待たない）
        PdfDataService.SwitchDisplayMode(DisplayMode.Page);
        StateHasChanged();
        await Task.Delay(100); // DOM更新待ち
        
        // JavaScript再初期化
        try
        {
            await JSRuntime.InvokeVoidAsync("initializeDragDrop");
            await JSRuntime.InvokeVoidAsync("initializeSortable");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error reinitializing JS: {ex.Message}");
        }
        
        Console.WriteLine($"Switched to Page mode. Items count: {DisplayItems.Count}");
        
        // バックグラウンドで残りのページ読み込みを継続（UI をブロックしない）
        _ = Task.Run(async () =>
        {
            try
            {
                await PdfDataService.EnsureAllPagesLoadedAsync();
                await InvokeAsync(() =>
                {
                    StateHasChanged(); // 読み込み完了時にUIを更新
                });
                Console.WriteLine("Background page loading completed");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error in background page loading: {ex.Message}");
                await InvokeAsync(() =>
                {
                    errorMessage = $"一部ページの読み込みに失敗しました。問題のあるページは「読み込みエラー」と表示されます。";
                    StateHasChanged();
                });
            }
        });
    }

    // ファイル選択処理
    private async Task HandleFileSelectionAsync(InputFileChangeEventArgs e)
    {
        Console.WriteLine($"HandleFileSelectionAsync called with {e.FileCount} files");
        
        if (e.FileCount == 0)
        {
            Console.WriteLine("No files selected");
            return;
        }

        isLoading = true;
        progress = 0;
        errorMessage = null;
        const long maxFileSize = 52428800; // 50MB

        var fileCount = 0;
        foreach (var file in e.GetMultipleFiles())
        {
            fileCount++;
            Console.WriteLine($"Processing file {fileCount}: {file.Name}, Size: {file.Size} bytes");
            try
            {
                using var stream = file.OpenReadStream(maxFileSize);
                using var memoryStream = new MemoryStream();
                var buffer = new byte[8192];
                long totalBytesRead = 0;
                int bytesRead;

                while ((bytesRead = await stream.ReadAsync(buffer, 0, buffer.Length)) > 0)
                {
                    await memoryStream.WriteAsync(buffer, 0, bytesRead);
                    totalBytesRead += bytesRead;

                    progress = (int)((totalBytesRead / (double)file.Size) * 100);
                    StateHasChanged();
                }

                var pdfData = memoryStream.ToArray();
                Console.WriteLine($"File {file.Name} read successfully, data size: {pdfData.Length} bytes");

                // 統一データサービスを使用してファイルを追加
                var success = await PdfDataService.AddPdfFileAsync(file.Name, pdfData);
                if (!success)
                {
                    Console.WriteLine($"Failed to add file {file.Name}");
                    errorMessage = $"ファイル処理に失敗しました: {file.Name} - PDFファイルが破損しているか、サポートされていない形式の可能性があります。";
                }
                else
                {
                    Console.WriteLine($"Successfully added file {file.Name}");
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error processing file {file.Name}: {ex.Message}");
                errorMessage = $"ファイル処理エラー: {file.Name} - {ex.Message}";
            }
        }

        isLoading = false;
        Console.WriteLine($"File loading completed. Total items: {DisplayItems.Count}");
        StateHasChanged();
    }

    // PDF結合処理
    private async Task MergePDFs()
    {
        try
        {
            Console.WriteLine("=== PDF結合開始 ===");
            
            var mergeData = PdfDataService.GetMergeData();
            if (mergeData.Count == 0)
            {
                errorMessage = "No PDF files to merge.";
                Console.WriteLine("No files selected.");
                return;
            }

            errorMessage = null;
            isLoading = true;
            StateHasChanged();

            // 並び替えられたページデータを使用してPDFを結合
            mergedPdfUrl = await JSRuntime.InvokeAsync<string>("mergePDFPages", mergeData);

            if (!string.IsNullOrEmpty(mergedPdfUrl))
            {
                // 結合成功：結果表示モードに切り替え
                showMergedResult = true;
                Console.WriteLine("Switched to result view mode");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"An error occurred: {ex.Message}");
            errorMessage = "An error occurred while merging PDFs. Please try again.";
        }
        finally
        {
            isLoading = false;
            StateHasChanged();
        }
    }

    // アイテム削除
    private void RemovePage(int index)
    {
        Console.WriteLine($"RemovePage called with index: {index}");
        
        try
        {
            PdfDataService.RemoveItem(index);
            Console.WriteLine($"Item {index} removed successfully.");
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error removing item {index}: {ex.Message}");
            errorMessage = $"削除に失敗しました: {ex.Message}";
        }
    }

    // ファイルダイアログを開く
    private async Task OpenFileDialog()
    {
        Console.WriteLine("OpenFileDialog called");
        try
        {
            await JSRuntime.InvokeVoidAsync("openFileDialog", "fileInput");
            Console.WriteLine("File dialog opened successfully");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error opening file dialog: {ex.Message}");
            errorMessage = $"ファイル選択ダイアログの表示に失敗しました: {ex.Message}";
        }
    }

    // その他のメソッド
    private void BackToEdit() 
    { 
        showMergedResult = false; 
        StateHasChanged(); 
    }
    
    private void StartNew() 
    { 
        PdfDataService.Clear(); 
        showMergedResult = false; 
        mergedPdfUrl = null;
        errorMessage = null;
        StateHasChanged(); 
    }

    private void ClearErrorMessage()
    {
        errorMessage = null;
        StateHasChanged();
    }

    // 隣接サムネイルとの入れ替え機能
    private async Task SwapWithNext(int index)
    {
        try
        {
            Console.WriteLine($"SwapWithNext called: index {index}");
            var currentCount = DisplayItems.Count;
            
            if (index >= 0 && index < currentCount - 1)
            {
                var nextIndex = index + 1;
                Console.WriteLine($"Swapping {index} with {nextIndex}");
                
                // 統一データサービスを使用して入れ替え
                PdfDataService.SwapItems(index, nextIndex);
                StateHasChanged();
                
                Console.WriteLine($"Swap completed successfully");
            }
            else
            {
                Console.WriteLine($"Invalid swap: index={index}, count={currentCount}");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error in SwapWithNext: {ex.Message}");
            errorMessage = $"サムネイルの入れ替えに失敗しました: {ex.Message}";
        }
    }

    // 回転処理
    private async Task RotatePage(int index)
    {
        if (index >= 0 && index < DisplayItems.Count)
        {
            try
            {
                Console.WriteLine($"Rotating item {index}...");
                
                // 統一データサービスを使用して回転
                await PdfDataService.RotateItemAsync(index);
                StateHasChanged();
                
                Console.WriteLine($"Item {index} rotation completed.");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error rotating item {index}: {ex.Message}");
                errorMessage = $"アイテム {index + 1} の回転に失敗しました: {ex.Message}";
            }
        }
    }

    // ファイル展開機能（ファイル単位表示から特定のファイルの全ページを展開）
    private async Task ExpandFile(int fileIndex)
    {
        if (fileIndex >= 0 && fileIndex < DisplayItems.Count && IsFileMode)
        {
            try
            {
                Console.WriteLine($"Expanding file at index {fileIndex}");
                
                // 統一データサービスを使用してファイル展開
                await PdfDataService.ExpandFileAsync(fileIndex);
                
                // ページ単位表示に切り替え
                await SwitchToPageMode();
                
                Console.WriteLine($"File {fileIndex} expanded successfully");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error expanding file: {ex.Message}");
                errorMessage = $"ファイル展開に失敗しました: {ex.Message}";
            }
        }
    }

    // 挿入ボタンクリック処理
    private async Task HandleInsertButtonClick(int position, MouseEventArgs e)
    {
        Console.WriteLine($"=== HandleInsertButtonClick called ===");
        Console.WriteLine($"Position: {position}");
        
        try
        {
            // JavaScriptの挿入メニューを表示
            await JSRuntime.InvokeVoidAsync("showInsertMenuAtExactPosition", position, e.ClientX, e.ClientY);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error showing insert menu: {ex.Message}");
            errorMessage = $"メニュー表示に失敗しました: {ex.Message}";
        }
    }

    // 静的インスタンスで現在のコンポーネントを参照（JavaScript連携用）
    private static Merge? _currentInstance;

    // JavaScript から呼び出される並び替えメソッド
    [JSInvokable("UpdateOrder")]
    public static async Task UpdateOrder(int oldIndex, int newIndex)
    {
        Console.WriteLine($"UpdateOrder called with oldIndex: {oldIndex}, newIndex: {newIndex}");

        if (_currentInstance != null)
        {
            Console.WriteLine($"Current instance found, calling UpdateOrderInternal");
            await _currentInstance.UpdateOrderInternal(oldIndex, newIndex);
        }
        else
        {
            Console.WriteLine($"ERROR: Current instance is null!");
        }
    }
    
    // 実際の並び替え処理
    private async Task UpdateOrderInternal(int oldIndex, int newIndex)
    {
        try
        {
            Console.WriteLine($"UpdateOrderInternal called: {oldIndex} -> {newIndex}");
            
            if (oldIndex >= 0 && oldIndex < DisplayItems.Count &&
                newIndex >= 0 && newIndex < DisplayItems.Count &&
                oldIndex != newIndex)
            {
                // 統一データサービスを使用して並び替え
                PdfDataService.MoveItem(oldIndex, newIndex);
                
                Console.WriteLine($"Successfully moved item from {oldIndex} to {newIndex}");
                
                // DOM更新
                await InvokeAsync(async () =>
                {
                    StateHasChanged();
                    await Task.Delay(100);
                    await JSRuntime.InvokeVoidAsync("initializeSortable");
                });
            }
            else
            {
                Console.WriteLine($"Invalid move operation: oldIndex={oldIndex}, newIndex={newIndex}, count={DisplayItems.Count}");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error in UpdateOrderInternal: {ex.Message}");
            errorMessage = $"並び替えに失敗しました: {ex.Message}";
        }
    }

    // JavaScript から呼び出される空白ページ挿入メソッド
    [JSInvokable("InsertBlankPageFromJS")]
    public static async Task InsertBlankPageFromJS(int position)
    {
        if (_currentInstance != null)
        {
            await _currentInstance.InsertBlankPage(position);
        }
    }

    // JavaScript から呼び出されるPDF挿入メソッド
    [JSInvokable("InsertPdfAtPositionFromJS")]
    public static async Task InsertPdfAtPositionFromJS(int position)
    {
        if (_currentInstance != null)
        {
            await _currentInstance.InsertPdfAtPosition(position);
        }
    }

    // 空白ページを挿入
    private async Task InsertBlankPage(int position)
    {
        try
        {
            Console.WriteLine($"Inserting blank page at position {position}");
            
            // 統一データサービスを使用して空白ページ挿入
            await PdfDataService.InsertBlankPageAsync(position);
            StateHasChanged();
            
            Console.WriteLine("Blank page inserted successfully");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error inserting blank page: {ex.Message}");
            errorMessage = $"空白ページの挿入に失敗しました: {ex.Message}";
        }
    }

    // PDF挿入
    private async Task InsertPdfAtPosition(int position)
    {
        try
        {
            Console.WriteLine($"Opening file dialog for PDF insertion at position {position}");
            
            // JavaScriptでファイルダイアログを開く
            await JSRuntime.InvokeVoidAsync("openInsertFileDialog", "insertFileInput");
            
            // 挿入位置を保存（ファイル選択後に使用）
            insertPosition = position;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error opening insert file dialog: {ex.Message}");
            errorMessage = $"ファイル選択ダイアログの表示に失敗しました: {ex.Message}";
        }
    }

    private int insertPosition = -1;

    // 挿入用ファイル選択処理
    private async Task HandleInsertFileSelectionAsync(InputFileChangeEventArgs e)
    {
        if (e.FileCount > 0 && insertPosition >= 0)
        {
            try
            {
                var file = e.GetMultipleFiles().First();
                Console.WriteLine($"Processing insert file: {file.Name} at position {insertPosition}");
                
                using var stream = file.OpenReadStream(52428800); // 50MB
                using var memoryStream = new MemoryStream();
                await stream.CopyToAsync(memoryStream);
                var pdfData = memoryStream.ToArray();
                
                // 統一データサービスを使用してファイルを挿入
                await PdfDataService.InsertPdfFileAsync(insertPosition, file.Name, pdfData);
                StateHasChanged();
                
                insertPosition = -1; // リセット
                Console.WriteLine($"File {file.Name} inserted successfully");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error inserting file: {ex.Message}");
                errorMessage = $"ファイル挿入に失敗しました: {ex.Message}";
                insertPosition = -1; // リセット
            }
        }
    }

    protected override void OnAfterRender(bool firstRender)
    {
        if (firstRender)
        {
            _currentInstance = this;
            Console.WriteLine("Current instance set in OnAfterRender");
        }
        
        // 毎回ドラッグ&ドロップとソート機能を再初期化（DOM更新時に必要）
        if (IsFilesLoaded && DisplayItems.Any())
        {
            InvokeAsync(async () =>
            {
                try
                {
                    await Task.Delay(50); // DOM更新完了を待つ
                    await JSRuntime.InvokeVoidAsync("initializeDragDrop");
                    await JSRuntime.InvokeVoidAsync("initializeSortable");
                    Console.WriteLine("Drag and drop and sortable re-initialized");
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Error initializing interactions: {ex.Message}");
                }
            });
        }
    }
}