@page "/merge"
@inject IJSRuntime JSRuntime
@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.AspNetCore.Components.Web

<PageTitle>Merge</PageTitle>

@if (isFilesLoaded)
{
    <!-- 上部固定バー -->
    <div class="fixed top-0 left-0 w-full bg-gray-800 text-white shadow-md z-50">
        <div class="flex items-center justify-between px-4 py-2">
            <span class="text-lg font-semibold">PDF操作</span>
            <button class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded" @onclick="MergePDFs">
                結合
            </button>
        </div>
    </div>
}

@if (!isFilesLoaded && !isLoading)
{
    <div id="drop-zone"
        class="flex items-center justify-center w-full h-screen border-2 border-dashed border-gray-400 cursor-pointer hover:bg-gray-100"
        @onclick="OpenFileDialog">
        <div class="text-center">
            <span class="text-2xl text-gray-500">ファイルをここにドラッグ＆ドロップ</span>
            <p class="text-sm text-gray-500 mt-2">またはクリックしてファイルを選択</p>
        </div>
    </div>
}
@if (isLoading)
{
    <div class="flex items-center justify-center w-full h-screen">
        <div class="text-center">
            <div class="w-64 h-4 bg-gray-200 rounded-full overflow-hidden">
                <div class="h-full bg-blue-500" style="width: @progress%;"></div>
            </div>
            <p class="text-sm text-gray-500 mt-2">読み込み中...</p>
        </div>
    </div>
}
<InputFile OnChange="HandleFileSelectionAsync" multiple="true" maxsize="52428800" style="display: none;"
    id="fileInput" />
@* <button @onclick="MergePDFs">Merge PDFs</button> *@
@if (!string.IsNullOrEmpty(errorMessage))
{
    <p style="color: red;">@errorMessage</p>
}
@if (!string.IsNullOrEmpty(mergedPdfUrl))
{
    <a href="@mergedPdfUrl" target="_blank" download="merged.pdf">Download Merged PDF</a>
}
<div id="sortable-container" class="flex flex-wrap gap-2">
    @if (pageThumbnails != null && pageThumbnails.Any())
    {
        @* 各サムネイルの左側に＋ボタンを配置（並び替え対象） *@
        @for (int i = 0; i < pageThumbnails.Count; i++)
        {
            var index = i;

            <div class="sortable-item-container flex items-center gap-2" data-index="@i">
                @* 左側の＋ボタン *@
                <div class="flex items-center">
                    <button
                        class="w-8 h-8 bg-blue-500 hover:bg-blue-600 text-white rounded-full flex items-center justify-center text-lg font-bold shadow-md"
                        @onclick="() => ToggleInsertMenu(i)">
                        +
                    </button>
                    @if (showInsertMenuIndex == i)
                    {
                        <div class="fixed inset-0 z-40" @onclick="() => ToggleInsertMenu(-1)"></div>
                        <div class="absolute top-10 left-0 bg-white border border-gray-300 rounded shadow-lg min-w-48 z-50">
                            <button class="w-full px-4 py-2 text-left hover:bg-gray-100 border-b border-gray-200"
                                @onclick="() => InsertBlankPage(i)">
                                📄 空白ページの挿入
                            </button>
                            <button class="w-full px-4 py-2 text-left hover:bg-gray-100" @onclick="() => InsertPdfAtPosition(i)">
                                📁 PDFを選択して挿入
                            </button>
                        </div>
                    }
                </div>

                @* 右側のサムネイル *@
                <div class="thumbnail-item relative group p-2">
                    <div class="w-24 h-32 flex items-center justify-center overflow-hidden">
                        <img src="@pageThumbnails[i]" class="max-w-full max-h-full object-contain border border-gray-300"
                            draggable="false" />
                    </div>

                    <!-- サブメニュー -->
                    <div class="menu-overlay absolute top-0 right-0 bg-white shadow-md rounded p-1 flex-col"
                        style="display: none;">
                        <button class="text-red-500 hover:text-red-700 p-1" @onclick="() => RemovePage(index)">
                            <i class="fas fa-trash"></i>
                        </button>
                        <button class="text-blue-500 hover:text-blue-700 p-1 mt-1" @onclick="() => RotatePage(index)">
                            <i class="fa-solid fa-rotate-right"></i>
                        </button>
                    </div>
                </div>
            </div>
        }

        @* 最後尾の固定＋ボタン *@
        <div class="flex items-center">
            <button
                class="w-8 h-8 bg-blue-500 hover:bg-blue-600 text-white rounded-full flex items-center justify-center text-lg font-bold shadow-md"
                @onclick="() => ToggleInsertMenu(pageThumbnails.Count)">
                +
            </button>
            @if (showInsertMenuIndex == pageThumbnails.Count)
            {
                <div class="fixed inset-0 z-40" @onclick="() => ToggleInsertMenu(-1)"></div>
                <div class="absolute top-10 left-0 bg-white border border-gray-300 rounded shadow-lg min-w-48 z-50">
                    <button class="w-full px-4 py-2 text-left hover:bg-gray-100 border-b border-gray-200"
                        @onclick="() => InsertBlankPage(pageThumbnails.Count)">
                        📄 空白ページの挿入
                    </button>
                    <button class="w-full px-4 py-2 text-left hover:bg-gray-100"
                        @onclick="() => InsertPdfAtPosition(pageThumbnails.Count)">
                        📁 PDFを選択して挿入
                    </button>
                </div>
            }
        </div>
    }
    else
    {
        @* サムネイルが0個の場合は最初の＋ボタンのみ *@
        <div class="flex items-center">
            <button
                class="w-8 h-8 bg-blue-500 hover:bg-blue-600 text-white rounded-full flex items-center justify-center text-lg font-bold shadow-md"
                @onclick="() => ToggleInsertMenu(0)">
                +
            </button>
            @if (showInsertMenuIndex == 0)
            {
                <div class="fixed inset-0 z-40" @onclick="() => ToggleInsertMenu(-1)"></div>
                <div class="absolute top-10 left-0 bg-white border border-gray-300 rounded shadow-lg min-w-48 z-50">
                    <button class="w-full px-4 py-2 text-left hover:bg-gray-100 border-b border-gray-200"
                        @onclick="() => InsertBlankPage(0)">
                        📄 空白ページの挿入
                    </button>
                    <button class="w-full px-4 py-2 text-left hover:bg-gray-100" @onclick="() => InsertPdfAtPosition(0)">
                        📁 PDFを選択して挿入
                    </button>
                </div>
            }
        </div>
    }
</div>

<InputFile OnChange="HandleInsertFileSelectionAsync" style="display: none;" id="insertFileInput" />

<style>
    .thumbnail-item:hover .menu-overlay {
        display: flex !important;
    }

    .sortable-item-container {
        cursor: move;
    }
</style>

@code {
    private bool isFilesLoaded = false;
    private bool isLoading = false;
    private int progress = 0;

    private List<byte[]> pdfDataList = new();
    private List<string> pdfPageDataList = new(); // ページレベルでのPDFデータ管理（base64文字列）
    private string? mergedPdfUrl;
    private string? errorMessage;
    private List<string> pageThumbnails = new();

    // 静的インスタンスで現在のコンポーネントを参照（並び替え用）
    private static Merge? _currentInstance;

    // JavaScript から呼び出される並び替えメソッド
    [JSInvokable("UpdateOrder")]
    public static void UpdateOrder(int oldIndex, int newIndex)
    {
        Console.WriteLine($"UpdateOrder called with oldIndex: {oldIndex}, newIndex: {newIndex}");

        if (_currentInstance != null)
        {
            Console.WriteLine($"Current instance found, calling UpdateOrderInternal");
            _currentInstance.UpdateOrderInternal(oldIndex, newIndex);
        }
        else
        {
            Console.WriteLine($"ERROR: Current instance is null!");
        }
    }

    // 実際の並び替え処理
    private void UpdateOrderInternal(int oldIndex, int newIndex)
    {
        Console.WriteLine($"UpdateOrderInternal called: {oldIndex} -> {newIndex}");

        if (oldIndex >= 0 && oldIndex < pageThumbnails.Count &&
        newIndex >= 0 && newIndex < pageThumbnails.Count &&
        oldIndex != newIndex)
        {
            Console.WriteLine($"Moving data from index {oldIndex} to {newIndex}");

            // データ配列のみ並び替え（DOM操作はしない）
            var thumbnail = pageThumbnails[oldIndex];
            var pageData = pdfPageDataList[oldIndex];

            pageThumbnails.RemoveAt(oldIndex);
            pdfPageDataList.RemoveAt(oldIndex);

            pageThumbnails.Insert(newIndex, thumbnail);
            pdfPageDataList.Insert(newIndex, pageData);

            Console.WriteLine($"Data reordered successfully: {oldIndex} -> {newIndex}");

            // StateHasChanged()は呼ばない（DOM操作はSortable.jsに任せる）
            // await InvokeAsync(() => StateHasChanged()); // この行をコメントアウト
        }
        else
        {
            Console.WriteLine($"Invalid move operation: oldIndex={oldIndex}, newIndex={newIndex}, count={pageThumbnails.Count}");
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (isFilesLoaded && firstRender)
        {
            await JSRuntime.InvokeVoidAsync("initializeSortable");
        }
    }

    // ...existing code...
    private async Task OpenFileDialog()
    {
        await JSRuntime.InvokeVoidAsync("openFileDialog", "fileInput");
    }

    private void RemovePage(int index)
    {
        if (index >= 0 && index < pageThumbnails.Count)
        {
            pageThumbnails.RemoveAt(index);
            if (index < pdfPageDataList.Count)
            {
                pdfPageDataList.RemoveAt(index);
            }
            Console.WriteLine($"Page {index} removed.");
            StateHasChanged(); // ← これを追加
        }
    }
    private async Task RotatePage(int index)
    {
        if (index >= 0 && index < pageThumbnails.Count)
        {
            try
            {
                Console.WriteLine($"Rotating page {index}...");

                // サムネイルを回転
                var thumbnail = pageThumbnails[index];
                var rotatedThumbnail = await JSRuntime.InvokeAsync<string>("rotateImage", thumbnail);
                if (rotatedThumbnail != null)
                {
                    pageThumbnails[index] = rotatedThumbnail;
                    Console.WriteLine($"Thumbnail {index} rotated successfully");
                }

                // 対応するPDFページも回転
                if (index < pdfPageDataList.Count)
                {
                    Console.WriteLine($"Rotating PDF page data {index}...");

                    // rotatePDFPage関数が存在するかチェック
                    var rotatedPageData = await JSRuntime.InvokeAsync<string>("rotatePDFPage", pdfPageDataList[index]);
                    if (rotatedPageData != null)
                    {
                        pdfPageDataList[index] = rotatedPageData;
                        Console.WriteLine($"PDF page data {index} rotated successfully");
                    }
                    else
                    {
                        Console.WriteLine($"rotatePDFPage returned null for page {index}");
                    }
                }

                StateHasChanged();
                Console.WriteLine($"Page {index} rotation completed.");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error rotating page {index}: {ex.Message}");
                errorMessage = $"ページ {index + 1} の回転に失敗しました: {ex.Message}";
            }
        }
    }

    private async Task HandleFileSelectionAsync(InputFileChangeEventArgs e)
    {
        isLoading = true;
        progress = 0;
        const long maxFileSize = 52428800; // 50MB

        foreach (var file in e.GetMultipleFiles())
        {
            try
            {
                using var stream = file.OpenReadStream(maxFileSize);
                using var memoryStream = new MemoryStream();
                var buffer = new byte[8192];
                long totalBytesRead = 0;
                int bytesRead;

                while ((bytesRead = await stream.ReadAsync(buffer, 0, buffer.Length)) > 0)
                {
                    await memoryStream.WriteAsync(buffer, 0, bytesRead);
                    totalBytesRead += bytesRead;

                    progress = (int)((totalBytesRead / (double)file.Size) * 100);
                    StateHasChanged();
                }

                var pdfData = memoryStream.ToArray();
                pdfDataList.Add(pdfData);

                // JavaScript でサムネイルを生成
                var newThumbnails = await JSRuntime.InvokeAsync<List<string>>("renderPDFPages", pdfData);
                if (newThumbnails != null)
                {
                    Console.WriteLine($"Generated {newThumbnails.Count} thumbnails");
                    pageThumbnails.AddRange(newThumbnails);

                    // extractPDFPagesを安全に呼び出し
                    try
                    {
                        Console.WriteLine("Calling extractPDFPages...");
                        var pageDataList = await JSRuntime.InvokeAsync<List<string>>("extractPDFPages", pdfData);
                        if (pageDataList != null)
                        {
                            Console.WriteLine($"Extracted {pageDataList.Count} pages");
                            pdfPageDataList.AddRange(pageDataList);
                        }
                        else
                        {
                            Console.WriteLine("extractPDFPages returned null");
                        }
                    }
                    catch (Exception jsEx)
                    {
                        Console.WriteLine($"JavaScript error in extractPDFPages: {jsEx.Message}");
                        // ページデータの抽出に失敗した場合、サムネイルのみで続行
                        errorMessage = $"ページデータの抽出に失敗しました: {file.Name}";
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error processing file {file.Name}: {ex.Message}");
                errorMessage = $"Error processing file {file.Name}. Please try again.";
            }
        }

        isLoading = false;
        isFilesLoaded = true;
        StateHasChanged();

        await InitializeSortableAfterLoad();

        Console.WriteLine($"Total thumbnails: {pageThumbnails?.Count}");
        Console.WriteLine($"Total page data: {pdfPageDataList?.Count}");
    }

    // PDFを結合する処理（並び替えが反映される）
    private async Task MergePDFs()
    {
        try
        {
            if (pdfPageDataList.Count == 0)
            {
                errorMessage = "No PDF files to merge.";
                Console.WriteLine("No files selected.");
                return;
            }

            errorMessage = null;
            // 並び替えられたページデータを使用してPDFを結合
            mergedPdfUrl = await JSRuntime.InvokeAsync<string>("mergePDFPages", pdfPageDataList);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"An error occurred: {ex.Message}");
            errorMessage = "An error occurred while merging PDFs. Please try again.";
        }
    }

    private async Task InitializeSortableAfterLoad()
    {
        if (isFilesLoaded && pageThumbnails.Any())
        {
            try
            {
                // DOMの更新を待つ
                await Task.Delay(200);

                Console.WriteLine("Initializing sortable after file load");
                await JSRuntime.InvokeVoidAsync("initializeSortable");

                Console.WriteLine("Sortable initialized successfully");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error initializing sortable: {ex.Message}");
            }
        }
    }

    protected override void OnAfterRender(bool firstRender)
    {
        if (firstRender)
        {
            _currentInstance = this;
            Console.WriteLine("Current instance set in OnAfterRenderAsync");
        }
    }

    private int showInsertMenuIndex = -1; // どの位置の挿入メニューを表示するか
    private int insertPosition = -1; // PDFを挿入する位置

    // 挿入メニューの表示/非表示を切り替え
    private void ToggleInsertMenu(int position)
    {
        if (showInsertMenuIndex == position)
        {
            Console.WriteLine($"Closing menu at position {position}");
            showInsertMenuIndex = -1; // 既に開いているメニューを閉じる
        }
        else if (position == -1)
        {
            Console.WriteLine("Closing menu from background click");
            showInsertMenuIndex = -1; // 背景クリックでメニューを閉じる
        }
        else
        {
            Console.WriteLine($"Opening menu at position {position}");
            showInsertMenuIndex = position; // 新しいメニューを開く
        }
        Console.WriteLine($"New showInsertMenuIndex: {showInsertMenuIndex}");
        StateHasChanged();
    }

    // 空白ページを挿入
    private async Task InsertBlankPage(int position)
    {
        try
        {
            Console.WriteLine($"Inserting blank page at position {position}");

            // 空白ページのPDFデータとサムネイルを生成
            var blankPageData = await JSRuntime.InvokeAsync<string>("createBlankPage");
            var blankThumbnail = await JSRuntime.InvokeAsync<string>("renderSinglePDFPage", blankPageData);

            if (blankPageData != null && blankThumbnail != null)
            {
                // 指定位置に挿入
                pageThumbnails.Insert(position, blankThumbnail);
                pdfPageDataList.Insert(position, blankPageData);

                Console.WriteLine($"Blank page inserted at position {position}");
                StateHasChanged();

                // Sortableを再初期化
                await Task.Delay(100);
                await InitializeSortableAfterLoad();
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error inserting blank page: {ex.Message}");
            errorMessage = $"空白ページの挿入に失敗しました: {ex.Message}";
        }
        finally
        {
            showInsertMenuIndex = -1; // メニューを閉じる
        }
    }

    // PDF挿入用のファイル選択
    private async Task InsertPdfAtPosition(int position)
    {
        insertPosition = position;
        showInsertMenuIndex = -1; // メニューを閉じる
        await JSRuntime.InvokeVoidAsync("openFileDialog", "insertFileInput");
    }

    // PDF挿入用のファイル処理
    private async Task HandleInsertFileSelectionAsync(InputFileChangeEventArgs e)
    {
        if (insertPosition == -1) return;

        const long maxFileSize = 52428800; // 50MB

        foreach (var file in e.GetMultipleFiles())
        {
            try
            {
                using var stream = file.OpenReadStream(maxFileSize);
                using var memoryStream = new MemoryStream();
                await stream.CopyToAsync(memoryStream);

                var pdfData = memoryStream.ToArray();

                // JavaScript でサムネイルを生成
                var newThumbnails = await JSRuntime.InvokeAsync<List<string>>("renderPDFPages", pdfData);
                var pageDataList = await JSRuntime.InvokeAsync<List<string>>("extractPDFPages", pdfData);

                if (newThumbnails != null && pageDataList != null)
                {
                    // 指定位置に挿入
                    for (int i = 0; i < newThumbnails.Count; i++)
                    {
                        pageThumbnails.Insert(insertPosition + i, newThumbnails[i]);
                        pdfPageDataList.Insert(insertPosition + i, pageDataList[i]);
                    }

                    Console.WriteLine($"Inserted {newThumbnails.Count} pages at position {insertPosition}");
                    StateHasChanged();

                    // Sortableを再初期化
                    await Task.Delay(100);
                    await InitializeSortableAfterLoad();
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error inserting PDF: {ex.Message}");
                errorMessage = $"PDFの挿入に失敗しました: {ex.Message}";
            }
        }

        insertPosition = -1; // リセット
    }
}