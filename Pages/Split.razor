@page "/split"
@implements IDisposable
@inject IJSRuntime JSRuntime
@inject PdfDataService PdfDataService
@inject CompletionStateService CompletionState
@using Microsoft.AspNetCore.Components.Web
@using Microsoft.JSInterop
@using System.IO
@using ClientPdfApp.Models
@using ClientPdfApp.Services
@using ClientPdfApp.Components

<PageTitle>分割</PageTitle>

@if (IsFilesLoaded && !CompletionState.ShowSplitOrExtractResult)
{
    <div id="drop-area" class="relative min-h-screen">
        <DropCover IsDragOver="isDragOver" Message="ここにファイルをドロップ" />
        <!-- 上部固定バー（編集モード） -->
        <div class="sticky top-0 left-0 w-full max-w-full bg-gray-800 text-white shadow z-50">
            <div
                class="flex items-center justify-between px-4 py-2 h-16 scrollbar-thin scrollbar-thumb-gray-400 scrollbar-track-gray-200">
                <div class="flex gap-2 items-center">

                    <ToggleButtonGroup T="string" Items="toggleItems" ActiveValue="CurrentModeString"
                        OnClick="OnToggleMode" />

                    <!-- 回転ボタングループ -->
                    <ActionButtonGroup T="string" Actions="rotateActions" />

                    <!-- 追加ボタングループ -->
                    <DropdownButton T="string" MenuId="addMenu" MenuItems="addMenuItems">
                        <Trigger>
                            <DropdownTriggerButton>
                                <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor">
                                    <path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z" />
                                </svg>
                                <span class="hidden md:inline">追加</span>
                            </DropdownTriggerButton>
                        </Trigger>
                    </DropdownButton>

                    <!-- 逆順ボタン -->
                    <ActionButtonGroup T="string" Actions="reverseActions" />

                    <!-- 並び替えボタングループ -->
                  <DropdownButton T="string" MenuId="sortMenu" MenuItems="sortMenuItems">
                        <Trigger>
                            <DropdownTriggerButton>
                                <i class="fa-solid fa-arrow-down-a-z"></i>
                                <span class="hidden md:inline">並び替え</span>
                            </DropdownTriggerButton>
                        </Trigger>
                    </DropdownButton>
                    @if (IsExtractMode)
                    {
                            <label class="flex items-center gap-2 bg-white text-gray-800 px-2 py-1 rounded cursor-pointer select-none">
                                <input type="checkbox" class="form-checkbox h-5 w-5 accent-blue-500"
                                    checked="@IsAllSelected"
                                    @onchange="ToggleAllExtractSelection" />
                                すべて選択
                            </label>
                            <label class="flex items-center gap-2 bg-white text-gray-800 px-2 py-1 rounded cursor-pointer select-none ml-2">
                            <input type="checkbox"
                                class="form-checkbox h-5 w-5 accent-blue-500"
                                @bind="IsExtractSplit"
                                disabled="@(ExtractSelectedCount < 2)" />
                            分割する
                        </label>
                    }
                </div>

                <ActionButtonGroup T="string" Actions="primaryActions" />

            </div>
            
        </div>

        <!-- サムネイル編集エリア -->
        <div class="md:p-0 p-3">
            @if (DisplayItems != null && DisplayItems.Any())
            {
                <div class="flex flex-col gap-1 p-2 md:flex-row md:flex-wrap md:gap-4 md:p-6" id="sortable-container">
                    @for (int i = 0; i < DisplayItems.Count; i++)
                    {
                        var item = DisplayItems[i];
                        <ThumbnailCard 
                            @key="item.Id"
                            Item="@item" Index="@i" DisplayItemsCount="DisplayItems.Count"
                            Mode="CurrentDisplayMode"
                            SplitPositions="PdfDataService.SplitInfo.SplitPositions" 
                            OperationMode="CurrentOperationMode"
                            OnCheckChanged="HandleCheckChanged"
                            OnShowPreview="args => ShowPreviewAsync(args.fileIndex, args.pageIndex)"
                            OnInsertBlankPage="InsertBlankPage"
                            OnInsertPdfAtPosition="InsertPdfAtPosition"
                            OnSwapWithNext="OnSwapWithNext" OnReloadPageItem="ReloadPageItem" OnRemove="RemovePage"
                            OnRotate="idx => (CurrentDisplayMode == DisplayMode.File ? RotateFile(DisplayItems[idx].Id) : RotatePage(idx))"
                            OnDuplicate="DuplicateItem" 
                            OnSelectChanged="HandleSelectChanged" />
                    }

                    <!-- 追加エリア -->
                    <FileAddArea
                        Position="@DisplayItems.Count"
                        OnInsertButtonClick="@(args => HandleInsertButtonClick(args.Position, args.E))"
                        OnAddFileClick="OpenFileDialog" />
                </div>
            }
        </div>
        <div class="fixed bottom-0 left-0 w-full z-50 md:hidden bg-white border-t border-gray-300 p-4">
            <button class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 rounded-lg text-lg"
                @onclick="ProcessPdfs">
                分割
            </button>
        </div>
    </div>
}
@if (previewIndex >= 0)
{
    <!-- 編集中のPDFプレビュー -->
    <PreviewModal IsOpen="@(previewIndex >= 0)" OnClose="ClosePreview" IsLoading="isPreviewLoading"
        ImageUrl="@previewImageUrl" PageIndex="@CurrentFilePageIndex" PageCount="@CurrentFilePageCount"
        ShowPageInput="@(CurrentDisplayMode == DisplayMode.File && CurrentFilePageCount > 1)" OnPageInputChanged="OnPreviewPageInputChanged"
        OnMovePreview="MovePreview" IsPrevDisabled="@(CurrentDisplayMode == DisplayMode.File? CurrentFilePageIndex == 0 : previewIndex == 0)"
        IsNextDisabled="@(CurrentDisplayMode == DisplayMode.File ? CurrentFilePageIndex == CurrentFilePageCount - 1 : (DisplayItems != null && DisplayItems.Any() ? previewIndex == DisplayItems.Count - 1 : true))"
        OnRotateLeft="RotatePreviewLeft" OnRotateRight="RotatePreviewRight" OnRemove="RemoveItemFromPreview" />
}
@if (!IsFilesLoaded && !CompletionState.ShowSplitOrExtractResult)
{
    <!-- 初期画面：ファイル選択 -->
    <SelectFilePanel OnOpenFileDialog="OpenFileDialog" isLoading="isLoading" progress="progress" />
}

@if (CompletionState.ShowSplitOrExtractResult)
{
    <!-- PC: 横並び, タブレット以下: 縦並び -->
    <div class="sticky top-0 left-0 w-full bg-gray-800 text-white shadow z-50 h-16">
        <div class="flex items-center px-4 py-2 h-16">
            <ActionButtonGroup T="string" Actions="backToEditActions" />
        </div>
    </div>

    <!-- メインエリア -->
    <div class="overflow-hidden h-[calc(100vh-4rem)]">
        <div class="flex flex-col md:flex-row h-full">
            <!-- PDF結果プレビュー -->
            <div class="flex flex-col flex-1 gap-4 overflow-y-auto pr-4 items-center">
                @foreach (var info in resultPdfInfos)
                {
                    <div class="flex flex-row items-center bg-white rounded shadow p-3 mb-2 w-full max-w-lg">
                        @if (!string.IsNullOrEmpty(info.ThumbnailUrl))
                        {
                            <img src="@info.ThumbnailUrl" alt="サムネイル"
                                class="w-16 h-20 object-contain ml-4 border border-gray-300" />
                        }
                        else
                        {
                            <div class="w-16 h-20 ml-4 flex items-center justify-center text-gray-400 bg-gray-100 border border-gray-300">
                                <i class="fa-solid fa-file-pdf text-2xl"></i>
                            </div>
                        }
                        <div class="flex flex-col flex-1 items-center">
                            <div class="font-bold text-lg mb-2">@info.Name</div>
                            <div class="text-gray-600 text-sm mb-1">サイズ: @info.Size</div>
                            <div class="text-gray-600 text-sm mb-2">ページ数: @info.PageCount</div>
                            <button class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded"
                                    @onclick="() => DownloadResultPdf(info)">
                                ダウンロード
                            </button>
                        </div>
                    </div>
                }
            </div>
            <!-- 情報パネル（PCのみ表示） -->
            <div
                class="hidden md:flex flex-col w-full max-w-xs bg-white border-l border-gray-200 shadow-lg h-full p-6 justify-center items-center">
                <InfoPanel Title="完了" FileName="@resultZipName" FileSize="@resultZipSize" PageCount="@resultTotalPageCount">
                    <SplitButton
                        PrimaryLabel="ダウンロード"
                        OnPrimaryClick="DownloadResultPdfs"
                        MenuItems="@resultDownloadMenuItems" />
                   <button
                        class="bg-white hover:bg-gray-100 border-1 border-solid border-gray-300 font-bold py-2 px-6 rounded-lg w-full flex items-center justify-center mt-4"
                        @onclick="StartNew">
                        <i class="fa-solid fa-rotate-right mr-2"></i>
                        新規作成
                    </button>
                </InfoPanel>
            </div>
        </div>
        <!-- 下部スライドアップメニュー（タブレット以下のサイズのみ） -->
        <div class="md:hidden fixed bottom-0 left-0 w-full z-[200]">
            <div
                class="@($"transition-transform will-change-transform duration-300 bg-white border-t border-gray-300 shadow-lg p-4 {(isMenuOpen ? "translate-y-0" : "translate-y-full")}")">
                <div class="flex flex-col items-center gap-4">
                    <div class="flex items-center gap-2 text-green-600 text-2xl font-bold">
                        <i class="fa-solid fa-check-circle"></i>
                        <span>完了</span>
                    </div>
                    <div class="text-gray-800 font-semibold truncate w-full text-center">@resultZipName</div>
                    <div class="text-gray-600 text-sm">サイズ: @resultZipSize</div>
                    <div class="text-gray-600 text-sm">総ページ数: @resultTotalPageCount</div>
                    <SplitButton
                        PrimaryLabel="ダウンロード"
                        OnPrimaryClick="DownloadResultPdfs"
                        MenuItems="@resultDownloadMenuItems" />
                    <button
                        class="bg-neutral-500 hover:bg-neutral-600 text-white font-bold py-2 px-6 rounded-lg w-full flex items-center justify-center mt-4"
                        @onclick="StartNew">
                        <i class="fa-solid fa-rotate-right mr-2"></i>
                        新規作成
                    </button>
                </div>
                <button class="absolute top-2 right-4 text-2xl text-gray-500" @onclick="() => isMenuOpen = false">
                    <i class="fa-solid fa-xmark"></i>
                </button>
            </div>
            <!-- 展開ボタン -->
            @if (!isMenuOpen)
            {
                <button
                    class="fixed bottom-4 left-1/2 -translate-x-1/2 z-[201] bg-white rounded-full shadow px-8 py-3 border border-gray-300 flex items-center gap-3 text-lg font-bold hover:bg-blue-50 transition min-w-[260px]"
                    @onclick="() => isMenuOpen = true">
                    <i class="fa-solid fa-check-circle text-green-600 text-2xl"></i>
                    <span>完了</span>
                    <i class="fa-solid fa-chevron-up ml-2"></i>
                </button>
            }
        </div>
        <!-- メニュー展開時はPDFのスクロールを禁止 -->
        @if (isMenuOpen)
        {
            <div class="fixed inset-0 bg-black/30 z-[199] touch-none" @onclick="() => isMenuOpen = false"></div>
        }
    </div>
}
@if (isBusy)
{
    <LoadingOverlay Message="処理中です..." />
}
<!-- メッセージ表示エリア -->
@if (!string.IsNullOrEmpty(errorMessage) || !string.IsNullOrEmpty(warnMessage))
{
    <MessageBar Message="@(errorMessage ?? warnMessage)" IsError="@(errorMessage != null)" OnClose="ClearAllMessages" />
}

<!-- ファイル選択用の隠しinput -->
<InputFile OnChange="HandleFileSelectionAsync" multiple class="hidden" id="fileInput" />

@code {

    protected override void OnInitialized()
    {
        PdfDataService.OnChange += OnServiceChanged;
        // ページ単位表示を強制
        PdfDataService.SwitchDisplayMode(DisplayMode.Page);
    }

    private void OnServiceChanged()
    {
        InvokeAsync(StateHasChanged);
    }

    public void Dispose()
    {
        PdfDataService.OnChange -= OnServiceChanged;
    }
    private bool isLoading = false;
    private bool isBusy = false;
    private int progress = 0;
    private string? errorMessage;
    private string? warnMessage;

    // 統一アーキテクチャ対応プロパティ
    private DisplayMode CurrentDisplayMode => PdfDataService.GetModel().CurrentMode;
    private List<DisplayItem> DisplayItems => PdfDataService.GetDisplayItems();
    private bool IsFilesLoaded => DisplayItems.Any();

    private OperationMode CurrentOperationMode = OperationMode.Split;
    private bool IsSplitMode => CurrentOperationMode == OperationMode.Split;
    private bool IsExtractMode => CurrentOperationMode == OperationMode.Extract;

    private int previewIndex = -1;

    private string? previewImageUrl = null;
    private bool isPreviewLoading = false;
    // ファイル単位表示時の現在ページ番号（0始まり）
    private int CurrentFilePageIndex => GetCurrentFilePageIndex();
    // ファイル単位表示時の総ページ数
    private int CurrentFilePageCount => GetCurrentFilePageCount();

    // ファイル単位表示時のファイル内ページ番号（0始まり）
    // プレビュー中のファイル内で、何ページ目を表示しているか
    private int filePageIndex = 0;
    private DotNetObjectReference<Split>? _dotNetRef;
    private bool isDragOver = false;
    private bool isMenuOpen = false;
    private bool showDownloadMenu = false;
    private string resultZipUrl = "";
    private string resultZipName = "";
    private string resultZipSize = "";
    private int resultTotalPageCount = 0;

    private bool IsExtractSplit { get; set; } = true; // デフォルトは分割出力
    private int ExtractSelectedCount => DisplayItems.Count(x => x.IsSelectedForExtract);
    private bool IsAllSelected => DisplayItems.Count > 0 && DisplayItems.All(x => x.IsSelectedForExtract);
    private int GetCurrentFilePageIndex()
    {
        if (CurrentDisplayMode == DisplayMode.Page || previewIndex < 0 || previewIndex >= DisplayItems.Count)
            return 0;
        return filePageIndex;
    }
    private int GetCurrentFilePageCount()
    {
        if (CurrentDisplayMode == DisplayMode.Page || previewIndex < 0 || previewIndex >= DisplayItems.Count)
            return 1;
        return DisplayItems[previewIndex].PageCount;
    }

    private List<ActionButtonItem> primaryActions => new()
    {
        new ActionButtonItem
        {
            Label = GetPrimaryActionLabel(),
            IconHtml = "<i class='fa-solid fa-arrow-right text-xl ml-2'></i>",
            Title = GetPrimaryActionLabel(),
            OnClick = EventCallback.Factory.Create(this, ProcessPdfs),
            ButtonClass = "bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-8 rounded-lg min-w-[44px] transition hidden md:flex h-[44px]",
            IconPosition = "right"
        }
    };

    private List<ActionButtonItem> backToEditActions => new()
    {
        new ActionButtonItem
        {
            Label = "編集に戻る",
            IconHtml = "<i class='fa-solid fa-arrow-left'></i>",
            Title = "編集に戻る",
            OnClick = EventCallback.Factory.Create(this, BackToEdit),
        }
    };

    private List<SplitButton.MenuActionItem> resultDownloadMenuItems => new()
    {
        new SplitButton.MenuActionItem
        {
            Label = "PDFでダウンロード",
            OnClick = EventCallback.Factory.Create(this, DownloadResultPdfs)
        },
        new SplitButton.MenuActionItem
        {
            Label = "PNG画像でダウンロード",
            OnClick = EventCallback.Factory.Create(this, DownloadResultPngs)
        }
    };

    private string GetPrimaryActionLabel()
    {
        if (CurrentOperationMode == OperationMode.Split)
        {
            var splitCount = PdfDataService.SplitInfo?.SplitPositions.Count ?? 0;
            if (splitCount > 0)
            {
                return $"{splitCount + 1}ファイルに分割";
            }
        }
        if (CurrentOperationMode == OperationMode.Extract)
        {
            var extractCount = DisplayItems.Count(x => x.IsSelectedForExtract);
            if (extractCount > 0)
            {
                return $"{extractCount}ページ抽出";
            }
        }
        return "完了";
    }

    private async Task MovePreview(int direction)
    {
        if (CurrentDisplayMode == DisplayMode.File)
        {
            var pageCount = DisplayItems[previewIndex].PageCount;
            var nextPage = filePageIndex + direction;
            if (nextPage >= 0 && nextPage < pageCount)
            {
                filePageIndex = nextPage;
                await ShowPreviewAsync(previewIndex, filePageIndex);
            }
        }
        else
        {
            var nextIndex = previewIndex + direction;
            if (nextIndex >= 0 && nextIndex < DisplayItems.Count)
            {
                await ShowPreviewAsync(nextIndex);
            }
        }
    }
    private async Task OnPreviewPageInputChanged(ChangeEventArgs e)
    {
        if (CurrentDisplayMode == DisplayMode.Page) return;

        if (int.TryParse(e.Value?.ToString(), out int inputPage))
        {
            // 1以上、最大ページ数以下のみ有効
            if (inputPage >= 1 && inputPage <= CurrentFilePageCount)
            {
                filePageIndex = inputPage - 1;
                await ShowPreviewAsync(previewIndex, filePageIndex);
            }
        }
    }
    private async Task RotatePreviewLeft()
    {
        if (previewIndex >= 0 && previewIndex < DisplayItems.Count)
        {
            await PdfDataService.RotateItemAsync(previewIndex, -90);
            await ShowPreviewAsync(previewIndex);
        }
    }

    private async Task RotatePreviewRight()
    {
        if (previewIndex >= 0 && previewIndex < DisplayItems.Count)
        {
            await PdfDataService.RotateItemAsync(previewIndex, 90);
            await ShowPreviewAsync(previewIndex);
        }
    }


    private async Task ShowPreviewAsync(int fileIndex, int pageIndex = 0)
    {
        previewIndex = fileIndex;
        filePageIndex = pageIndex;
        previewImageUrl = null;
        isPreviewLoading = true;
        StateHasChanged();

        try
        {
            if (CurrentDisplayMode == DisplayMode.File)
            {
                // 修正: 残っているページリストからOriginalPageIndexを取得して渡す
                var fileId = DisplayItems[fileIndex].Id;
                var model = PdfDataService.GetModel();
                var filePages = model.Pages.Where(p => p.FileId == fileId).OrderBy(p => p.OriginalPageIndex).ToList();
                if (pageIndex >= 0 && pageIndex < filePages.Count)
                {
                    var page = filePages[pageIndex];
                    previewImageUrl = await PdfDataService.GetPreviewImageAsync(fileId, page.OriginalPageIndex);
                }
                else
                {
                    previewImageUrl = null;
                }
            }
            else
            {
                // ページ単位表示時は従来通り
                previewImageUrl = await PdfDataService.GetPreviewImageAsync(DisplayItems[fileIndex].Id);
            }
        }
        catch
        {
            // 失敗時はサムネイル表示
            previewImageUrl = DisplayItems[fileIndex].Thumbnail;
        }

        isPreviewLoading = false;
        StateHasChanged();
    }


    private void ClosePreview()
    {
        previewIndex = -1;
        StateHasChanged();
    }

    public class MergePageDto
    {
        public string FileId { get; set; } = "";
        public string FileName { get; set; } = "";
        public string PageData { get; set; } = "";
        public bool IsPdf { get; set; }
        public int RotateAngle { get; set; }
    }


    public class ResultPdfInfo
    {
        public string Url { get; set; } = "";
        public string Name { get; set; } = "";
        public string Size { get; set; } = "";
        public int PageCount { get; set; }
        public string? ThumbnailUrl { get; set; } // ←追加
    }
    private List<ResultPdfInfo> resultPdfInfos = new();

    private async Task ProcessPdfs()
    {
        if (CurrentOperationMode == OperationMode.Split)
        {
            await ProcessSplit();
        }
        else if (CurrentOperationMode == OperationMode.Extract)
        {
            await ProcessExtract();
        }
    }
    private async Task ProcessSplit()
    {
        try
        {
            isBusy = true;
            StateHasChanged();
            await Task.Yield();

            var allPages = PdfDataService.GetModel().Pages;

            // 準備できていないページがある場合は中断
            var notReadyCount = allPages.Count(item => string.IsNullOrEmpty(item.PageData) || item.HasError);
            if (notReadyCount > 0)
            {
                ShowWarn($"PDFの読み込みが完了していないページが {notReadyCount} ページあります。");
                return;
            }
            if (allPages.Count == 0)
            {
                ShowError("分割対象がありません。");
                return;
            }

            errorMessage = null;

            var splitGroups = new List<List<PageItem>>();
            var currentGroup = new List<PageItem>();
            foreach (var page in allPages)
            {
                if (currentGroup.Count > 0 && PdfDataService.SplitInfo.SplitPositions.Contains(page.OriginalPageIndex))
                {
                    splitGroups.Add(currentGroup);
                    currentGroup = new List<PageItem>();
                }
                currentGroup.Add(page);
            }
            if (currentGroup.Count > 0)
                splitGroups.Add(currentGroup);

            resultPdfInfos.Clear();
            int groupIndex = 1;
            foreach (var group in splitGroups)
            {
                var mergeData = group.Select(item => new MergePageDto
                {
                    FileId = item.FileId,
                    FileName = item.FileName,
                    PageData = item.PageData,
                    IsPdf = Path.GetExtension(item.FileName).ToLowerInvariant() == ".pdf",
                    RotateAngle = item.RotateAngle % 360
                }).ToList();

                var url = await JSRuntime.InvokeAsync<string>("mergePDFPages", mergeData);
                if (!string.IsNullOrEmpty(url))
                {
                    var name = $"split_{groupIndex}_{DateTime.Now:yyyyMMddHHmm}.pdf";
                    var size = await JSRuntime.InvokeAsync<string>("getPdfFileSize", url);
                    resultPdfInfos.Add(new ResultPdfInfo
                    {
                        Url = url,
                        Name = name,
                        Size = size,
                        PageCount = group.Count
                    });
                }
                else
                {
                    ShowError($"PDFの分割に失敗しました。グループ {groupIndex} のページ数: {group.Count}");
                    return;
                }
                groupIndex++;
            }

            // zip作成
            if (resultPdfInfos.Count > 0)
            {
                resultZipName = $"split_{DateTime.Now:yyyyMMddHHmm}.zip";
                var pdfUrls = resultPdfInfos.Select(x => x.Url).ToList();
                var pdfNames = resultPdfInfos.Select(x => x.Name).ToList();
                resultZipUrl = await JSRuntime.InvokeAsync<string>("createZipFromUrls", pdfUrls, pdfNames,  resultZipName);
                resultZipSize = await JSRuntime.InvokeAsync<string>("getZipFileSize", resultZipUrl);
                resultTotalPageCount = resultPdfInfos.Sum(x => x.PageCount);
                CompletionState.SetCompletion(CompletionStateService.CompletionType.SplitOrExtract );

            }
            else
            {
                ShowError("分割PDFの生成に失敗しました。");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"An error occurred: {ex.Message}");
            ShowError("PDFの分割中にエラーが発生しました。");
        }
        finally
        {
            isBusy = false;
            StateHasChanged();
        }
    }

    private async Task ProcessExtract()
    {
        try
        {
            isBusy = true;
            StateHasChanged();
            await Task.Yield();

            var selectedPages = PdfDataService.GetModel().Pages
                .Where(p => p.IsSelectedForExtract)
                .ToList();

            if (selectedPages.Count == 0)
            {
                ShowWarn("抽出対象が選択されていません。");
                return;
            }

            var notReadyCount = selectedPages.Count(item => string.IsNullOrEmpty(item.PageData) || item.HasError);
            if (notReadyCount > 0)
            {
                ShowWarn($"抽出対象に読み込み未完了またはエラーのページが {notReadyCount} ページあります。");
                return;
            }

            resultPdfInfos.Clear();

            if (IsExtractSplit)
            {
                int pageIndex = 1;
                foreach (var page in selectedPages)
                {
                    var mergeData = new List<MergePageDto>
                    {
                        new MergePageDto
                        {
                            FileId = page.FileId,
                            FileName = page.FileName,
                            PageData = page.PageData,
                            IsPdf = Path.GetExtension(page.FileName).ToLowerInvariant() == ".pdf",
                            RotateAngle = page.RotateAngle % 360
                        }
                    };

                    var url = await JSRuntime.InvokeAsync<string>("mergePDFPages", mergeData);
                    if (!string.IsNullOrEmpty(url))
                    {
                        var name = $"extract_{pageIndex}_{DateTime.Now:yyyyMMddHHmm}.pdf";
                        var size = await JSRuntime.InvokeAsync<string>("getPdfFileSize", url);
                        resultPdfInfos.Add(new ResultPdfInfo
                        {
                            Url = url,
                            Name = name,
                            Size = size,
                            PageCount = 1
                        });
                    }
                    pageIndex++;
                }
            }
            else
            {
                // 結合して1つのPDFとして出力
                var mergeData = selectedPages.Select(page => new MergePageDto
                {
                    FileId = page.FileId,
                    FileName = page.FileName,
                    PageData = page.PageData,
                    IsPdf = Path.GetExtension(page.FileName).ToLowerInvariant() == ".pdf",
                    RotateAngle = page.RotateAngle % 360
                }).ToList();

                var url = await JSRuntime.InvokeAsync<string>("mergePDFPages", mergeData);
                if (!string.IsNullOrEmpty(url))
                {
                    var name = $"extract_merged_{DateTime.Now:yyyyMMddHHmm}.pdf";
                    var size = await JSRuntime.InvokeAsync<string>("getPdfFileSize", url);
                    resultPdfInfos.Add(new ResultPdfInfo
                    {
                        Url = url,
                        Name = name,
                        Size = size,
                        PageCount = selectedPages.Count
                    });
                }
            }

            // ZIP作成などSplitと同様の後処理
            if (resultPdfInfos.Count > 0)
            {
                resultZipName = $"extract_{DateTime.Now:yyyyMMddHHmm}.zip";
                var pdfUrls = resultPdfInfos.Select(x => x.Url).ToList();
                var pdfNames = resultPdfInfos.Select(x => x.Name).ToList();
                resultZipUrl = await JSRuntime.InvokeAsync<string>("createZipFromUrls", pdfUrls, pdfNames, resultZipName);
                resultZipSize = await JSRuntime.InvokeAsync<string>("getZipFileSize", resultZipUrl);
                resultTotalPageCount = resultPdfInfos.Sum(x => x.PageCount);
                CompletionState.SetCompletion(CompletionStateService.CompletionType.SplitOrExtract  );
            }
            else
            {
                ShowError("抽出PDFの生成に失敗しました。");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"An error occurred: {ex.Message}");
            ShowError("PDFの抽出中にエラーが発生しました。");
        }
        finally
        {
            isBusy = false;
            StateHasChanged();
        }
    }

    // アイテム削除
    private void RemovePage(int index)
    {

        try
        {
            PdfDataService.RemoveItem(index);
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error removing item {index}: {ex.Message}");
            errorMessage = $"削除に失敗しました: {ex.Message}";
        }
    }


    // ファイルダイアログを開く
    private async Task OpenFileDialog()
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("openFileDialog", "fileInput");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error opening file dialog: {ex.Message}");
            errorMessage = $"ファイル選択ダイアログの表示に失敗しました: {ex.Message}";
        }
    }

    // その他のメソッド
    private void BackToEdit()
    {
        CompletionState.ResetAll();
        StateHasChanged();
    }

    private void StartNew()
    {
        CompletionState.ResetAll();

        AppResetHelper.ResetPage(
            PdfDataService,
            () => { /* ページ固有の状態リセット */ },
            () => { 

                resultPdfInfos.Clear();
                resultZipUrl = "";
                resultZipName = "";
                resultZipSize = "";
                resultTotalPageCount = 0;
            },
            msg => errorMessage = msg,
            StateHasChanged
        );
    }

    private void ClearErrorMessage()
    {
        errorMessage = null;
        StateHasChanged();
    }

    // 隣接サムネイルとの入れ替え機能
    private async Task OnSwapWithNext(int index)
    {
        try
        {
            PdfDataService.SwapWithNext(index);
            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            errorMessage = $"サムネイルの入れ替えに失敗しました: {ex.Message}";
        }
    }

    // 回転処理
    private async Task RotatePage(int index, int angle = 90)
    {
        if (index >= 0 && index < DisplayItems.Count)
        {
            try
            {
                await PdfDataService.RotateItemAsync(index, angle);
                StateHasChanged();
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error rotating item {index}: {ex.Message}");
                errorMessage = $"アイテム {index + 1} の回転に失敗しました: {ex.Message}";
            }
        }
    }

    private async Task RotateFile(string fileId)
    {
        await PdfDataService.RotateFileAsync(fileId, 90);
        StateHasChanged();
    }

    private Task RotateAllLeft() => RotateAll(-90);
    private Task RotateAllRight() => RotateAll(90);
    private async Task RotateAll(int angle)
    {
        isBusy = true;
        StateHasChanged();
        await Task.Yield();

        await PdfDataService.RotateAllAsync(CurrentDisplayMode, DisplayItems, angle);

        isBusy = false;
        StateHasChanged();
    }

    private async void RemoveItemFromPreview()
    {
        if (CurrentDisplayMode == DisplayMode.File)
        {
            var fileId = DisplayItems[previewIndex].Id;
            int removedPageIndex = filePageIndex;

            PdfDataService.RemovePageFromFile(fileId, removedPageIndex);
            await InvokeAsync(StateHasChanged);

            var items = DisplayItems;
            var newIndex = items.FindIndex(x => x.Id == fileId);

            if (newIndex >= 0 && items[newIndex].PageCount > 0)
            {
                int pageCount = items[newIndex].PageCount;
                // インデックス再計算
                filePageIndex = (removedPageIndex >= pageCount) ? pageCount - 1 : removedPageIndex;
                if (filePageIndex < 0) filePageIndex = 0;
                previewIndex = newIndex;

                await ShowPreviewAsync(previewIndex, filePageIndex);
            }
            else
            {
                // ファイル自体が消えた場合、次のインデックスにプレビューを移動
                if (items.Count > 0)
                {
                    previewIndex = Math.Min(previewIndex, items.Count - 1);
                    filePageIndex = 0;
                    await ShowPreviewAsync(previewIndex, filePageIndex);
                }
                else
                {
                    ClosePreview();
                }
            }
        }
        else
        {
            PdfDataService.RemoveItem(previewIndex);
            var items = DisplayItems;
            if (items.Count > 0)
            {
                previewIndex = Math.Min(previewIndex, items.Count - 1);
                await ShowPreviewAsync(previewIndex);
            }
            else
            {
                ClosePreview();
            }
        }
    }
    private async Task DuplicateItem(int index)
    {
        if (CurrentDisplayMode == DisplayMode.File)
        {
            var fileItem = DisplayItems[index];
            await PdfDataService.DuplicateItemAsync(fileItem.Id, true, index + 1);
        }
        else if (CurrentDisplayMode == DisplayMode.Page)
        {
            var pageItem = DisplayItems[index];
            await PdfDataService.DuplicateItemAsync(pageItem.Id, false, index + 1);
        }
        StateHasChanged();
    }

    // 挿入ボタンクリック処理
    private async Task HandleInsertButtonClick(int position, MouseEventArgs e)
    {

        try
        {
            // JavaScriptの挿入メニューを表示
            await JSRuntime.InvokeVoidAsync("showInsertMenuAtExactPosition", position, e.ClientX, e.ClientY);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error showing insert menu: {ex.Message}");
            errorMessage = $"メニュー表示に失敗しました: {ex.Message}";
        }
    }

    // 静的インスタンスで現在のコンポーネントを参照（JavaScript連携用）
    public static Split? _currentInstance;

    // 実際の並び替え処理
    public async Task UpdateOrderInternal(string pageType, int oldIndex, int newIndex)
    {
        try
        {
            if (oldIndex >= 0 && oldIndex < DisplayItems.Count &&
            newIndex >= 0 && newIndex < DisplayItems.Count &&
            oldIndex != newIndex)
            {
                // 統一データサービスを使用して並び替え
                PdfDataService.MoveItem(oldIndex, newIndex);

                // DOM更新
                await InvokeAsync(async () =>
                {
                    await InvokeAsync(StateHasChanged);
                    await JSRuntime.InvokeVoidAsync("initializeSortable");
                });
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error in UpdateOrderInternal: {ex.Message}");
            errorMessage = $"並び替えに失敗しました: {ex.Message}";
        }
    }

    // JavaScript から呼び出されるPDF挿入メソッド
    [JSInvokable("Split_InsertPdfAtPositionFromJS")]
    public static async Task InsertPdfAtPositionFromJS(int position)
    {
        if (_currentInstance != null)
        {
            await _currentInstance.InsertPdfAtPosition(position);
        }
    }

    // 空白ページを挿入
    public async Task InsertBlankPage(int position)
    {
        isBusy = true;
        StateHasChanged();
        await Task.Yield();

        await PdfDataService.InsertBlankPageWithDisplayModeAsync(
            CurrentDisplayMode, DisplayItems, position);
        
        isBusy = false;
        StateHasChanged();
    }

    // PDF挿入
    public async Task InsertPdfAtPosition(int position)
    {
        await PdfDataService.OpenInsertPdfDialogAsync(
            CurrentDisplayMode,
            DisplayItems,
            position,
            pos => insertPosition = pos,
            msg => errorMessage = msg
        );
    }

    private int insertPosition = -1;

    // 挿入用ファイル選択処理
    private async Task HandleFileSelectionAsync(InputFileChangeEventArgs e)
    {
        isBusy = true;
        StateHasChanged();
        await Task.Yield();

        await PdfDataService.HandleFileInputAsync(
            e,
            insertPosition >= 0 ? insertPosition : null,
            msg => errorMessage = msg,
            () => isLoading = true,
            () => isLoading = false
        );
        insertPosition = -1;
        isBusy = false;
        StateHasChanged();
    }

    private List<DropdownMenuItem> addMenuItems => new()
{
new DropdownMenuItem
{
Label = "空白ページを追加",
OnClick = EventCallback.Factory.Create(this, () => InsertBlankPage(DisplayItems.Count))
},
new DropdownMenuItem
{
Label = "ドキュメントを追加",
OnClick = EventCallback.Factory.Create(this, () => InsertPdfAtPosition(DisplayItems.Count))
}
};

    private List<DropdownMenuItem> sortMenuItems => new()
{
new DropdownMenuItem
{
Label = "名前（昇順）",
OnClick = EventCallback.Factory.Create(this, () => SelectSort(true))
},
new DropdownMenuItem
{
Label = "名前（降順）",
OnClick = EventCallback.Factory.Create(this, () => SelectSort(false))
}
};

    private List<ActionButtonItem> reverseActions => new()
{
new ActionButtonItem
{
Label = "逆順",
IconHtml = @"<svg width='20' height='20' viewBox='0 0 21 21' fill='none' class='mr-2 inline-block align-middle'><g
stroke='currentColor' stroke-linecap='round' stroke-linejoin='round'><path d='M4.5 8.5l-4 4 4 4' /><path d='M12.5
12.5h-12' /><path d='M8.5.5l4 4-4 4' /><path d='M12.5 4.5h-12' /></g></svg>",
Title = "逆順",
OnClick = EventCallback.Factory.Create(this, ReverseOrder)
}
};

    private List<ActionButtonItem> rotateActions => new()
    {
        new ActionButtonItem
        {
            Label = "左",
            IconHtml = "<span class='material-symbols-outlined'>rotate_left</span>",
            Title = "左回転",
            OnClick = EventCallback.Factory.Create(this, RotateAllLeft),
            IconPosition = "left"
        },
        new ActionButtonItem
        {
            Label = "右",
            IconHtml = "<span class='material-symbols-outlined'>rotate_right</span>",
            Title = "右回転",
            OnClick = EventCallback.Factory.Create(this, RotateAllRight),
            IconPosition = "left"
        }
    };

    private Task ReverseOrder()
    {
        isBusy = true;
        StateHasChanged();

        if (CurrentDisplayMode == DisplayMode.File)
        {
            // ファイル単位：ファイルごと逆順
            var model = PdfDataService.GetModel();
            var fileIds = DisplayItems.Select(x => x.Id).Reverse().ToList();
            PdfDataService.ReorderFiles(fileIds);
        }
        else if (CurrentDisplayMode == DisplayMode.Page)
        {
            // ページ単位：ページごと逆順
            PdfDataService.ReversePages();
        }

        StateHasChanged();
        isBusy = false;
        return Task.CompletedTask;
    }

    private void SelectSort(bool ascending)
    {
        SortByName(ascending);
    }
    private void SortByName(bool ascending)
    {
        if (CurrentDisplayMode == DisplayMode.File)
        {
            var sorted = ascending
            ? DisplayItems.OrderBy(x => x.DisplayName).Select(x => x.Id).ToList()
            : DisplayItems.OrderByDescending(x => x.DisplayName).Select(x => x.Id).ToList();
            PdfDataService.ReorderFiles(sorted);
        }
        else if (CurrentDisplayMode == DisplayMode.Page)
        {
            PdfDataService.SortPagesByName(ascending);
        }
        StateHasChanged();
    }

   [JSInvokable]
    public async Task OnJsFileDropped(string fileName, string contentType, string base64Data)
    {
        isBusy = true;
        StateHasChanged();
        await Task.Yield();

        try
        {
            await PdfDataService.HandleDroppedFileAsync(
                fileName,
                base64Data,
                msg => errorMessage = msg,
                async (name, data) => await PdfDataService.AddOrInsertPdfFileAsync(name, data, null),
                async (name, data) => await PdfDataService.AddOrInsertImageFileAsync(name, data, null)
            );
        }
        finally
        {
            isBusy = false;
            StateHasChanged();
        }
    }

    private List<ToggleButtonItem<string>> toggleItems = new()
{
new ToggleButtonItem<string>
{
Value = "Split",
Label = "分割",
IconSvg = @"<i class=""fa-solid fa-scissors""></i>"
},
new ToggleButtonItem<string>
{
Value = "Extract",
Label = "抽出",
IconSvg = @"<svg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 24 24' class='w-5 h-5 mr-1'><path fill='currentColor' fill-rule='evenodd' d='M14 4h5v6h-5zm-1-1h7v8h-7zm7 10h-7v8h7zm-10 1H5v6h5zm-5-1H4v8h7v-8zm6-10H4v8h7z' clip-rule='evenodd'></path></svg>"
}
};

    private string CurrentModeString => IsSplitMode ? "Split" : "Extract";

    private async Task OnToggleMode(string mode)
    {
        if (mode == "Split")
            CurrentOperationMode = OperationMode.Split;
        else if (mode == "Extract")
            CurrentOperationMode = OperationMode.Extract;

        StateHasChanged();
        await Task.Delay(100);
    }

    private bool _dropAreaRegistered = false;

    private void ToggleAllExtractSelection(ChangeEventArgs e)
    {
        bool check = e.Value is bool b && b;
        foreach (var item in DisplayItems)
        {
            if (item.IsSelectedForExtract != check)
            {
                PdfDataService.SetExtractSelection(item, check);
            }
        }
        StateHasChanged();
    }

    private void HandleSelectChanged(int index)
    {
        if (index >= 0 && index < DisplayItems.Count)
        {
            PdfDataService.ToggleExtractSelection(index);
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _currentInstance = this;
            _dotNetRef = DotNetObjectReference.Create(this);
        }
        // 初期画面のときのみ登録
        if (!IsFilesLoaded && !CompletionState.ShowSplitOrExtractResult)
        {
            await JSRuntime.InvokeVoidAsync("registerSelectDropArea", _dotNetRef);
        }
        if (showDownloadMenu)
        {
            await JSRuntime.InvokeVoidAsync(
            "registerOutsideClickForDownloadMenu",
            "downloadMenu",
            DotNetObjectReference.Create(this)
            );
        }
        // drop-areaが表示され、まだ登録していない場合のみ
        if (!_dropAreaRegistered && IsFilesLoaded && DisplayItems.Any())
        {
            await JSRuntime.InvokeVoidAsync("registerDropArea", "drop-area", _dotNetRef);
            _dropAreaRegistered = true;
        }
        else if (_dropAreaRegistered && (!IsFilesLoaded || !DisplayItems.Any()))
        {
            // drop-areaが消えたらフラグを戻す（必要ならJSでunregisterも）
            _dropAreaRegistered = false;
        }
        if (IsFilesLoaded && DisplayItems.Any())
        {
            foreach (var item in DisplayItems)
            {
                await JSRuntime.InvokeVoidAsync(
                "drawImageToCanvas",
                $"thumb-{item.Id}",
                item.Thumbnail
                );
            }
        }

        // 毎回ドラッグ&ドロップとソート機能を再初期化（DOM更新時に必要）
        if (IsFilesLoaded && DisplayItems.Any())
        {
            await InvokeAsync(async () =>
            {
                try
                {
                    await Task.Delay(50); // DOM更新完了を待つ
                    await JSRuntime.InvokeVoidAsync("initializeSortable");
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Error initializing interactions: {ex.Message}");
                }
            });
        }

        // サムネイル未取得のPDFだけ順次取得
        foreach (var info in resultPdfInfos)
        {
            if (string.IsNullOrEmpty(info.ThumbnailUrl))
            {
                // 例: JSでPDFの1ページ目サムネイルを取得する場合
                info.ThumbnailUrl = await JSRuntime.InvokeAsync<string>(
                    "getPdfThumbnailUrl", info.Url);

                StateHasChanged(); // 取得ごとに再描画
                await Task.Delay(50); // 負荷軽減のため少し待つ
            }
        }

    }
    [JSInvokable]
    public void SetDragOver(bool over)
    {
        isDragOver = over;
        StateHasChanged();
    }
    [JSInvokable]
    public void CloseDownloadMenu()
    {
        showDownloadMenu = false;
        StateHasChanged();
    }
    private async void DownloadResultPdfs()
    {
        if (string.IsNullOrEmpty(resultZipUrl) || string.IsNullOrEmpty(resultZipName))
            return;

        try
        {
            await JSRuntime.InvokeVoidAsync(
                "downloadFileFromUrl",
                resultZipUrl,
                resultZipName,
                "application/zip"
            );
        }
        catch (Exception ex)
        {
            errorMessage = $"ZIPのダウンロードに失敗しました: {ex.Message}";
            StateHasChanged();
        }
    }

    private async void ShowError(string msg)
    {
        errorMessage = msg;
        warnMessage = null;
        StateHasChanged();
        await Task.Delay(5000);
        if (errorMessage == msg) // 他のメッセージで上書きされていなければ
        {
            errorMessage = null;
            StateHasChanged();
        }
    }


    private async void ShowWarn(string msg)
    {
        warnMessage = msg;
        errorMessage = null;
        StateHasChanged();
        await Task.Delay(5000);
        if (warnMessage == msg)
        {
            warnMessage = null;
            StateHasChanged();
        }
    }

    private void ClearAllMessages()
    {
        errorMessage = null;
        warnMessage = null;
        StateHasChanged();
    }
    private async Task DownloadResultPdf(ResultPdfInfo info)
    {
        await JSRuntime.InvokeVoidAsync("downloadFileFromUrl", info.Url, info.Name, "application/pdf");
    }

    private async void DownloadResultPngs()
    {
        if (resultPdfInfos == null || resultPdfInfos.Count == 0)
            return;

        try
        {
            // 各PDFごとにPNG変換し、まとめてZIPでダウンロード
            var pdfUrls = resultPdfInfos.Select(x => x.Url).ToList();
            var pdfNames = resultPdfInfos.Select(x => x.Name).ToList();
            var zipName = Path.GetFileNameWithoutExtension(resultZipName) + "_png.zip";

            await JSRuntime.InvokeVoidAsync(
                "downloadAllPdfsAsPngZip",
                pdfUrls,
                pdfNames,
                zipName
            );
        }
        catch (Exception ex)
        {
            errorMessage = $"PNGダウンロードに失敗しました: {ex.Message}";
            StateHasChanged();
        }
    }
    private async Task ReloadPageItem(DisplayItem item)
    {
        // ページ単位の場合のみ対応
        if (item.RawData is PageItem pageItem)
        {
            pageItem.IsLoading = true;
            pageItem.HasError = false;
            StateHasChanged();

            // ページ再読み込み（ファイルIDとページインデックスで再実行）
            await PdfDataService.ReloadPageAsync(pageItem.FileId, pageItem.OriginalPageIndex);

            StateHasChanged();
        }
    }
    private void HandleCheckChanged(int index)
    {
        if (index > 0 && index < DisplayItems.Count)
        {
            PdfDataService.ToggleSplitBefore(index);
        }
    }


}
