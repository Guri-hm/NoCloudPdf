@page "/slice"
@implements IAsyncDisposable
@inject IJSRuntime JSRuntime
@inject PdfDataService PdfDataService
@inject MessageService MessageService
@inject CompletionStateService CompletionState
@using Microsoft.AspNetCore.Components.Web
@using Microsoft.JSInterop
@using System.IO
@using NoCloudPdf.Models
@using NoCloudPdf.Services
@using NoCloudPdf.Components

<PageTitle>NoCloudPDF-スライス</PageTitle>

@if (IsFilesLoaded && !CompletionState.ShowResult)
{
    <div id="drop-area" class="relative h-screen flex flex-col">
        <DropCover Message="ここにファイルをドロップ" />
        
        <!-- 上部固定バー -->
        <div class="sticky top-0 left-0 w-full max-w-full bg-gray-800 text-white shadow z-50">
            <div
                class="flex items-start justify-between px-4 py-2 scrollbar-thin scrollbar-thumb-gray-400 scrollbar-track-gray-200">
                <div class="flex flex-wrap gap-2 items-center">
                    <ActionButtonGroup T="string" Actions="resetActions" />
                    <div class="hidden md:block h-6 w-px bg-gray-300 mx-2" aria-hidden="true"></div>
                    <h1 class="hidden md:inline text-lg font-bold">スライス
                        <Tooltip Text="範囲選択した部分のみ，画像として書き出します。">
                            <InfoIcon Class="w-5 h-5 inline-block ml-1 text-blue-400 cursor-pointer" />
                        </Tooltip>
                    </h1>
                    <div class="ml-4 flex items-center gap-2">
                        <input type="number"
                            id="topbar-page-input"
                            min="1"
                            max="@Math.Max(1, DisplayItems.Count)"
                            value="@displayedPageNumber"
                            @onchange="OnTopBarPageInputChanged"
                            class="w-10 px-2 py-1 rounded border border-gray-300 text-sm"
                            title="ページ番号を入力して移動" />
                        <span class="text-sm">/ @DisplayItems.Count</span>
                    </div>
                    <ToggleButtonGroup T="bool" Items="toggleItems" ActiveValue="isDrawingMode"
                        OnClick="OnToggleDrawingMode" />
                    <ActionButtonGroup T="string" Actions="rotateActions" />
                    <ActionButtonGroup T="string" Actions="zoomActions" />

                    <DropdownButton T="string" MenuId="trimMenu" MenuItems="applyTrimItems">
                        <Trigger>
                            <DropdownTriggerButton>
                                <ActivityZoneIcon/>
                                <span class="hidden xl:inline">書き出し範囲</span>
                            </DropdownTriggerButton>
                        </Trigger>
                    </DropdownButton>

                    <ActionButtonGroup T="string" Actions="showOptionsModal" />
                </div>
                <ActionButtonGroup T="string" Actions="primaryActions" />
            </div>
        </div>
        <SplitPane 
            LeftWidth="@thumbnailAreaWidth" 
            LeftWidthChanged="@(w => { thumbnailAreaWidth = w; StateHasChanged(); })"
            EnableAutoResize="true">
            <Left>
                <div id="thumbnail-container" class="grid gap-4 p-4" style="grid-template-columns: repeat(auto-fit, minmax(112px, 1fr));">

                    @if (DisplayItems.Any(item => item.RawData is PageItem pi && (pi.IsPasswordProtected || pi.IsOperationRestricted)))
                    {
                        <div class="col-span-full w-full flex justify-center my-2">
                            <div class="bg-yellow-50 border-l-4 border-yellow-400 text-yellow-900 p-3 rounded font-bold text-sm flex items-center gap-2">
                                <UnlockIcon Class="w-5 h-5 text-yellow-500" />
                                制限付きのPDFページが含まれています。
                            </div>
                        </div>
                    }
                    @for (int i = 0; i < DisplayItems.Count; i++)
                    {
                        var index = i;
                        var item = DisplayItems[i];
                        <TrimThumbnailCard Item="@item"
                                        Index="@index"
                                        IsSelected="@(displayedPageNumber -1 == index)"
                                        HasTrimRect="@(PdfDataService.GetTrimRect(index) != null)"
                                        OnClick="@(() => SelectPage(index))"
                                        OnReloadPageItem="ReloadPageItem" 
                                        />
                    }
                    <FileAddArea
                    Position="@DisplayItems.Count"
                    OnInsertBlankPage="InsertBlankPage"
                    OnInsertPdfAtPosition="InsertPdfAtPosition"
                    OnAddFileClick="OpenFileDialog" ShowInsertButton="@(false)" />
                </div>
            </Left>
            <Right>
                    <PreviewArea 
                        Items="@DisplayItems"
                        CurrentPageNumber="@displayedPageNumber"
                        CurrentPageNumberChanged="@(p => displayedPageNumber = p)"
                        IsDrawingMode="@isDrawingMode"
                        RotationCounter="@_rotationCounter"
                        AllowMultipleRects="@(true)" 
                        SnapEnabled="@useSnapToGrid"
                        SnapEnabledChanged="@(async (bool v) => { useSnapToGrid = v; await OnSnapToGridChanged(); })" 
                        />
            </Right>
        </SplitPane>
        <div class="fixed bottom-0 left-0 w-full z-50 md:hidden bg-white border-t border-gray-300 p-4">
            <button class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 rounded-lg text-lg"
                @onclick="ExportSlicedImagesAsync">
                完了
            </button>
        </div>    
    </div>
    <OptionsModal IsOpen="@isOptionsModalOpen" 
              OnClose="() => isOptionsModalOpen = false"
              Title="スライスオプション">
        <SliceOptions ExportDpi="@exportDpi"
                    ExportDpiChanged="EventCallback.Factory.Create<int>(this, v => exportDpi = v)"
                    UseAspectRatioLock="@useAspectRatioLock"
                    UseAspectRatioLockChanged="EventCallback.Factory.Create<bool>(this, v => useAspectRatioLock = v)"
                    OnAspectRatioLockChanged="EventCallback.Factory.Create(this, OnAspectRatioLockChanged)"
                    GridCols="@gridCols"
                    GridColsChanged="EventCallback.Factory.Create<int>(this, v => gridCols = v)"
                    GridRows="@gridRows"
                    GridRowsChanged="EventCallback.Factory.Create<int>(this, v => gridRows = v)"
                    OnGridDivisionChanged="EventCallback.Factory.Create(this, OnGridDivisionChanged)"
                    UseSnapToGrid="@useSnapToGrid"
                    UseSnapToGridChanged="EventCallback.Factory.Create<bool>(this, v => useSnapToGrid = v)"
                    OnSnapToGridChanged="EventCallback.Factory.Create(this, OnSnapToGridChanged)" />
    </OptionsModal>
}
@if (!IsFilesLoaded && !CompletionState.ShowResult)
{
    <!-- 初期画面：ファイル選択 -->
    <SelectFilePanel OnOpenFileDialog="OpenFileDialog"/>
}

@if (CompletionState.ShowResult && slicedImages.Any())
{
    <!-- PC: 横並び, タブレット以下: 縦並び -->
    <div class="sticky top-0 left-0 w-full bg-gray-800 text-white shadow z-50 h-16">
        <div class="flex items-center px-4 py-2 h-16">
            <ActionButtonGroup T="string" Actions="backToEditActions" />
        </div>
    </div>

    <!-- メインエリア -->
    <div class="overflow-hidden h-[calc(100vh-4rem)]">
        <div class="flex flex-col md:flex-row h-full">
            <!-- 画像ギャラリー（スクロール可能） -->
            <div class="flex-1 overflow-auto p-6 bg-gray-50">
                <div class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
                    @foreach (var image in slicedImages)
                    {
                        <div class="bg-white rounded-lg shadow p-4 flex flex-col gap-2">
                            <!-- 画像表示エリアを固定高さに -->
                            <div class="w-full h-48 flex items-center justify-center bg-gray-100 rounded overflow-hidden">
                                <img src="@image.DataUrl" 
                                    alt="@image.FileName" 
                                    class="max-w-full max-h-full object-contain" />
                            </div>
                            <span class="text-sm text-gray-600 truncate w-full text-center">@image.FileName</span>
                            <button
                                class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-1 px-4 rounded text-sm w-full"
                                @onclick="() => DownloadSingleImage(image)">
                                <DownloadIcon Class="mr-2 inline-block" />ダウンロード
                            </button>
                        </div>
                    }
                </div>
            </div>
            <!-- 情報パネル（PCのみ表示） -->
            <div class="hidden md:flex flex-col w-full max-w-xs bg-white border-l border-gray-200 shadow-lg h-full p-6 justify-center items-center">
                <InfoPanel Title="完了" FileName="@mergedFileName" FileSize="@mergedFileSize" PageCount="@mergedPageCount">
                    <button
                        class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-6 rounded-lg w-full flex items-center justify-center"
                        @onclick="DownloadAllImagesAsZip">
                        <DownloadIcon Class="mr-2 inline-block" />
                        すべてZIPでダウンロード
                    </button>
                    <button
                        class="bg-white hover:bg-gray-100 border-1 border-solid border-gray-300 font-bold py-2 px-6 rounded-lg w-full flex items-center justify-center mt-4"
                        @onclick="StartNew">
                        <ResetIcon class="mr-2 inline-block align-middle w-[1em] h-[1em]" />
                        新規作成
                    </button>
                </InfoPanel>
            </div>
        </div>
        <!-- 下部スライドアップメニュー（タブレット以下のサイズのみ） -->
        <div class="md:hidden fixed bottom-0 left-0 w-full z-[200]">
            <div
                class="@($"transition-transform will-change-transform duration-300 bg-white border-t border-gray-300 shadow-lg p-4 {(isMenuOpen ? "translate-y-0" : "translate-y-full")}")">
                <div class="flex flex-col items-center gap-4">
                    <div class="flex items-center gap-2 text-green-600 text-2xl font-bold">
                        <CheckCircleIcon />
                        <span>完了</span>
                    </div>
                    <div class="text-gray-800 font-semibold truncate w-full text-center">@mergedFileName</div>
                    <div class="text-gray-600 text-sm">書き出し枚数: @mergedPageCount</div>
                    <button
                        class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-6 rounded-lg w-full"
                        @onclick="DownloadAllImagesAsZip">
                        <DownloadIcon Class="mr-2 inline-block" />すべてZIPでダウンロード
                    </button>
                    <button
                        class="bg-neutral-500 hover:bg-neutral-600 text-white font-bold py-2 px-6 rounded-lg w-full flex items-center justify-center mt-4"
                        @onclick="StartNew">
                        <ResetIcon class="mr-2 inline-block align-middle w-[1em] h-[1em]" />
                        新規作成
                    </button>
                </div>
                <button class="absolute top-2 right-4 text-2xl text-gray-500" @onclick="() => isMenuOpen = false">
                    <CloseIcon/>
                </button>
            </div>

            @if (!isMenuOpen)
            {
                <button
                    class="fixed bottom-4 left-1/2 -translate-x-1/2 z-[201] bg-white rounded-full shadow px-8 py-3 border border-gray-300 flex items-center gap-3 text-lg font-bold hover:bg-blue-50 transition min-w-[260px]"
                    @onclick="() => isMenuOpen = true">
                    <CheckCircleIcon Class="text-green-600 text-2xl"/>
                    <span class="text-green-600">完了</span>
                    <ChevronUpIcon/>
                </button>
            }
        </div>
        <!-- メニュー展開時はPDFのスクロールを禁止 -->
        @if (isMenuOpen)
        {
            <div class="fixed inset-0 bg-black/30 z-[199] touch-none" @onclick="() => isMenuOpen = false"></div>
        }
    </div>
}

<!-- ローディング中 -->
<LoadingOverlay />

<!-- メッセージ表示エリア -->
<MessageBar />

<PasswordInputDialog IsOpen="@isPasswordDialogOpen" FileName="@passwordDialogFileName" OnClose="OnPasswordDialogClose" />

<!-- ファイル選択用の隠しinput -->
<InputFile OnChange="HandleFileSelectionAsync" multiple class="hidden" id="fileInput" />

@if(isTrimRangeDialogOpen){
    <TrimRangeDialog 
        OnClose="CloseTrimRangeDialog"
        OnApply="ApplyTrimRangeSettings"
        PreviewImageSrc="@currentPreviewImage"
        CurrentPageNumber="@displayedPageNumber"
        TotalPages="@DisplayItems.Count"
        InitialTrimRectNormalized="@InitialTrimRectNormalized"
        OnError="OnDialogError" />
}

@code {
    protected override void OnInitialized()
    {
        PdfDataService.OnChange += OnServiceChanged;
        PdfDataService.PasswordInputDialogFunc = ShowPasswordInputDialogAsync;

        // ページ単位表示を強制
        PdfDataService.SwitchDisplayMode(DisplayMode.Page);

        // 完了状態をリセット
        CompletionState.Reset();
    }

    private void OnServiceChanged()
    {
        InvokeAsync(StateHasChanged);
    }

    private void PrevPage() => displayedPageNumber = Math.Max(1, displayedPageNumber - 1);
    private void NextPage() => displayedPageNumber = Math.Min(DisplayItems.Count, displayedPageNumber + 1);
    private Task OnBottomPageInputChanged(ChangeEventArgs e)
    {
        if (int.TryParse(e?.Value?.ToString(), out var v))
        {
            var target = Math.Max(1, Math.Min(Math.Max(1, DisplayItems.Count), v));
            displayedPageNumber = target;
            var targetIndex = target - 1;
        }
        return Task.CompletedTask;
    }

    private async Task OnDialogError(string message)
    {
        // エラーメッセージを表示してダイアログを閉じる（必要に応じて別の処理に差し替え）
        Console.WriteLine($"OnDialogError called: {message}");
        isTrimRangeDialogOpen = false;
        _ = MessageService.ShowAsync(message, MessageType.Error);
        StateHasChanged();
        await Task.CompletedTask;
    }

    private async Task ReloadPageItem(DisplayItem item)
    {
        // ページ単位の場合のみ対応
        if (item.RawData is PageItem pageItem)
        {
            pageItem.IsLoading = true;
            
            var errorMsg = await PdfDataService.ReloadPageAsync(pageItem.FileId, pageItem.OriginalPageIndex);
            
            if (!string.IsNullOrEmpty(errorMsg))
            {
                _ = MessageService.ShowAsync(errorMsg, MessageType.Error);
            }
        }
    }

    // 表示中の現在ページ番号を変更
    [JSInvokable("SetVisiblePageFromJs")]
    public Task SetVisiblePageFromJs(int pageIndex)
    {
        try
        {
            if (pageIndex < 0) pageIndex = 0;
            if (pageIndex >= DisplayItems.Count) pageIndex = Math.Max(0, DisplayItems.Count - 1);
            displayedPageNumber = pageIndex + 1;

        }
        catch { }
        return Task.CompletedTask;
    }

    // 上部バーの入力でページ移動
    private Task OnTopBarPageInputChanged(ChangeEventArgs e)
    {
        if (int.TryParse(e?.Value?.ToString(), out var v))
        {
            var target = Math.Max(1, Math.Min(Math.Max(1, DisplayItems.Count), v));
            displayedPageNumber = target;
            var targetIndex = target - 1;
        }
        return Task.CompletedTask;
    }

    public async ValueTask DisposeAsync()
    {
        await PageDisposeHelper.DisposePageAsync(
            jsRuntime: JSRuntime,
            dotNetRef: _dotNetRef,
            dropAreaRegistered: _dropAreaRegistered,
            onChangeHandler: OnServiceChanged,
            pdfDataService: PdfDataService,
            passwordTcs: passwordTcs,
            completionState: CompletionState,
            additionalCleanup: async () =>
            {
                // ページ固有のクリーンアップ
                await PageDisposeHelper.UnregisterTrimPreviewAreaAsync(JSRuntime);
            }
        );
        
        _dotNetRef = null;
        _dropAreaRegistered = false;
        passwordTcs = null;
    }

    // 統一アーキテクチャ対応プロパティ
    private DisplayMode CurrentDisplayMode => PdfDataService.GetModel().CurrentMode;
    private List<DisplayItem> DisplayItems => PdfDataService.GetDisplayItems();
    private bool IsFilesLoaded => DisplayItems.Any();


    private DotNetObjectReference<Slice>? _dotNetRef;
    private bool isMenuOpen = false;
    private string mergedFileName = "";
    private string mergedFileSize = "";

    private int mergedPageCount = 0;
    private int exportDpi = 150;
    private bool isOptionsModalOpen = false;

    private List<ToggleButtonItem<bool>> toggleItems = new()
    {
        new ToggleButtonItem<bool>
        {
            Value = true,
            Label = "スライス",
            IconFragment = builder =>
            {
                builder.OpenComponent(0, typeof(SliceIcon));
                builder.AddAttribute(1, "Class", "w-5 h-5");
                builder.CloseComponent();
            }
        },
        new ToggleButtonItem<bool>
        {
            Value = false,
            Label = "パン",
            IconFragment = builder =>
            {
                builder.OpenComponent(0, typeof(PanIcon));
                builder.AddAttribute(1, "Class", "w-5 h-5");
                builder.CloseComponent();
            }
        }
    };

    private async Task OnToggleDrawingMode(bool drawingMode)
    {
        // drawingMode == false の時にパンを有効にする
        isDrawingMode = drawingMode;
        try
        {
            await JSRuntime.InvokeVoidAsync("setPreviewPanEnabled", !drawingMode);
        }
        catch { }
    }

    private List<ActionButtonItem> primaryActions => new()
    {
        new ActionButtonItem
        {
            Label = "完了",
            IconFragment = builder =>
            {
                builder.OpenComponent(0, typeof(ArrowRightIcon));
                builder.CloseComponent();
            },
            Title = "完了",
            OnClick = EventCallback.Factory.Create(this, ExportSlicedImagesAsync),
            ButtonClass = "bg-blue-600 hover:bg-blue-700 px-8 transition hidden md:flex",
            IconPosition = "right",
            TextColor = "text-white"
        }
    };

    private async Task AddPdfFile()
    {
        await OpenFileDialog();
    }

    // ファイルダイアログを開く
    private async Task OpenFileDialog()
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("openFileDialog", "fileInput");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error opening file dialog: {ex.Message}");
            _ = MessageService.ShowAsync($"ファイル選択ダイアログの表示に失敗しました: {ex.Message}", MessageType.Error);
        }
    }

    // その他のメソッド
    private void BackToEdit()
    {
        CompletionState.Reset();
        StateHasChanged();
    }

    private void StartNew()
    {
        CompletionState.Reset(); // グローバルな完了フラグをリセット
        PdfDataService.Clear();

        slicedImages.Clear();
        mergedFileName = "";
        mergedFileSize = "";
        mergedPageCount = 0;

    }

    private async Task RotateAllLeft() => await RotateAll(-90);
    private async Task RotateAllRight() => await RotateAll(90);
    private int _rotationCounter = 0;

    private async Task RotateAll(int angle)
    {
        try{
            await MessageService.ShowLoadingAsync("回転中...");
            await Task.Yield();

            PdfDataService.RotateAll(CurrentDisplayMode, DisplayItems, angle);
            _rotationCounter++;
            _ = MessageService.ShowAsync($"回転が完了しました", MessageType.Success);
        }catch(Exception ex){
            _ = MessageService.ShowAsync($"回転中にエラーが発生しました: {ex.Message}", MessageType.Error);
        }finally{
            await MessageService.HideLoadingAsync();
        }
    }

    // 空白ページを挿入
    public async Task InsertBlankPage(int position)
    {

        await PdfDataService.InsertBlankPageWithDisplayModeAsync(
            CurrentDisplayMode, DisplayItems, position);

    }

    // PDF挿入
    public async Task InsertPdfAtPosition(int position)
    {
        await PdfDataService.OpenInsertPdfDialogAsync(
            CurrentDisplayMode,
            DisplayItems,
            position,
            pos => insertPosition = pos,
            msg => _ = MessageService.ShowAsync(msg, MessageType.Error)
        );
    }

    private int insertPosition = -1;

    // 挿入用ファイル選択処理
    private async Task HandleFileSelectionAsync(InputFileChangeEventArgs e)
    {
        try{

            await MessageService.ShowLoadingAsync("ファイル読み込み中...");
            await PdfDataService.HandleFileInputAsync(
                e,
                insertPosition >= 0 ? insertPosition : null
            );
            insertPosition = -1;

        }catch (Exception ex){
            Console.WriteLine($"An error occurred: {ex.Message}");
            _ = MessageService.ShowAsync($"ファイルの読み込み中にエラーが発生しました: {ex.Message}", MessageType.Error);

        }finally{
            await MessageService.HideLoadingAsync();
        }
    }

    private List<ActionButtonItem> resetActions => new()
    {
        new ActionButtonItem
        {
            IconFragment = builder =>
            {
                builder.OpenComponent(0, typeof(ResetIcon));
                builder.AddAttribute(1, "Class", "w-5 h-5"); 
                builder.CloseComponent();
            },
            Title = "最初からやり直す",
            OnClick = EventCallback.Factory.Create(this, StartNew),
            ButtonClass = "bg-amber-200 hover:bg-amber-300 border border-amber-400 font-bold py-2 px-3 rounded",
            TextColor = "text-black"
        }
    };

    private List<ActionButtonItem> backToEditActions => new()
    {
        new ActionButtonItem
        {
            Label = "編集に戻る",
            IconFragment = builder =>
            {
                builder.OpenComponent(0, typeof(ArrowLeftIcon));
                builder.CloseComponent();
            },
            Title = "編集に戻る",
            OnClick = EventCallback.Factory.Create(this, BackToEdit),
        }
    };

    private List<ActionButtonItem> rotateActions => new()
    {
        new ActionButtonItem
        {
            Label = "左",
            IconFragment = builder =>
            {
                builder.OpenComponent(0, typeof(RotateLeftIcon));
                builder.AddAttribute(1, "Class", "w-6 h-6"); 
                builder.CloseComponent();
            },
            Title = "左回転",
            OnClick = EventCallback.Factory.Create(this, RotateAllLeft),
            IconPosition = "left"
        },
        new ActionButtonItem
        {
            Label = "右",
            IconFragment = builder =>
            {
                builder.OpenComponent(0, typeof(RotateRightIcon));
                builder.AddAttribute(1, "Class", "w-6 h-6"); 
                builder.CloseComponent();
            },
            Title = "右回転",
            OnClick = EventCallback.Factory.Create(this, RotateAllRight),
            IconPosition = "left"
        }
    };

    private List<ActionButtonItem> zoomActions => new()
    {
        new ActionButtonItem
        {
            Label = "幅に合わせる",
            IconFragment = builder =>
            {
                builder.OpenComponent(0, typeof(FitWidthIcon));
                builder.AddAttribute(1, "Class", "w-6 h-6"); 
                builder.CloseComponent();
            },
            Title = "幅に合わせる",
            OnClick = EventCallback.Factory.Create(this, FitPreviewWidth),
        },
        new ActionButtonItem
        {
            Label = "高さに合わせる",
            IconFragment = builder =>
            {
                builder.OpenComponent(0, typeof(FitHeightIcon));
                builder.AddAttribute(1, "Class", "w-6 h-6"); 
                builder.CloseComponent();
            },
            Title = "高さに合わせる",
            OnClick = EventCallback.Factory.Create(this, FitPreviewHeight),
        },
                new ActionButtonItem
        {
            Label = "全体表示",
            IconFragment = builder =>
            {
                builder.OpenComponent(0, typeof(FitScreenIcon));
                builder.AddAttribute(1, "Class", "w-6 h-6"); 
                builder.CloseComponent();
            },
            Title = "全体表示",
            OnClick = EventCallback.Factory.Create(this, FitPreviewBoth),
        },
        new ActionButtonItem
        {
            Label = "実際のサイズ",
            IconFragment = builder =>
            {
                builder.OpenComponent(0, typeof(ViewRealSizeIcon));
                builder.AddAttribute(1, "Class", "w-6 h-6"); 
                builder.CloseComponent();
            },
            Title = "実際のサイズ",
            OnClick = EventCallback.Factory.Create(this, SetPreviewToActualSize),
        },
        new ActionButtonItem
        {
            IconFragment = builder =>
            {
                builder.OpenComponent(0, typeof(ZoomOutIcon));
                builder.AddAttribute(1, "Class", "w-6 h-6"); 
                builder.CloseComponent();
            },
            Title = "縮小",
            OnClick = EventCallback.Factory.Create(this, ZoomOut),
            IconPosition = "left"
        },
        new ActionButtonItem
        {
            IconFragment = builder =>
            {
                builder.OpenComponent(0, typeof(ZoomInIcon));
                builder.AddAttribute(1, "Class", "w-6 h-6"); 
                builder.CloseComponent();
            },
            Title = "拡大",
            OnClick = EventCallback.Factory.Create(this, ZoomIn),
            IconPosition = "left"
        }
    };

    private List<ActionButtonItem> showOptionsModal => new()
    {
        new ActionButtonItem
        {
            Label = "オプション",
            IconFragment = builder =>
            {
                builder.OpenComponent(0, typeof(SettingsIcon));
                builder.AddAttribute(1, "Class", "w-6 h-6"); 
                builder.CloseComponent();
            },
            Title = "スライスオプション",
            OnClick = EventCallback.Factory.Create(this, () => isOptionsModalOpen = true),
        }
    };

    private List<DropdownMenuItem> applyTrimItems => new()
    {
        new DropdownMenuItem
        {
        Label = "現在ページの範囲を全ページに適用",
        OnClick = EventCallback.Factory.Create(this,ApplyCurrentTrimToAll)
        },
        new DropdownMenuItem
        {
        Label = "すべての範囲をクリア",
        OnClick = EventCallback.Factory.Create(this, ClearAllTrims)
        }
    };

    // 現在表示ページのトリム矩形を取得して全ページへ適用する
    private Task ApplyCurrentTrimToAll()
    {
        if (DisplayItems == null || DisplayItems.Count == 0)
        {
            _ = MessageService.ShowAsync("適用対象がありません。", MessageType.Warn);
            return Task.CompletedTask;
        }

        var idx = Math.Max(0, Math.Min(DisplayItems.Count - 1, displayedPageNumber - 1));
        var trimRects = PdfDataService.GetTrimRects(idx);
        if (trimRects == null || trimRects.Count == 0)
        {
            _ = MessageService.ShowAsync("現在ページに書き出し範囲が設定されていません。", MessageType.Warn);
            return Task.CompletedTask;
        }

        try
        {
            for (int i = 0; i < DisplayItems.Count; i++)
            {
                PdfDataService.SetTrimRects(i, new List<TrimRectInfo>(trimRects), notify: false);
            }
            _ = PdfDataService.RedrawAllTrimOverlaysAsync();
            _ = MessageService.ShowAsync("すべてのページに適用しました", MessageType.Success);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"ApplyCurrentTrimToAll error: {ex.Message}");
            _ = MessageService.ShowAsync("すべてのページへの適用に失敗しました", MessageType.Error);
        }
        finally
        {
        }
        return Task.CompletedTask;

    }

    private Task ClearAllTrims()
    {
        try
        {
            var count = DisplayItems?.Count ?? 0;
            for (int i = 0; i < count; i++)
            {
                try { PdfDataService.ClearTrimRect(i); } catch { }
            }

            try { trimRects.Clear(); } catch { }
            try
            {
                if (previewItems != null)
                {
                    for (int i = 0; i < previewItems.Count; i++)
                    {
                        previewItems[i].TrimRect = null;
                    }
                }
            }
            catch { }

            for (int i = 0; i < count; i++)
            {
                try
                {
                    _ = JSRuntime.InvokeVoidAsync("drawTrimOverlayAsSvg", $"trim-preview-canvas-{i}", Array.Empty<object>());
                    // JavaScript側の内部状態をクリア
                    _ = JSRuntime.InvokeVoidAsync("clearTrimState", $"trim-preview-canvas-{i}");
                }
                catch { }
            }

            _ = MessageService.ShowAsync("すべてのトリミング範囲をクリアしました", MessageType.Success);
        }
        catch
        {
            _ = MessageService.ShowAsync("トリミング範囲のクリアに失敗しました", MessageType.Error);
        }
        return Task.CompletedTask;
    }

    // 1:1 アスペクト比固定フラグ
    private bool useAspectRatioLock = false;

    private async Task OnAspectRatioLockChanged()
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("setTrimRectAspectRatio", useAspectRatioLock ? 1.0 : 0);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"OnAspectRatioLockChanged error: {ex.Message}");
        }
    }

    // グリッド分割の列・行
    private int gridCols = 1;
    private int gridRows = 1;

    private async Task OnGridDivisionChanged()
    {
        try
        {
            gridCols = Math.Max(1, Math.Min(5, gridCols));
            gridRows = Math.Max(1, Math.Min(5, gridRows));
            await JSRuntime.InvokeVoidAsync("setTrimRectGridDivision", gridCols, gridRows);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"OnGridDivisionChanged error: {ex.Message}");
        }
    }

    [JSInvokable]
    public async Task OnJsFileDropped(string fileName, string contentType, string base64Data)
    {
        try
        {
            await PdfDataService.HandleDroppedFileAsync(fileName, base64Data);
        }catch (Exception ex)
        {
            Console.WriteLine($"An error occurred: {ex.Message}");
            _ = MessageService.ShowAsync($"ファイルの読み込み中にエラーが発生しました: {ex.Message}", MessageType.Error);
        }   
        finally
        {
            await MessageService.HideLoadingAsync();
        }
    }

    private bool isPasswordDialogOpen = false;
    private string passwordDialogFileName = "";
    private TaskCompletionSource<string?>? passwordTcs;

    public Task<string?> ShowPasswordInputDialogAsync(string fileName)
    {
        isPasswordDialogOpen = true;
        passwordDialogFileName = fileName;
        passwordTcs = new TaskCompletionSource<string?>();
        StateHasChanged();
        return passwordTcs.Task;
    }

    private void OnPasswordDialogClose(string? password)
    {
        isPasswordDialogOpen = false;
        passwordTcs?.SetResult(password);
        passwordTcs = null;
        StateHasChanged();
    }

    private bool _dropAreaRegistered = false;
    private int displayedPageNumber = 1;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _dotNetRef = DotNetObjectReference.Create(this);
        }

        // 初期画面のときのみ登録
        if (!IsFilesLoaded && !CompletionState.ShowResult)
        {
            await JSRuntime.InvokeVoidAsync("registerSelectDropArea", _dotNetRef);
        }

        // drop-areaが表示され、まだ登録していない場合のみ
        if (!_dropAreaRegistered && IsFilesLoaded && DisplayItems.Any())
        {
            await JSRuntime.InvokeVoidAsync("registerDropArea", "drop-area", _dotNetRef);
            _dropAreaRegistered = true;
        }
        else if (_dropAreaRegistered && (!IsFilesLoaded || !DisplayItems.Any()))
        {
            // drop-areaが消えたらフラグを戻す（必要ならJSでunregisterも）
            _dropAreaRegistered = false;
        }

    }

    /// <summary>
    /// 単一画像をダウンロード
    /// </summary>
    private async Task DownloadSingleImage(SlicedImage image)
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("downloadFileFromUrl", image.DataUrl, image.FileName, "image/png");
        }
        catch (Exception ex)
        {
            _ = MessageService.ShowAsync($"画像のダウンロードに失敗しました: {ex.Message}", MessageType.Error);
        }
    }

    /// <summary>
    /// すべての画像を ZIP でダウンロード
    /// </summary>
    private async Task DownloadAllImagesAsZip()
    {
        try
        {
            await MessageService.ShowLoadingAsync("ZIP作成中...");

            var imageData = slicedImages.Select(img => new
            {
                fileName = img.FileName,
                dataUrl = img.DataUrl
            }).ToArray();

            await JSRuntime.InvokeVoidAsync("downloadImagesAsZip", imageData, mergedFileName);

            _ = MessageService.ShowAsync("ZIPファイルをダウンロードしました", MessageType.Success);
        }
        catch (Exception ex)
        {
            _ = MessageService.ShowAsync($"ZIPダウンロードに失敗しました: {ex.Message}", MessageType.Error);
        }
        finally
        {
            await MessageService.HideLoadingAsync();
        }
    }

    private bool isDrawingMode = true;

    // リサイズ関連
    private int thumbnailAreaWidth = 300;

    private Task SelectPage(int index)
    {
        displayedPageNumber = index + 1;
        StateHasChanged();
        return Task.CompletedTask;
    }

    private int BrowserViewportWidth()
    {
        // 既定値フォールバック
        return 1200;
    }

    private Dictionary<int, TrimRect> trimRects = new();
    private List<PreviewItem> previewItems = new();

    // 矩形データ）
    public class TrimRect
    {
        public double X { get; set; }
        public double Y { get; set; }
        public double Width { get; set; }
        public double Height { get; set; }
    }

    // プレビュー項目の最小情報（UI側で使っているプロパティのみ）
    public class PreviewItem
    {
        public int ContainerWidth { get; set; }
        public int ContainerHeight { get; set; }
        public TrimRect? TrimRect { get; set; }
    }

    private double previewZoom = 1.0;
    private const double ZoomStep = 0.25;
    private const double MinZoom = 0.25;
    private const double MaxZoom = 3.0;

    private async Task ZoomIn()
    {
        try { await JSRuntime.InvokeVoidAsync("clearAutoFitMode"); } catch { }

        // 現在の実際の倍率を取得してから計算
        var canvasId = $"trim-preview-canvas-{displayedPageNumber - 1}";
        var currentScale = await JSRuntime.InvokeAsync<double>("getCurrentPreviewZoom", canvasId);
        if (currentScale > 0) previewZoom = currentScale;

        previewZoom = Math.Min(MaxZoom, previewZoom + ZoomStep);
        await JSRuntime.InvokeVoidAsync("setPreviewZoom", previewZoom);
    }

    private async Task ZoomOut()
    {
        try { await JSRuntime.InvokeVoidAsync("clearAutoFitMode"); } catch { }

        var canvasId = $"trim-preview-canvas-{displayedPageNumber - 1}";
        var currentScale = await JSRuntime.InvokeAsync<double>("getCurrentPreviewZoom", canvasId);
        if (currentScale > 0) previewZoom = currentScale;

        previewZoom = Math.Max(MinZoom, previewZoom - ZoomStep);
        await JSRuntime.InvokeVoidAsync("setPreviewZoom", previewZoom);
    }

    private async Task FitPreviewWidth()
    {
        var canvasId = $"trim-preview-canvas-{displayedPageNumber - 1}";
        try
        {
            // 横幅フィットモードを有効化
            await JSRuntime.InvokeVoidAsync("setAutoFitMode", "width");
            var scale = await JSRuntime.InvokeAsync<double>("fitPreviewToViewport", canvasId, "fit-width");
            previewZoom = scale;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"FitPreviewWidth error: {ex.Message}");
        }
    }

    private async Task FitPreviewHeight()
    {
        var canvasId = $"trim-preview-canvas-{displayedPageNumber - 1}";
        try
        {
            // 縦幅フィットモードを有効化
            await JSRuntime.InvokeVoidAsync("setAutoFitMode", "height");
            var scale = await JSRuntime.InvokeAsync<double>("fitPreviewToViewport", canvasId, "fit-height");
            previewZoom = scale;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"FitPreviewHeight error: {ex.Message}");
        }
    }

    private async Task SetPreviewToActualSize()
    {
        var canvasId = $"trim-preview-canvas-{displayedPageNumber - 1}";
        try
        {
            // 実際のサイズモードを有効化
            await JSRuntime.InvokeVoidAsync("setAutoFitMode", "none");
            var scale = await JSRuntime.InvokeAsync<double>("fitPreviewToViewport", canvasId, "actual-size");
            previewZoom = scale;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"SetPreviewToActualSize error: {ex.Message}");
        }
    }

    private async Task FitPreviewBoth()
    {
        var canvasId = $"trim-preview-canvas-{displayedPageNumber - 1}";
        try
        {
            // 全体表示モードを有効化
            await JSRuntime.InvokeVoidAsync("setAutoFitMode", "both");
            var scale = await JSRuntime.InvokeAsync<double>("fitPreviewToViewport", canvasId, "fit-both");
            previewZoom = scale;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"FitPreviewBoth error: {ex.Message}");
        }
    }


    // 切り出し画像のデータモデル
    private class SlicedImage
    {
        public string Id { get; set; } = "";
        public string DataUrl { get; set; } = "";
        public string FileName { get; set; } = "";
        public int OriginalPageIndex { get; set; }
        public int RectIndex { get; set; }
    }

    private List<SlicedImage> slicedImages = new();
    /// <summary>
    /// 各ページの矩形を画像として切り出す
    /// </summary>
    private async Task ExportSlicedImagesAsync()
    {
        if (DisplayItems == null || DisplayItems.Count == 0)
            return;

        try
        {
            await MessageService.ShowLoadingAsync("書き出し中...");
            await Task.Yield();

            slicedImages.Clear();
            var displayList = DisplayItems.ToList();
            var pageCount = displayList.Count;

            int imageCounter = 1;

            for (int pageIndex = 0; pageIndex < pageCount; pageIndex++)
            {
                var item = displayList[pageIndex];
                if (item.RawData is not PageItem page)
                    continue;

                if (string.IsNullOrEmpty(page.PageData) || page.HasPageDataError)
                    continue;

                // 複数矩形を取得
                var rects = PdfDataService.GetTrimRects(pageIndex);
                if (rects == null || rects.Count == 0)
                    continue; // 矩形がないページはスキップ

                // 矩形ごとに画像を切り出し
                for (int rectIndex = 0; rectIndex < rects.Count; rectIndex++)
                {
                    var rect = rects[rectIndex];
                    try
                    {
                        var rotate = page.RotateAngle % 360;

                        string imageDataUrl;

                        // 制限付きPDFの場合は専用関数で直接切り出し
                        if (page.IsOperationRestricted || page.IsPasswordProtected)
                        {
                            imageDataUrl = await PdfDataService.CropRestrictedPdfPageToImageAsync(
                                page.Id,
                                rect.X, rect.Y, rect.Width, rect.Height,
                                exportDpi,
                                rotate
                            ) ?? "";
                        }
                        else
                        {
                            // 通常のページは既存の方法
                            imageDataUrl = await JSRuntime.InvokeAsync<string>(
                                "cropPdfPageToImage",
                                page.PageData,
                                rect.X, rect.Y, rect.Width, rect.Height,
                                rotate,
                                exportDpi
                            );
                        }
                        
                        if (!string.IsNullOrEmpty(imageDataUrl))
                        {
                            var fileName = $"slice_{imageCounter:D3}.png";
                            slicedImages.Add(new SlicedImage
                            {
                                Id = $"slice-{pageIndex}-{rectIndex}",
                                DataUrl = imageDataUrl,
                                FileName = fileName,
                                OriginalPageIndex = pageIndex,
                                RectIndex = rectIndex
                            });
                            imageCounter++;
                        }
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine($"Error exporting slice page={pageIndex} rect={rectIndex}: {ex.Message}");
                    }
                }
            }

            if (slicedImages.Count == 0)
            {
                _ = MessageService.ShowAsync("書き出す範囲が設定されていません。", MessageType.Warn);
                return;
            }

            // 完了画面へ遷移
            mergedFileName = $"sliced_{DateTime.Now:yyyyMMddHHmm}.zip";
            mergedFileSize = FormatFileSize(slicedImages.Sum(img => EstimateImageSize(img.DataUrl)));
            mergedPageCount = slicedImages.Count;
            CompletionState.SetShowResult(true);

            _ = MessageService.ShowAsync($"{slicedImages.Count} 枚の画像を書き出しました", MessageType.Success);

        }catch(Exception ex)
        {
            Console.WriteLine($"ExportSlicedImagesAsync error: {ex.Message}");
            _ = MessageService.ShowAsync($"書き出し中にエラーが発生しました: {ex.Message}", MessageType.Error);

        }
        finally
        {
            await MessageService.HideLoadingAsync();
            StateHasChanged();
        }
    }

    /// <summary>
    /// Base64 画像データのサイズを概算（バイト）
    /// </summary>
    private long EstimateImageSize(string dataUrl)
    {
        if (string.IsNullOrEmpty(dataUrl)) return 0;
        var base64Index = dataUrl.IndexOf(",");
        if (base64Index < 0) return 0;
        var base64 = dataUrl.Substring(base64Index + 1);
        return (long)(base64.Length * 0.75); // Base64 → バイナリ変換の概算
    }

        /// <summary>
    /// ファイルサイズを人間が読める形式にフォーマット
    /// </summary>
    private string FormatFileSize(long bytes)
    {
        string[] sizes = { "B", "KB", "MB", "GB" };
        double len = bytes;
        int order = 0;
        while (len >= 1024 && order < sizes.Length - 1)
        {
            order++;
            len /= 1024;
        }
        return $"{len:0.##} {sizes[order]}";
    }

    private bool isTrimRangeDialogOpen = false;
    private string currentPreviewImage = "";
    private TrimRectInfo? InitialTrimRectNormalized;
    private async Task OpenTrimRangeDialog()
    {
        try
        {
            if (DisplayItems == null || DisplayItems.Count == 0)
            {
                _ = MessageService.ShowAsync("対象のページがありません。", MessageType.Warn);
                return;
            }
            var idx = Math.Max(0, Math.Min(DisplayItems.Count - 1, displayedPageNumber - 1));
            if (DisplayItems[idx].RawData is PageItem page)
            {
                currentPreviewImage = await PdfDataService.GetPreviewImageAsync(page.Id) ?? "";
            }

            InitialTrimRectNormalized = PdfDataService.GetTrimRect(idx);
            isTrimRangeDialogOpen = true;
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"OpenTrimRangeDialog error: {ex.Message}");
        }
    }

    private Task CloseTrimRangeDialog()
    {
        isTrimRangeDialogOpen = false;
        StateHasChanged();
        return Task.CompletedTask;
    }

    private async Task ApplyTrimRangeSettings(TrimRangeDialog.TrimRangeSettings settings)
    {
        try
        {
            await MessageService.ShowLoadingAsync("適用中...");
            await Task.Yield();

            int w = settings.ImageNaturalWidth;
            int h = settings.ImageNaturalHeight;

            if (w <= 0 || h <= 0)
            {
                try
                {
                    var curIndex = Math.Max(0, displayedPageNumber - 1);
                    var canvasId = $"trim-preview-canvas-{curIndex}";
                    var canvasSize = await JSRuntime.InvokeAsync<int[]>("getCanvasNaturalSize", canvasId);
                    if (canvasSize != null && canvasSize.Length >= 2)
                    {
                        w = canvasSize[0];
                        h = canvasSize[1];
                    }
                }
                catch { }
            }

            if (w <= 0 || h <= 0)
            {
                _ = MessageService.ShowAsync("プレビュー画像のサイズを取得できませんでした", MessageType.Error);
                return;
            }

            double nx = (double)settings.LeftMargin / w;
            double ny = (double)settings.TopMargin / h;
            double nw = Math.Max(0, 1.0 - (double)(settings.LeftMargin + settings.RightMargin) / w);
            double nh = Math.Max(0, 1.0 - (double)(settings.TopMargin + settings.BottomMargin) / h);

            List<int> targetPages = new();
            if (settings.ApplyRange == "current")
            {
                targetPages.Add(displayedPageNumber - 1);
            }
            else if (settings.ApplyRange == "all")
            {
                targetPages.AddRange(Enumerable.Range(0, DisplayItems.Count));
            }
            else if (settings.ApplyRange == "range")
            {
                int start = Math.Max(0, settings.RangeStart - 1);
                int end = Math.Min(DisplayItems.Count - 1, settings.RangeEnd - 1);
                targetPages.AddRange(Enumerable.Range(start, end - start + 1));
            }

            foreach (var idx in targetPages)
            {
                PdfDataService.SetTrimRect(idx, nx, ny, nw, nh);
            }

            _ = MessageService.ShowAsync("トリミング範囲を適用しました", MessageType.Success);
            isTrimRangeDialogOpen = false;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"ApplyTrimRangeSettings error: {ex.Message}");
            _ = MessageService.ShowAsync("トリミング範囲の適用に失敗しました", MessageType.Error);
        }
        finally
        {
            await MessageService.HideLoadingAsync();
            StateHasChanged();
        }
    }

    private bool useSnapToGrid = false;

    private async Task OnSnapToGridChanged()
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("setTrimSnapEnabled", useSnapToGrid);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"OnSnapToGridChanged error: {ex.Message}");
        }
    }
    
    [JSInvokable("OnPreviewOutOfView")]
    public Task OnPreviewOutOfView(string pageId)
    {
        PdfDataService.ClearPreviewCache(pageId);
        return Task.CompletedTask;
    }
}
