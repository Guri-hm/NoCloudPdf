@page "/trim"
@implements IDisposable
@inject IJSRuntime JSRuntime
@inject PdfDataService PdfDataService
@inject CompletionStateService CompletionState
@using Microsoft.AspNetCore.Components.Web
@using Microsoft.JSInterop
@using System.IO
@using NoCloudPdf.Models
@using NoCloudPdf.Services
@using NoCloudPdf.Components

<PageTitle>NoCloudPDF-トリミング</PageTitle>

@if (IsFilesLoaded && !CompletionState.ShowTrimmedResult)
{
    <div id="drop-area" class="relative h-screen flex flex-col">
        <DropCover IsDragOver="isDragOver" Message="ここにファイルをドロップ" />
        
        <!-- 上部固定バー -->
        <div class="sticky top-0 left-0 w-full bg-gray-800 text-white shadow z-50">
            <div class="px-4 py-2">
                <div class="topbar-columns">
                    <!-- 左列: 固定幅 or コンテンツ幅 -->
                    <div class="topbar-left-col">
                        <div class="group-first">
                            <ActionButtonGroup T="string" Actions="resetActions" />
                        </div>
                        <div class="separator-vertical" aria-hidden="true"></div>
                        <div class="group-rest-left">
                            <!-- ここに左列内の追加要素（タイトルや入力など）を入れる -->
                            <h1 class="text-lg font-bold">トリミング</h1>
                            <div class="ml-4 flex items-center gap-2">
                                <input type="number"
                                    min="1"
                                    max="@Math.Max(1, DisplayItems.Count)"
                                    value="@displayedPageNumber"
                                    @onchange="OnTopBarPageInputChanged"
                                    class="w-20 px-2 py-1 rounded border border-gray-300 text-sm"
                                    title="ページ番号を入力してEnterで移動" />
                                <span class="text-sm">/ @DisplayItems.Count</span>
                            </div>
                        </div>
                    </div>

                    <!-- 仕切り線 -->
                    <div class="topbar-divider" aria-hidden="true"></div>

                    <!-- 右列: 可変幅、内部で折り返し -->
                    <div class="topbar-right-col">
                        <div class="topbar-actions-wrap">
                            <ToggleButtonGroup T="bool" Items="toggleItems" ActiveValue="isDrawingMode"
                                OnClick="OnToggleDrawingMode" />
                            <ActionButtonGroup T="string" Actions="rotateActions" />
                            <ActionButtonGroup T="string" Actions="zoomActions" />
                            <ActionButtonGroup T="string" Actions="applyTrimActions" />
                        </div>

                        <!-- 右端の主要アクション（例: 完了ボタン）は右端に常に表示 -->
                        <div class="topbar-primary">
                            <ActionButtonGroup T="string" Actions="primaryActions" />
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- 左右分割エリア -->
        <div id="split-container" class="flex-1 flex overflow-hidden">
            <!-- 左側：サムネイル一覧 -->
            <div id="thumbnail-area" class="w-auto overflow-y-auto bg-gray-50 border-r border-gray-300 flex-none" style="--thumbnail-width: 300px; width: var(--thumbnail-width);">
                <div class="grid gap-4 p-4" style="grid-template-columns: repeat(auto-fit, minmax(112px, 1fr));">
                    @for (int i = 0; i < DisplayItems.Count; i++)
                    {
                        var index = i;
                        var item = DisplayItems[i];
                        <TrimThumbnailCard Item="@item"
                            IsSelected="@(selectedPageIndex == index)"
                            HasTrimRect="@(trimRects.ContainsKey(index))"
                            OnClick="@(() => SelectPage(index))" />
                    }
                </div>
            </div>
            
            <!-- リサイズハンドル -->
            <div id="splitter-handle" class="w-1 bg-gray-400 cursor-ew-resize hover:bg-blue-500 flex-none"
                style="touch-action: none;"
                @onpointerdown="@(e => StartResize((PointerEventArgs)e))">
            </div>
            
            <!-- 右側：プレビューエリア（プレビュー領域は固定、内部で拡大縮小してスクロールさせる）-->
            <div class="flex-1 min-w-0">
                <div id="trim-preview-container" class="h-full overflow-auto bg-gray-100 p-4 flex flex-col gap-4">
                    <!-- ビューポート：幅は固定（親に合わせる）、内部で横スクロールさせる -->
                    <div class="preview-zoom-viewport w-full h-full">
                        <div id="preview-zoom-inner" class="preview-zoom-inner" style="--preview-zoom: 1; transform: scale(var(--preview-zoom)); transform-origin: top center;">
                            @for (int i = 0; i < DisplayItems.Count; i++)
                            {
                                var item = DisplayItems[i];
                                <TrimPreviewItem Item="@item" Index="@i"  IsDrawingMode="@isDrawingMode" />
                            }
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
}
@if (previewIndex >= 0)
{
    
}
@if (!IsFilesLoaded && !CompletionState.ShowTrimmedResult)
{
    <!-- 初期画面：ファイル選択 -->
    <SelectFilePanel OnOpenFileDialog="OpenFileDialog"/>
}

@if (CompletionState.ShowTrimmedResult && !string.IsNullOrEmpty(mergedPdfUrl))
{
    <!-- PC: 横並び, タブレット以下: 縦並び -->
    <div class="sticky top-0 left-0 w-full bg-gray-800 text-white shadow z-50 h-16">
        <div class="flex items-center px-4 py-2 h-16">
            <ActionButtonGroup T="string" Actions="backToEditActions" />
        </div>
    </div>

    <!-- メインエリア -->
    <div class="overflow-hidden h-[calc(100vh-4rem)]">
        <div class="flex flex-col md:flex-row h-full">
            <!-- PDFプレビュー -->
            <PdfPreviewCanvas MergedPageCount="mergedPageCount" />
            <!-- 情報パネル（PCのみ表示） -->
            <div class="hidden md:flex flex-col w-full max-w-xs bg-white border-l border-gray-200 shadow-lg h-full p-6 justify-center items-center">
                <InfoPanel Title="完了" FileName="@mergedFileName" FileSize="@mergedFileSize" PageCount="@mergedPageCount">
                    <SplitButton
                        PrimaryLabel="PDFでダウンロード"
                        OnPrimaryClick="DownloadMergedPdf"
                        MenuItems="@downloadMenuItems" />
                    <button
                        class="bg-white hover:bg-gray-100 border-1 border-solid border-gray-300 font-bold py-2 px-6 rounded-lg w-full flex items-center justify-center mt-4"
                        @onclick="StartNew">
                        <ResetIcon class="inline-block align-middle w-[1em] h-[1em]" />
                        新規作成
                    </button>
                </InfoPanel>
            </div>
        </div>
        <!-- 下部スライドアップメニュー（タブレット以下のサイズのみ） -->
        <div class="md:hidden fixed bottom-0 left-0 w-full z-[200]">
            <div
                class="@($"transition-transform will-change-transform duration-300 bg-white border-t border-gray-300 shadow-lg p-4 {(isMenuOpen ? "translate-y-0" : "translate-y-full")}")">
                <div class="flex flex-col items-center gap-4">
                    <div class="flex items-center gap-2 text-green-600 text-2xl font-bold">
                        <i class="fa-solid fa-check-circle"></i>
                        <span>完了</span>
                    </div>
                    <div class="text-gray-800 font-semibold truncate w-full text-center">@mergedFileName</div>
                    <div class="text-gray-600 text-sm">サイズ: @mergedFileSize</div>
                    <div class="text-gray-600 text-sm">ページ数: @mergedPageCount</div>
                    <SplitButton
                        PrimaryLabel="PDFでダウンロード"
                        OnPrimaryClick="DownloadMergedPdf"
                        MenuItems="@downloadMenuItems" />
                    <button
                        class="bg-neutral-500 hover:bg-neutral-600 text-white font-bold py-2 px-6 rounded-lg w-full flex items-center justify-center mt-4"
                        @onclick="StartNew">
                        <ResetIcon class="inline-block align-middle w-[1em] h-[1em]" />
                        新規作成
                    </button>
                </div>
                <button class="absolute top-2 right-4 text-2xl text-gray-500" @onclick="() => isMenuOpen = false">
                    <i class="fa-solid fa-xmark"></i>
                </button>
            </div>
            <!-- 展開ボタン -->
            @if (!isMenuOpen)
            {
                <button
                    class="fixed bottom-4 left-1/2 -translate-x-1/2 z-[201] bg-white rounded-full shadow px-8 py-3 border border-gray-300 flex items-center gap-3 text-lg font-bold hover:bg-blue-50 transition min-w-[260px]"
                    @onclick="() => isMenuOpen = true">
                    <i class="fa-solid fa-check-circle text-green-600 text-2xl"></i>
                    <span>完了</span>
                    <i class="fa-solid fa-chevron-up ml-2"></i>
                </button>
            }
        </div>
        <!-- メニュー展開時はPDFのスクロールを禁止 -->
        @if (isMenuOpen)
        {
            <div class="fixed inset-0 bg-black/30 z-[199] touch-none" @onclick="() => isMenuOpen = false"></div>
        }
    </div>
}
@if (isBusy)
{
    <LoadingOverlay Message="処理中です..." />
}
<!-- メッセージ表示エリア -->
@if (message != null && !string.IsNullOrEmpty(message.Text))
{
    <MessageBar Message="@message.Text"
                Type="@message.Type"
                OnClose="ClearMessage"
                AutoCloseMs="5000" />
}
<PasswordInputDialog IsOpen="@isPasswordDialogOpen" FileName="@passwordDialogFileName" OnClose="OnPasswordDialogClose" />

<!-- ファイル選択用の隠しinput -->
<InputFile OnChange="HandleFileSelectionAsync" multiple class="hidden" id="fileInput" />
<HeaderFooterDialog IsOpen="@showHeaderFooterDialog" 
                    OnApply="ApplyHeaderFooter" 
                    OnClose="() => showHeaderFooterDialog = false" />

@code {
    protected override void OnInitialized()
    {
        PdfDataService.OnChange += OnServiceChanged;
        PdfDataService.PasswordInputDialogFunc = ShowPasswordInputDialogAsync;

        // ページ単位表示を強制
        PdfDataService.SwitchDisplayMode(DisplayMode.Page);
    }

    private void OnServiceChanged()
    {
        InvokeAsync(StateHasChanged);
    }

    [JSInvokable("SetVisiblePageFromJs")]
    public Task SetVisiblePageFromJs(int pageIndex)
    {
        try
        {
            if (pageIndex < 0) pageIndex = 0;
            if (pageIndex >= DisplayItems.Count) pageIndex = Math.Max(0, DisplayItems.Count - 1);
            previewIndex = pageIndex;
            displayedPageNumber = pageIndex + 1;
            InvokeAsync(StateHasChanged);
        }
        catch { }
        return Task.CompletedTask;
    }

    // 上部バーの入力でページ移動（1始まりの値を受ける）
    private async Task OnTopBarPageInputChanged(ChangeEventArgs e)
    {
        if (int.TryParse(e?.Value?.ToString(), out var v))
        {
            var target = Math.Max(1, Math.Min(Math.Max(1, DisplayItems.Count), v));
            displayedPageNumber = target;
            var targetIndex = target - 1;
            try
            {
                // スクロール移動（既存のヘルパーを利用）
                await JSRuntime.InvokeVoidAsync("trimPreviewArea.scrollToPage", targetIndex);
                // 画像プレビュー更新など必要ならこちらも呼ぶ（軽量）
                _ = ShowPreviewAsync(targetIndex);
            }
            catch { }
        }
    }

    public void Dispose()
    {
        PdfDataService.OnChange -= OnServiceChanged;
        _dotNetRef?.Dispose();

        try
        {
            if (_windowResizeRegistered)
            {
                _ = JSRuntime.InvokeVoidAsync("unregisterWindowResize");
                _windowResizeRegistered = false;
            }
        }
        catch { }

        try { _ = JSRuntime.InvokeVoidAsync("unregisterVisiblePageObserver", "trim-preview-container"); } catch { }
        _visibleObserverLastCount = -1;

        try
        {
            _ = JSRuntime.InvokeVoidAsync("unregisterPanelResize");
        }
        catch { }

        if (_dropAreaRegistered)
        {
            JSRuntime.InvokeVoidAsync("unregisterDropArea", "drop-area");
            _dropAreaRegistered = false;
        }

        passwordTcs?.TrySetCanceled();
        passwordTcs = null;
    }
    private bool isBusy = false;
    private string? mergedPdfUrl;
    private MessageInfo? message;
    private void ShowMessage(string? text, MessageType type)
    {
        message = new MessageInfo { Text = text ?? string.Empty, Type = type };
        StateHasChanged();
    }

    private void ClearMessage()
    {
        message = null;
    }
    // 統一アーキテクチャ対応プロパティ
    private DisplayMode CurrentDisplayMode => PdfDataService.GetModel().CurrentMode;
    private OperationMode CurrentOperationMode = OperationMode.Trim;
    private List<DisplayItem> DisplayItems => PdfDataService.GetDisplayItems();
    private bool IsFilesLoaded => DisplayItems.Any();

    private int previewIndex = -1;

    private string? previewImageUrl = null;
    private bool isPreviewLoading = false;
    // ファイル単位表示時の現在ページ番号（0始まり）
    private int CurrentFilePageIndex => GetCurrentFilePageIndex();
    // ファイル単位表示時の総ページ数
    private int CurrentFilePageCount => GetCurrentFilePageCount();

    // ファイル単位表示時のファイル内ページ番号（0始まり）
    // プレビュー中のファイル内で、何ページ目を表示しているか
    private int filePageIndex = 0;
    private DotNetObjectReference<Trim>? _dotNetRef;
    private bool isDragOver = false;
    private bool isMenuOpen = false;
    private string mergedFileName = "";
    private string mergedFileSize = "";
    private int mergedPageCount = 0;
    public class PdfStampPosition
    {
        public string Text { get; set; } = "";
        public int OffsetX { get; set; } // 端からのX距離(px)
        public int OffsetY { get; set; } // 端からのY距離(px)
        public PdfStampCorner Corner { get; set; } // 左上/上/右上/左下/下/右下
    }

    public enum PdfStampCorner
    {
        TopLeft, Top, TopRight, BottomLeft, Bottom, BottomRight
    }
    private int GetCurrentFilePageIndex()
    {
        if (CurrentDisplayMode == DisplayMode.Page || previewIndex < 0 || previewIndex >= DisplayItems.Count)
            return 0;
        return filePageIndex;
    }
    private int GetCurrentFilePageCount()
    {
        if (CurrentDisplayMode == DisplayMode.Page || previewIndex < 0 || previewIndex >= DisplayItems.Count)
            return 1;
        return DisplayItems[previewIndex].PageCount;
    }

    private List<ToggleButtonItem<bool>> toggleItems = new()
    {
        new ToggleButtonItem<bool>
        {
            Value = true,
            Label = "トリミング",
            IconFragment = builder =>
            {
                builder.OpenComponent(0, typeof(TrimIcon));
                builder.AddAttribute(1, "Class", "w-5 h-5");
                builder.CloseComponent();
            }
        },
        new ToggleButtonItem<bool>
        {
            Value = false,
            Label = "パン",
            IconFragment = builder =>
            {
                builder.OpenComponent(0, typeof(PanIcon));
                builder.AddAttribute(1, "Class", "w-5 h-5");
                builder.CloseComponent();
            }
        }
    };

    private async Task OnToggleDrawingMode(bool drawingMode)
    {
        // drawingMode == false のときパンを有効にする
        isDrawingMode = drawingMode;
        try
        {
            await JSRuntime.InvokeVoidAsync("setPreviewPanEnabled", !drawingMode);
        }
        catch { }
    }

    private List<SplitButton.MenuActionItem> downloadMenuItems => new()
    {
        new SplitButton.MenuActionItem
        {
            Label = "PDFでダウンロード",
            OnClick = EventCallback.Factory.Create(this, DownloadMergedPdf)
        },
        new SplitButton.MenuActionItem
        {
            Label = "PNG画像でダウンロード",
            OnClick = EventCallback.Factory.Create(this, DownloadMergedPng)
        }
    };

    private List<ActionButtonItem> primaryActions => new()
    {
        new ActionButtonItem
        {
            Label = "完了",
            IconHtml = "<i class='fa-solid fa-arrow-right text-xl ml-2'></i>",
            Title = "完了",
            OnClick = EventCallback.Factory.Create(this, MergePDFs),
            ButtonClass = "bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-8 rounded-lg min-w-[44px] transition hidden md:flex h-[44px]",
            IconPosition = "right"
        }
    };

    private async Task AddPdfFile()
    {
        await OpenFileDialog();
    }

    private async Task MovePreview(int direction)
    {
        if (CurrentDisplayMode == DisplayMode.File)
        {
            var pageCount = DisplayItems[previewIndex].PageCount;
            var nextPage = filePageIndex + direction;
            if (nextPage >= 0 && nextPage < pageCount)
            {
                filePageIndex = nextPage;
                await ShowPreviewAsync(previewIndex, filePageIndex);
            }
        }
        else
        {
            var nextIndex = previewIndex + direction;
            if (nextIndex >= 0 && nextIndex < DisplayItems.Count)
            {
                await ShowPreviewAsync(nextIndex);
            }
        }
    }
    private async Task OnPreviewPageInputChanged(ChangeEventArgs e)
    {
        if (CurrentDisplayMode == DisplayMode.Page) return;

        if (int.TryParse(e.Value?.ToString(), out int inputPage))
        {
            // 1以上、最大ページ数以下のみ有効
            if (inputPage >= 1 && inputPage <= CurrentFilePageCount)
            {
                filePageIndex = inputPage - 1;
                await ShowPreviewAsync(previewIndex, filePageIndex);
            }
        }
    }
    private async Task RotatePreviewLeft()
    {
        if (previewIndex >= 0 && previewIndex < DisplayItems.Count)
        {
            await PdfDataService.RotateItemAsync(previewIndex, -90);
            await ShowPreviewAsync(previewIndex);
        }
    }

    private async Task RotatePreviewRight()
    {
        if (previewIndex >= 0 && previewIndex < DisplayItems.Count)
        {
            await PdfDataService.RotateItemAsync(previewIndex, 90);
            await ShowPreviewAsync(previewIndex);
        }
    }


    private async Task ShowPreviewAsync(int fileIndex, int pageIndex = 0)
    {
        previewIndex = fileIndex;
        filePageIndex = pageIndex;
        previewImageUrl = null;
        isPreviewLoading = true;
        StateHasChanged();
        try
        {
            if (CurrentDisplayMode == DisplayMode.File)
            {
                var fileMeta = DisplayItems[fileIndex].RawData as FileMetadata;
                if (fileMeta == null)
                {
                    previewImageUrl = null;
                    return;
                }
                // Idが「ファイル名+_file」になっているのでRawDataからIdを取得
                var fileId = fileMeta.FileId;

                var model = PdfDataService.GetModel();
                var filePages = model.Pages.Where(p => p.FileId == fileId).OrderBy(p => p.OriginalPageIndex).ToList();
                if (pageIndex >= 0 && pageIndex < filePages.Count)
                {
                    var page = filePages[pageIndex];
                    previewImageUrl = await PdfDataService.GetPreviewImageAsync(fileId, page.OriginalPageIndex);
                }
                else
                {
                    previewImageUrl = null;
                }
            }
            else
            {
                // ページ単位表示時は従来通り
                previewImageUrl = await PdfDataService.GetPreviewImageAsync(DisplayItems[fileIndex].Id);
            }
        }
        catch
        {
            // 失敗時はサムネイル表示
            previewImageUrl = DisplayItems[fileIndex].Thumbnail;
        }

        isPreviewLoading = false;
        StateHasChanged();
    }


    private void ClosePreview()
    {
        previewIndex = -1;
        StateHasChanged();
    }
    private void SwitchToFileMode()
    {
        if (CurrentDisplayMode == DisplayMode.File) return;
        PdfDataService.SwitchDisplayMode(DisplayMode.File);
    }

    private void SwitchToPageMode()
    {
        if (CurrentDisplayMode == DisplayMode.Page) return;
        PdfDataService.SwitchDisplayMode(DisplayMode.Page);
    }

    public class MergePageDto
    {
        public string FileId { get; set; } = "";
        public string FileName { get; set; } = "";
        public string PageData { get; set; } = "";
        public bool IsPdf { get; set; }
        public int RotateAngle { get; set; }
    }
    // PDF結合処理
    private async Task MergePDFs()
    {
        try
        {
            isBusy = true;
            StateHasChanged();
            await Task.Yield();

            var mergeItems = PdfDataService.GetModel().Pages;

            // 準備できていないページがある場合は中断
            var notReadyCount = mergeItems.Count(item => string.IsNullOrEmpty(item.PageData) || item.HasError);
            if (notReadyCount > 0)
            {
                ShowMessage($"PDFの読み込みが完了していないページが {notReadyCount} ページあります。", MessageType.Warn);
                return;
            }

            if (mergeItems.Count == 0)
            {
                ShowMessage("結合対象がありません。", MessageType.Error);
                return;
            }

            ClearMessage();

            // JSに渡すためのデータを整形
            var mergeData = mergeItems.Select(item => new MergePageDto
            {
                FileId = item.FileId,
                FileName = item.FileName,
                PageData = item.PageData,
                IsPdf = Path.GetExtension(item.FileName).ToLowerInvariant() == ".pdf",
                RotateAngle = item.RotateAngle % 360
            }).ToList();

            //  JSで結合処理
            mergedPdfUrl = await JSRuntime.InvokeAsync<string>("mergePDFPages", mergeData);

            if (!string.IsNullOrEmpty(mergedPdfUrl))
            {
                mergedFileName = $"merge_{DateTime.Now:yyyyMMddHHmm}.pdf";
                mergedFileSize = await JSRuntime.InvokeAsync<string>("getPdfFileSize", mergedPdfUrl);
                mergedPageCount = mergeItems.Count;

                CompletionState.SetCompletion(CompletionStateService.CompletionType.Merged);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"An error occurred: {ex.Message}");
            ShowMessage("PDF/画像の結合中にエラーが発生しました。", MessageType.Error);
        }
        finally
        {
            isBusy = false;
            StateHasChanged();
        }
    }

    // アイテム削除
    private void RemovePage(int index)
    {

        try
        {
            PdfDataService.RemoveItem(index);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error removing item {index}: {ex.Message}");
            ShowMessage($"削除に失敗しました: {ex.Message}", MessageType.Error);
        }
    }


    // ファイルダイアログを開く
    private async Task OpenFileDialog()
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("openFileDialog", "fileInput");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error opening file dialog: {ex.Message}");
            ShowMessage($"ファイル選択ダイアログの表示に失敗しました: {ex.Message}", MessageType.Error);
        }
    }

    // その他のメソッド
    private void BackToEdit()
    {
        CompletionState.ResetAll();
        StateHasChanged();
    }

    private void StartNew()
    {
        CompletionState.ResetAll(); // グローバルな完了フラグをリセット

        AppResetHelper.ResetPage(
            PdfDataService,
            () => { /* ページ固有の状態リセット */ },
            () => { 
                mergedPdfUrl = null;
                mergedFileName = "";
                mergedFileSize = "";
                mergedPageCount = 0;
            },
            msg => ShowMessage(msg, MessageType.Error),
            StateHasChanged
        );
    }

    private async Task OnSwapWithNext(int index)
    {
        try
        {
            PdfDataService.SwapWithNext(index);
            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            ShowMessage($"サムネイルの入れ替えに失敗しました: {ex.Message}", MessageType.Error);
        }
    }

    // 回転処理
    private async Task RotatePage(int index, int angle = 90)
    {
        if (index >= 0 && index < DisplayItems.Count)
        {
            try
            {
                await PdfDataService.RotateItemAsync(index, angle);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error rotating item {index}: {ex.Message}");
                ShowMessage($"アイテム {index + 1} の回転に失敗しました: {ex.Message}", MessageType.Error);
            }
        }
    }

    private async Task RotateFile(string fileId)
    {
        await PdfDataService.RotateFileAsync(fileId, 90);
    }

    private Task RotateAllLeft() => RotateAll(-90);
    private Task RotateAllRight() => RotateAll(90);
    private async Task RotateAll(int angle)
    {
        isBusy = true;
        StateHasChanged();
        await Task.Yield();

        await PdfDataService.RotateAllAsync(CurrentDisplayMode, DisplayItems, angle);

        isBusy = false;
        StateHasChanged();

        // 回転後は矩形をクリア
        trimRects.Clear();
        foreach (var item in previewItems)
        {
            item.TrimRect = null;
        }
    }
    private async Task DuplicateItem(int index)
    {
        if (CurrentDisplayMode == DisplayMode.File)
        {
            var fileItem = DisplayItems[index];
            await PdfDataService.DuplicateItemAsync(fileItem.Id, true, index + 1);
        }
        else if (CurrentDisplayMode == DisplayMode.Page)
        {
            var pageItem = DisplayItems[index];
            await PdfDataService.DuplicateItemAsync(pageItem.Id, false, index + 1);
        }
    }

    // 静的インスタンスで現在のコンポーネントを参照（JavaScript連携用）
    public static Trim? _currentInstance;

    // 並び替え時に@keyとして使い、Blazorの仮想DOMキャッシュをリセットしてサムネイルリストを強制的に再生成するためのバージョン番号
    private int sortVersion = 0;
    // 実際の並び替え処理
    public async Task UpdateOrderInternal(string pageType, int oldIndex, int newIndex)
    {
        try
        {
            if (oldIndex >= 0 && oldIndex < DisplayItems.Count &&
            newIndex >= 0 && newIndex < DisplayItems.Count &&
            oldIndex != newIndex)
            {
                // 統一データサービスを使用して並び替え
                PdfDataService.MoveItem(oldIndex, newIndex);
                sortVersion++; 
                await InvokeAsync(StateHasChanged);
            }
            else
            {
                return;
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error in UpdateOrderInternal: {ex.Message}");
            ShowMessage($"並び替えに失敗しました: {ex.Message}", MessageType.Error);
        }
    }

    // JavaScript から呼び出されるPDF挿入メソッド
    [JSInvokable("Trim_InsertPdfAtPositionFromJS")]
    public static async Task InsertPdfAtPositionFromJS(int position)
    {
        if (_currentInstance != null)
        {
            await _currentInstance.InsertPdfAtPosition(position);
        }
    }

    // 空白ページを挿入
    public async Task InsertBlankPage(int position)
    {
        isBusy = true;
        StateHasChanged();
        await Task.Yield();

        await PdfDataService.InsertBlankPageWithDisplayModeAsync(
            CurrentDisplayMode, DisplayItems, position);

        isBusy = false;
        StateHasChanged();
    }

    // PDF挿入
    public async Task InsertPdfAtPosition(int position)
    {
        await PdfDataService.OpenInsertPdfDialogAsync(
            CurrentDisplayMode,
            DisplayItems,
            position,
            pos => insertPosition = pos,
            msg => ShowMessage(msg, MessageType.Error)
        );
    }

    private int insertPosition = -1;

    // 挿入用ファイル選択処理
    private async Task HandleFileSelectionAsync(InputFileChangeEventArgs e)
    {
        isBusy = true;
        StateHasChanged();
        await Task.Yield();

        await PdfDataService.HandleFileInputAsync(
            e,
            insertPosition >= 0 ? insertPosition : null,
            msg => { ShowMessage(msg, MessageType.Error); },
            msg => { ShowMessage(msg, MessageType.Warn); }
        );
        insertPosition = -1;
        isBusy = false;
        StateHasChanged();
    }

    private List<ActionButtonItem> resetActions => new()
    {
        new ActionButtonItem
        {
            Icon = builder =>
            {
                builder.OpenComponent(0, typeof(ResetIcon));
                builder.AddAttribute(1, "Class", "w-5 h-5"); // 必要に応じてサイズ調整
                builder.CloseComponent();
            },
            Title = "最初からやり直す",
            OnClick = EventCallback.Factory.Create(this, StartNew),
            ButtonClass = "bg-amber-200 hover:bg-amber-300 border border-amber-400 font-bold py-2 px-3 rounded"
        }
    };

    private List<ActionButtonItem> backToEditActions => new()
    {
        new ActionButtonItem
        {
            Label = "編集に戻る",
            IconHtml = "<i class='fa-solid fa-arrow-left'></i>",
            Title = "編集に戻る",
            OnClick = EventCallback.Factory.Create(this, BackToEdit),
        }
    };

    private List<ActionButtonItem> rotateActions => new()
    {
        new ActionButtonItem
        {
            Label = "左",
            Icon = builder =>
            {
                builder.OpenComponent(0, typeof(RotateLeftIcon));
                builder.AddAttribute(1, "Class", "w-6 h-6"); // ← ここでパラメータ指定
                builder.CloseComponent();
            },
            Title = "左回転",
            OnClick = EventCallback.Factory.Create(this, RotateAllLeft),
            IconPosition = "left"
        },
        new ActionButtonItem
        {
            Label = "右",
            Icon = builder =>
            {
                builder.OpenComponent(0, typeof(RotateRightIcon));
                builder.AddAttribute(1, "Class", "w-6 h-6"); // ← ここでパラメータ指定
                builder.CloseComponent();
            },
            Title = "右回転",
            OnClick = EventCallback.Factory.Create(this, RotateAllRight),
            IconPosition = "left"
        }
    };

    private List<ActionButtonItem> zoomActions => new()
    {
        new ActionButtonItem
        {
            Label = "幅に合わせる",
            Icon = builder =>
            {
                builder.OpenComponent(0, typeof(FitWidthIcon));
                builder.AddAttribute(1, "Class", "w-6 h-6"); // ← ここでパラメータ指定
                builder.CloseComponent();
            },
            Title = "幅に合わせる",
            OnClick = EventCallback.Factory.Create(this, FitPreviewWidth),
        },
        new ActionButtonItem
        {
            Label = "縮小",
            Icon = builder =>
            {
                builder.OpenComponent(0, typeof(ZoomOutIcon));
                builder.AddAttribute(1, "Class", "w-6 h-6"); // ← ここでパラメータ指定
                builder.CloseComponent();
            },
            Title = "縮小",
            OnClick = EventCallback.Factory.Create(this, ZoomOut),
            IconPosition = "left"
        },
        new ActionButtonItem
        {
            Label = "拡大",
            Icon = builder =>
            {
                builder.OpenComponent(0, typeof(ZoomInIcon));
                builder.AddAttribute(1, "Class", "w-6 h-6"); // ← ここでパラメータ指定
                builder.CloseComponent();
            },
            Title = "拡大",
            OnClick = EventCallback.Factory.Create(this, ZoomIn),
            IconPosition = "left"
        }
    };

    // 全ページ適用用アクション（トップバー表示）
    private List<ActionButtonItem> applyTrimActions => new()
    {
        new ActionButtonItem
        {
            Label = "",
            Title = "現在ページに描かれているトリミング範囲をすべてのページにコピーします",
            OnClick = EventCallback.Factory.Create(this, ApplyCurrentTrimToAll),
            IconHtml = "現在範囲を全ページに適用"
        }
    };

    // 現在表示ページのトリム矩形を取得して全ページへ適用する
    private async Task ApplyCurrentTrimToAll()
    {
        if (DisplayItems == null || DisplayItems.Count == 0)
        {
            ShowMessage("適用対象がありません。", MessageType.Warn);
            return;
        }

        var idx = Math.Max(0, Math.Min(DisplayItems.Count - 1, displayedPageNumber - 1));
        var trimInfo = PdfDataService.GetTrimRect(idx); // TrimRectInfo? (normalized 0..1)
        if (trimInfo == null)
        {
            ShowMessage("現在ページにトリミング範囲が設定されていません。", MessageType.Warn);
            return;
        }

        isBusy = true;
        StateHasChanged();
        try
        {
            for (int i = 0; i < DisplayItems.Count; i++)
            {
                // SetTrimRect expects normalized coords (PdfDataService API uses normalized TrimRectInfo)
                await PdfDataService.SetTrimRect(i, trimInfo.X, trimInfo.Y, trimInfo.Width, trimInfo.Height);
            }
            ShowMessage("現在のトリム範囲をすべてのページに適用しました。", MessageType.Success);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"ApplyCurrentTrimToAll error: {ex.Message}");
            ShowMessage("全ページへの適用に失敗しました。", MessageType.Error);
        }
        finally
        {
            isBusy = false;
            StateHasChanged();
        }
    }

    private async Task ReverseOrder()
    {
        isBusy = true;
        StateHasChanged();
        await Task.Yield();

        if (CurrentDisplayMode == DisplayMode.File)
        {
            // ファイル単位：ファイルごと逆順
            var model = PdfDataService.GetModel();
            var fileIds = DisplayItems.Select(x => x.Id).Reverse().ToList();
            PdfDataService.ReorderFiles(fileIds);
        }
        else if (CurrentDisplayMode == DisplayMode.Page)
        {
            // ページ単位：ページごと逆順
            PdfDataService.ReversePages();
        }

        isBusy = false;
        StateHasChanged();
    }

    private async Task SelectSort(bool ascending)
    {
        await SortByName(ascending);
    }
    private async Task SortByName(bool ascending)
    {
        isBusy = true;
        StateHasChanged();
        await Task.Yield();

        if (CurrentDisplayMode == DisplayMode.File)
        {
            var sorted = ascending
            ? DisplayItems.OrderBy(x => x.DisplayName).Select(x => x.Id).ToList()
            : DisplayItems.OrderByDescending(x => x.DisplayName).Select(x => x.Id).ToList();
            PdfDataService.ReorderFiles(sorted);
        }
        else if (CurrentDisplayMode == DisplayMode.Page)
        {
            PdfDataService.SortPagesByName(ascending);
        }

        isBusy = false;
        StateHasChanged();
    }

    [JSInvokable]
    public async Task OnJsFileDropped(string fileName, string contentType, string base64Data)
    {
        isBusy = true;
        StateHasChanged();
        await Task.Yield();

        try
        {
            await PdfDataService.HandleDroppedFileAsync(
                fileName,
                base64Data,
                msg => { ShowMessage(msg, MessageType.Error); },
                msg => { ShowMessage(msg, MessageType.Warn); },
                async (name, data) => await PdfDataService.AddOrInsertPdfFileAsync(name, data, null),
                async (name, data) => await PdfDataService.AddOrInsertImageFileAsync(name, data, null)
            );
        }
        finally
        {
            isBusy = false;
            StateHasChanged();
        }
    }

    private string CurrentDisplayModeString => CurrentDisplayMode == DisplayMode.File ? "File" : "Page";

    private void OnToggleMode(string mode)
    {
        if (mode == "File")
            SwitchToFileMode();
        else if (mode == "Page")
            SwitchToPageMode();
    }

    private bool isPasswordDialogOpen = false;
    private string passwordDialogFileName = "";
    private TaskCompletionSource<string?>? passwordTcs;

    // サービスから呼ばれる
    public Task<string?> ShowPasswordInputDialogAsync(string fileName)
    {
        isPasswordDialogOpen = true;
        passwordDialogFileName = fileName;
        passwordTcs = new TaskCompletionSource<string?>();
        StateHasChanged();
        return passwordTcs.Task;
    }

    private void OnPasswordDialogClose(string? password)
    {
        isPasswordDialogOpen = false;
        passwordTcs?.SetResult(password);
        passwordTcs = null;
        StateHasChanged();
    }

    private bool showHeaderFooterDialog = false;

    // 既存のaddMenuItems配列に追加
    private List<DropdownMenuItem> addMenuItems => new()
    {
        new DropdownMenuItem
        {
            Label = "空白ページを追加",
            OnClick = EventCallback.Factory.Create(this, () => InsertBlankPage(DisplayItems.Count))
        },
        new DropdownMenuItem
        {
            Label = "ドキュメントを追加",
            OnClick = EventCallback.Factory.Create(this, AddPdfFile)
        },
        new DropdownMenuItem
        {
            Label = "ヘッダー・フッター",
            OnClick = EventCallback.Factory.Create(this, ShowHeaderFooterDialog)
        }
    };

    private void ShowHeaderFooterDialog()
    {
        showHeaderFooterDialog = true;
        StateHasChanged();
    }

    private async Task ApplyHeaderFooter(HeaderFooterSetting setting)
    {
        if (!setting.Stamps.Any())
        {
            ShowMessage("スタンプが設定されていません。", MessageType.Warn);
            return;
        }

        try
        {
            isBusy = true;
            StateHasChanged();
            await Task.Yield();

            var model = PdfDataService.GetModel();
            var pages = model.Pages;

            if (!pages.Any())
            {
                ShowMessage("処理対象のページがありません。", MessageType.Warn);
                return;
            }

            // 準備できていないページがある場合は中断
            var notReadyCount = pages.Count(p => string.IsNullOrEmpty(p.PageData) || p.HasError);
            if (notReadyCount > 0)
            {
                ShowMessage($"PDFの読み込みが完了していないページが {notReadyCount} ページあります。", MessageType.Warn);
                return;
            }

            var totalPages = pages.Count;

            // 各ページにヘッダー・フッターを適用
            for (int i = 0; i < pages.Count; i++)
            {
                var page = pages[i];

                try
                {
                    var stampData = CreateStampsForCoordinateTransform(setting.Stamps, page.RotateAngle, totalPages, i);

                    var stampedPdfBytes = await JSRuntime.InvokeAsync<byte[]>(
                        "addStampsToPdf", 
                        page.PageData, 
                        stampData
                    );

                    var stampedBase64 = Convert.ToBase64String(stampedPdfBytes);
                    page.PageData = stampedBase64;

                    // サムネイル再生成
                    var newThumbnail = await JSRuntime.InvokeAsync<string>(
                        "generatePdfThumbnailFromPageData", 
                        stampedBase64
                    );

                    if (!string.IsNullOrEmpty(newThumbnail))
                    {
                        page.Thumbnail = newThumbnail;
                    }
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"ページ {i + 1} のヘッダー・フッター適用でエラー: {ex.Message}");
                    ShowMessage($"ページ {i + 1} の処理中にエラーが発生しました。", MessageType.Error);
                }
            }

            ShowMessage($"{pages.Count} ページにヘッダー・フッターを適用しました。", MessageType.Success);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"ヘッダー・フッター適用エラー: {ex.Message}");
            ShowMessage("ヘッダー・フッターの適用中にエラーが発生しました。", MessageType.Error);
        }
        finally
        {
            isBusy = false;
            StateHasChanged();
        }
    }

    private List<object> CreateStampsForCoordinateTransform(List<StampPosition> originalStamps, int rotateAngle, int totalPages, int currentPageIndex)
    {
        var stampData = new List<object>();

        foreach (var stamp in originalStamps)
        {
            var stampObject = new
            {
                corner = stamp.Corner.ToString(), // ← 画面上での位置指定
                text = stamp.Text,
                isSerial = stamp.IsSerial,
                isZeroPadded = stamp.IsZeroPadded,
                totalPages = totalPages,
                currentPageIndex = currentPageIndex,
                rotateAngle = rotateAngle, // ← JavaScript側で座標変換に使用
                offsetX = stamp.OffsetX,
                offsetY = stamp.OffsetY,
                fontSize = stamp.FontSize,
                color = new { r = stamp.Color.R / 255.0, g = stamp.Color.G / 255.0, b = stamp.Color.B / 255.0 }
            };

            stampData.Add(stampObject);
        }

        return stampData;
    }

    private bool _renderedMergedPages = false;
    private bool _dropAreaRegistered = false;
    private bool previewItemsLoaded = false;
    private bool previewZoomInitialized = false;
    private int displayedPageNumber = 1;
    private int _visibleObserverLastCount = -1;
    private bool _windowResizeRegistered = false;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _currentInstance = this;
            _dotNetRef = DotNetObjectReference.Create(this);
            try
            {
                // register window resize notifier (JS -> .NET: OnWindowResizedFromJs)
                await JSRuntime.InvokeVoidAsync("registerWindowResize", _dotNetRef);
                _windowResizeRegistered = true;
            }
            catch (Exception ex)
            {
                Console.WriteLine($"registerWindowResize failed: {ex.Message}");
            }
        }

        if (IsFilesLoaded && DisplayItems.Any())
        {
            if (DisplayItems.Count != _visibleObserverLastCount)
            {
                try
                {
                    await JSRuntime.InvokeVoidAsync("registerVisiblePageObserver", _dotNetRef, "trim-preview-container", 500);
                    _visibleObserverLastCount = DisplayItems.Count;
                }
                catch { _visibleObserverLastCount = -1; }
            }
        }
        else
        {
            // ensure cleared when no items
            if (_visibleObserverLastCount != -1)
            {
                try { await JSRuntime.InvokeVoidAsync("unregisterVisiblePageObserver", "trim-preview-container"); } catch { }
                _visibleObserverLastCount = -1;
            }
        }

        if (!previewZoomInitialized)
        {
            await ApplyPreviewZoomAsync();
            try { await JSRuntime.InvokeVoidAsync("computeAndApplyFitZoom"); } catch { }
            previewZoomInitialized = true;
        }

        // 初期画面のときのみ登録
        if (!IsFilesLoaded && !CompletionState.ShowMergedResult)
        {
            await JSRuntime.InvokeVoidAsync("registerSelectDropArea", _dotNetRef);
        }

        // drop-areaが表示され、まだ登録していない場合のみ
        if (!_dropAreaRegistered && IsFilesLoaded && DisplayItems.Any())
        {
            await JSRuntime.InvokeVoidAsync("registerDropArea", "drop-area", _dotNetRef);
            _dropAreaRegistered = true;
        }
        else if (_dropAreaRegistered && (!IsFilesLoaded || !DisplayItems.Any()))
        {
            // drop-areaが消えたらフラグを戻す（必要ならJSでunregisterも）
            _dropAreaRegistered = false;
        }

        if (IsFilesLoaded && DisplayItems.Any())
        {
            if (!previewZoomInitialized)
            {
                await ApplyPreviewZoomAsync();
                previewZoomInitialized = true;
            }

            // サムネイル描画
            foreach (var item in DisplayItems)
            {
                await JSRuntime.InvokeVoidAsync("drawImageToCanvas", $"trim-thumb-{item.Id}", item.Thumbnail);
            }
            
            // パネルリサイズ用のグローバルポインタリスナを登録
            try
            {
                await JSRuntime.InvokeVoidAsync("registerPanelResize", _dotNetRef, "splitter-handle");
            }
            catch (Exception ex)
            {
                // 開発環境等でJSが無い場合はログだけ出して継続
                Console.WriteLine($"registerPanelResize not available: {ex.Message}");
            }
        }

        // 毎回ドラッグ&ドロップとソート機能を再初期化（DOM更新時に必要）
        if (IsFilesLoaded && DisplayItems.Any())
        {
            await InvokeAsync(async () =>
            {
                try
                {
                    await Task.Delay(50); // DOM更新完了を待つ
                    await JSRuntime.InvokeVoidAsync("initializeSortable");
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Error initializing interactions: {ex.Message}");
                }
            });
        }
        if (CompletionState.ShowMergedResult && !string.IsNullOrEmpty(mergedPdfUrl) && mergedPageCount > 0 && !_renderedMergedPages)
        {
            _renderedMergedPages = true;
            var canvasIds = Enumerable.Range(0, mergedPageCount)
            .Select(i => $"merged-canvas-{i}")
            .ToArray();
            await JSRuntime.InvokeVoidAsync("renderPdfPages", mergedPdfUrl, canvasIds);
        }
        else if (!CompletionState.ShowMergedResult)
        {
            _renderedMergedPages = false;
        }

        try
        {
            await JSRuntime.InvokeVoidAsync("setPreviewPanEnabled", !isDrawingMode);
        }
        catch { }
    }

    [JSInvokable("OnWindowResizedFromJs")]
    public Task OnWindowResizedFromJs(int availableWidth, int sidebarWidth)
    {
        try
        {
            // Only recalc when not currently dragging panel
            if (isResizingPanel) return Task.CompletedTask;

            // desired ratio: thumb:preview = 1:3 => thumb = avail * (1/(1+3)) = 0.25
            var computed = (int)Math.Round(availableWidth * 0.25);

            // clamp to same min/max as CommitPanelWidth does
            var clamped = Math.Max(200, Math.Min( Math.Min(600, computed), (int)(BrowserViewportWidth() - 260) ));

            // update server state and reflect immediately in DOM
            thumbnailAreaWidth = clamped;
            StateHasChanged();

            // Reflect in DOM (no blocking)
            _ = JSRuntime.InvokeVoidAsync("applyThumbnailWidth", clamped);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"OnWindowResizedFromJs error: {ex.Message}");
        }
        return Task.CompletedTask;
    }

    [JSInvokable]
    public void SetDragOver(bool over)
    {
        isDragOver = over;
        StateHasChanged();
    }

    private async void DownloadMergedPdf()
    {
        if (string.IsNullOrEmpty(mergedPdfUrl) || string.IsNullOrEmpty(mergedFileName))
            return;

        try
        {
            await JSRuntime.InvokeVoidAsync(
            "downloadFileFromUrl",
            mergedPdfUrl,
            mergedFileName,
            "application/pdf"
            );
        }
        catch (Exception ex)
        {
            ShowMessage($"PDFのダウンロードに失敗しました: {ex.Message}", MessageType.Error);
        }
    }

    private async void DownloadMergedPng()
    {
        if (string.IsNullOrEmpty(mergedPdfUrl) || string.IsNullOrEmpty(mergedFileName))
            return;

        var pdfUrls = new List<string> { mergedPdfUrl };
        var pdfNames = new List<string> { mergedFileName };
        var zipName = Path.ChangeExtension(mergedFileName, ".zip");

        try
        {
            // JSでPNGまたはZIPダウンロードを実行
            await JSRuntime.InvokeVoidAsync(
            "downloadAllPdfsAsPngZip",
            pdfUrls,
            pdfNames,
            zipName
            );
        }
        catch (Exception ex)
        {
            ShowMessage($"PNGダウンロードに失敗しました: {ex.Message}",MessageType.Error);
            StateHasChanged();
        }
    }

    private bool HasAnyPageOrThumbnailError => DisplayItems.Any(item =>
        item.RawData is PageItem pageItem && (pageItem.HasThumbnailError || pageItem.HasPageDataError));

    private async Task ReloadAllThumbnailsAsync()
    {
        foreach (var item in DisplayItems)
        {
            if (item.RawData is PageItem pageItem && pageItem.HasThumbnailError && !pageItem.HasPageDataError)
            {
                await ReloadPageItem(item);
            }
        }
    }

    private async Task ForceReloadAllThumbnailsAsync()
    {
        foreach (var item in DisplayItems)
        {
            if (item.RawData is PageItem pageItem)
            {
                await ReloadPageItem(item);
            }
        }
    }
    private async Task ReloadPageItem(DisplayItem item)
    {
        // ページ単位の場合のみ対応
        if (item.RawData is PageItem pageItem)
        {
            pageItem.IsLoading = true;
            StateHasChanged();
            await Task.Yield();

            var errorMsg = await PdfDataService.ReloadPageAsync(pageItem.FileId, pageItem.OriginalPageIndex);

            StateHasChanged();

            if (!string.IsNullOrEmpty(errorMsg))
            {
                ShowMessage(errorMsg, MessageType.Error);
            }
        }
    }

    private bool isDrawingMode = true;
    private int selectedPageIndex = -1;


    // リサイズ関連
    private int thumbnailAreaWidth = 300;
    private bool isResizingPanel = false;
    private double resizeStartX = 0;
    private int resizeStartWidth = 0;
    
    private Task SelectPage(int index)
    {
        // 先にスクロール命令を投げる（非同期・待たない）
        _ = JSRuntime.InvokeVoidAsync("trimPreviewArea.scrollToPage", index);

        // 選択状態は後で反映（再描画は必要なら）
        selectedPageIndex = index;
        StateHasChanged();
        return Task.CompletedTask;
    }
    
    
    private async Task ApplyTrimRectToAll()
    {
        if (selectedTrimRect == null) return;
        
        for (int i = 0; i < previewItems.Count; i++)
        {
            var item = previewItems[i];
            var rect = new TrimRect
            {
                X = Math.Max(0, Math.Min(selectedTrimRect.X, item.ContainerWidth)),
                Y = Math.Max(0, Math.Min(selectedTrimRect.Y, item.ContainerHeight)),
                Width = Math.Min(selectedTrimRect.Width, item.ContainerWidth - selectedTrimRect.X),
                Height = Math.Min(selectedTrimRect.Height, item.ContainerHeight - selectedTrimRect.Y)
            };
            
            if (rect.Width > 0 && rect.Height > 0)
            {
                trimRects[i] = rect;
                item.TrimRect = rect;
                await PdfDataService.SetTrimRect(i, rect.X, rect.Y, rect.Width, rect.Height);
            }
        }
        StateHasChanged();
    }
    
    private void ClearCurrentTrimRect()
    {
        if (selectedPageIndex >= 0)
        {
            trimRects.Remove(selectedPageIndex);
            if (selectedPageIndex < previewItems.Count)
            {
                previewItems[selectedPageIndex].TrimRect = null;
            }
            PdfDataService.ClearTrimRect(selectedPageIndex);
            StateHasChanged();
        }
    }
    
    private void StartResize(PointerEventArgs e)
    {
        isResizingPanel = true;
        resizeStartX = e.ClientX;
        resizeStartWidth = thumbnailAreaWidth;
    }
    
    [JSInvokable]
    public void OnPanelMouseMove(double clientX)
    {
        if (isResizingPanel)
        {
            var delta = clientX - resizeStartX;
            thumbnailAreaWidth = Math.Max(200, Math.Min(600, resizeStartWidth + (int)delta));
            StateHasChanged();
        }
    }
    
    [JSInvokable]
    public void OnPanelMouseUp()
    {
        isResizingPanel = false;
    }

    // JS 側で視覚的に幅を変更 -> 最終確定で JS がこのメソッドを呼ぶ
    [JSInvokable("CommitPanelWidth")]
    public void CommitPanelWidth(int width)
    {
        // 必要な最小/最大チェックを行って UI に反映（1回の StateHasChanged）
        thumbnailAreaWidth = Math.Max(200, Math.Min( Math.Min(600, width), (int) (BrowserViewportWidth() - 260) ));
        StateHasChanged();
    }

    // （補助）ブラウザ幅を使った上限算出に安全に使えるようにする簡易ヘルパー
    private int BrowserViewportWidth()
    {
        // JS 経由で取る実装が望ましい。ここは既定値フォールバック
        return 1200;
    }

        // ...existing code...
        // --- 以下はビルドを通すための最小スタブ定義（本実装があれば置き換えてください） ---
        private Dictionary<int, TrimRect> trimRects = new();
        private List<PreviewItem> previewItems = new();
        private TrimRect? selectedTrimRect = null;
    
        // 矩形データ（以前の定義に合わせる）
        public class TrimRect
        {
            public double X { get; set; }
            public double Y { get; set; }
            public double Width { get; set; }
            public double Height { get; set; }
        }
    
        // プレビュー項目の最小情報（UI側で使っているプロパティのみ）
        public class PreviewItem
        {
            public int ContainerWidth { get; set; }
            public int ContainerHeight { get; set; }
            public TrimRect? TrimRect { get; set; }
        }

    private double previewZoom = 1.0;
    private const double ZoomStep = 0.25;
    private const double MinZoom = 0.25;
    private const double MaxZoom = 3.0;

    private async Task ApplyPreviewZoomAsync()
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("setPreviewZoom", previewZoom);
        }
        catch { 
            StateHasChanged();

        }
    }

    private async Task ZoomIn()
    {
        previewZoom = Math.Min(MaxZoom, previewZoom + ZoomStep);
        await ApplyPreviewZoomAsync();
    }

    private async Task ZoomOut()
    {
        previewZoom = Math.Max(MinZoom, previewZoom - ZoomStep);
        await ApplyPreviewZoomAsync();
    }

    private async Task FitPreviewWidth()
    {
        previewZoom = 1.0;
        await ApplyPreviewZoomAsync();
    }

    // 追加: トリミング用（正規化）ヘルパー（例）
    private (double x, double y, double w, double h) ToNormalizedRect(double x, double y, double w, double h, double containerW, double containerH)
    {
        if (containerW <= 0 || containerH <= 0) return (0,0,0,0);
        return (x / containerW, y / containerH, w / containerW, h / containerH);
    }
    private (int x, int y, int w, int h) FromNormalizedRect(double nx, double ny, double nw, double nh, double containerW, double containerH)
    {
        return ((int)Math.Round(nx * containerW), (int)Math.Round(ny * containerH), (int)Math.Round(nw * containerW), (int)Math.Round(nh * containerH));
    }

    private async Task SetPreviewZoomPreset(double z)
    {
        previewZoom = Math.Max(MinZoom, Math.Min(MaxZoom, z));
        await ApplyPreviewZoomAsync();
    }


}
